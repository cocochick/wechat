{"version":3,"sources":["potree.module.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["class LRUItem\n{\n\tconstructor(node)\n\t{\n\t\tthis.previous = null;\n\t\tthis.next = null;\n\t\tthis.node = node;\n\t}\n}\n\n/**\n * @class A doubly-linked-list of the least recently used elements.\n */\nclass LRU\n{\n\tconstructor()\n\t{\n\t\t// the least recently used item\n\t\tthis.first = null;\n\t\t// the most recently used item\n\t\tthis.last = null;\n\t\t// a list of all items in the lru list\n\t\tthis.items = {};\n\t\tthis.elements = 0;\n\t\tthis.numPoints = 0;\n\t}\n\n\tsize()\n\t{\n\t\treturn this.elements;\n\t}\n\n\tcontains(node)\n\t{\n\t\treturn this.items[node.id] == null;\n\t}\n\n\ttouch(node)\n\t{\n\t\tif(!node.loaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar item;\n\n\t\tif(this.items[node.id] == null)\n\t\t{\n\t\t\t// add to list\n\t\t\titem = new LRUItem(node);\n\t\t\titem.previous = this.last;\n\t\t\tthis.last = item;\n\t\t\tif(item.previous !== null)\n\t\t\t{\n\t\t\t\titem.previous.next = item;\n\t\t\t}\n\n\t\t\tthis.items[node.id] = item;\n\t\t\tthis.elements++;\n\n\t\t\tif(this.first === null)\n\t\t\t{\n\t\t\t\tthis.first = item;\n\t\t\t}\n\t\t\tthis.numPoints += node.numPoints;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// update in list\n\t\t\titem = this.items[node.id];\n\n\t\t\tif(item.previous === null)\n\t\t\t{\n\t\t\t\t// handle touch on first element\n\t\t\t\tif(item.next !== null)\n\t\t\t\t{\n\t\t\t\t\tthis.first = item.next;\n\t\t\t\t\tthis.first.previous = null;\n\t\t\t\t\titem.previous = this.last;\n\t\t\t\t\titem.next = null;\n\t\t\t\t\tthis.last = item;\n\t\t\t\t\titem.previous.next = item;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(item.next !== null)\n\t\t\t{\n\t\t\t\t// handle touch on any other element\n\t\t\t\titem.previous.next = item.next;\n\t\t\t\titem.next.previous = item.previous;\n\t\t\t\titem.previous = this.last;\n\t\t\t\titem.next = null;\n\t\t\t\tthis.last = item;\n\t\t\t\titem.previous.next = item;\n\t\t\t}\n\t\t}\n\t}\n\n\tremove(node)\n\t{\n\t\tvar lruItem = this.items[node.id];\n\t\tif(lruItem)\n\t\t{\n\t\t\tif(this.elements === 1)\n\t\t\t{\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!lruItem.previous)\n\t\t\t\t{\n\t\t\t\t\tthis.first = lruItem.next;\n\t\t\t\t\tthis.first.previous = null;\n\t\t\t\t}\n\t\t\t\tif(!lruItem.next)\n\t\t\t\t{\n\t\t\t\t\tthis.last = lruItem.previous;\n\t\t\t\t\tthis.last.next = null;\n\t\t\t\t}\n\t\t\t\tif(lruItem.previous && lruItem.next)\n\t\t\t\t{\n\t\t\t\t\tlruItem.previous.next = lruItem.next;\n\t\t\t\t\tlruItem.next.previous = lruItem.previous;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelete this.items[node.id];\n\t\t\tthis.elements--;\n\t\t\tthis.numPoints -= node.numPoints;\n\t\t}\n\t}\n\n\tgetLRUItem()\n\t{\n\t\tif(this.first === null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tvar lru = this.first;\n\n\t\treturn lru.node;\n\t}\n\n\ttoString()\n\t{\n\t\tvar string = \"{ \";\n\t\tvar curr = this.first;\n\n\t\twhile (curr !== null)\n\t\t{\n\t\t\tstring += curr.node.id;\n\t\t\tif(curr.next !== null)\n\t\t\t{\n\t\t\t\tstring += \", \";\n\t\t\t}\n\t\t\tcurr = curr.next;\n\t\t}\n\n\t\tstring += \"}\";\n\t\tstring += \"(\" + this.size() + \")\";\n\t\treturn string;\n\t}\n\n\tfreeMemory()\n\t{\n\t\tif(this.elements <= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\twhile(this.numPoints > Global.pointLoadLimit)\n\t\t{\n\t\t\tvar element = this.first;\n\t\t\tvar node = element.node;\n\t\t\tthis.disposeDescendants(node);\n\t\t}\n\t}\n\n\tdisposeDescendants(node)\n\t{\n\t\tvar stack = [];\n\t\tstack.push(node);\n\n\t\twhile (stack.length > 0)\n\t\t{\n\t\t\tvar current = stack.pop();\n\n\t\t\tcurrent.dispose();\n\t\t\tthis.remove(current);\n\n\t\t\tfor(var key in current.children)\n\t\t\t{\n\t\t\t\tif(current.children.hasOwnProperty(key))\n\t\t\t\t{\n\t\t\t\t\tvar child = current.children[key];\n\t\t\t\t\tif(child.loaded)\n\t\t\t\t\t{\n\t\t\t\t\t\tstack.push(current.children[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The worker manager is responsible for creating and managing worker instances.\n */\nclass WorkerManager\n{\n\tconstructor()\n\t{\n\t\tthis.workers = [];\n\n\t\tfor(var i = 0; i < WorkerManager.URLS.length; i++)\n\t\t{\n\t\t\tthis.workers.push([]);\n\t\t}\n\t}\n\n\t/**\n\t * Get a worker from the pool, if none available one will be created.\n\t */\n\tgetWorker(type)\n\t{\n\t\tif(this.workers[type].length > 0)\n\t\t{\n\t\t\treturn this.workers[type].pop();\n\t\t}\n\t\t\n\t\treturn new Worker(Global.workerPath + WorkerManager.URLS[type]);\n\t}\n\n\t/**\n\t * Return (reinsert) the worker into the pool.\n\t */\n\treturnWorker(type, worker)\n\t{\n\t\tthis.workers[type].push(worker);\n\t}\n\n\t/**\n\t * Run a task immediatly.\n\t */\n\trunTask(type, onMessage, message, transfer)\n\t{\n\t\tvar self = this;\n\n\t\tvar worker = this.getWorker(type);\n\t\tworker.onmessage = function(event)\n\t\t{\n\t\t\tonMessage(event);\n\t\t\tself.returnWorker(type, worker);\n\t\t};\n\n\t\tif(transfer !== undefined)\n\t\t{\n\t\t\tworker.postMessage(message, transfer);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tworker.postMessage(message);\n\t\t}\n\t}\n}\nWorkerManager.BINARY_DECODER = 0;\nWorkerManager.LAS_LAZ = 1;\nWorkerManager.LAS_DECODER = 2;\nWorkerManager.GREYHOUND = 3;\nWorkerManager.DEM = 4;\nWorkerManager.EPT_LAS_ZIP_DECODER = 5;\nWorkerManager.EPT_BINARY_DECODER = 6;\n\nWorkerManager.URLS = \n[\n\t\"/workers/BinaryDecoderWorker.js\",\n\t\"/workers/LASLAZWorker.js\",\n\t\"/workers/LASDecoderWorker.js\",\n\t\"/workers/GreyhoundBinaryDecoderWorker.js\",\n\t\"/workers/DEMWorker.js\",\n\t\"/workers/EptLaszipDecoderWorker.js\",\n\t\"/workers/EptBinaryDecoderWorker.js\"\n];\n\nfunction getBasePath()\n{\n\tif(document.currentScript && document.currentScript.src)\n\t{\n\t\tvar scriptPath = new URL(document.currentScript.src + \"/..\").href;\n\n\t\tif(scriptPath.slice(-1) === \"/\")\n\t\t{\n\t\t\tscriptPath = scriptPath.slice(0, -1);\n\t\t}\n\n\t\treturn scriptPath;\n\t}\n\telse\n\t{\n\t\tconsole.error(\"Potree: Was unable to find its script path using document.currentScript.\");\n\t}\n\n\treturn \"\";\n}\n\nvar Global = \n{\n\tdebug: {},\n\tworkerPath: getBasePath(),\n\tmaxNodesLoadGPUFrame: 20,\n\tmaxDEMLevel: 0,\n\tmaxNodesLoading: navigator.hardwareConcurrency !== undefined ? navigator.hardwareConcurrency : 4,\n\tpointLoadLimit: 1e10,\n\tnumNodesLoading: 0,\n\tmeasureTimings: false,\n\tworkerPool: new WorkerManager(),\n\tlru: new LRU(),\n\tpointcloudTransformVersion: undefined\n};\n\nvar PointAttributeNames =\n{\n\tPOSITION_CARTESIAN: 0, //float x, y, z,\n\tCOLOR_PACKED: 1, //byte r, g, b, a, I: [0,1]\n\tCOLOR_FLOATS_1: 2, //float r, g, b, I: [0,1]\n\tCOLOR_FLOATS_255: 3, //float r, g, b, I: [0,255]\n\tNORMAL_FLOATS: 4, //float x, y, z,\n\tFILLER: 5,\n\tINTENSITY: 6,\n\tCLASSIFICATION: 7,\n\tNORMAL_SPHEREMAPPED: 8,\n\tNORMAL_OCT16: 9,\n\tNORMAL: 10,\n\tRETURN_NUMBER: 11,\n\tNUMBER_OF_RETURNS: 12,\n\tSOURCE_ID: 13,\n\tINDICES: 14,\n\tSPACING: 15\n};\n\n/**\n * Some types of possible point attribute data formats\n *\n * @class\n */\nvar PointAttributeTypes =\n{\n\tDATA_TYPE_DOUBLE:\n\t{\n\t\tordinal: 0,\n\t\tsize: 8\n\t},\n\tDATA_TYPE_FLOAT:\n\t{\n\t\tordinal: 1,\n\t\tsize: 4\n\t},\n\tDATA_TYPE_INT8:\n\t{\n\t\tordinal: 2,\n\t\tsize: 1\n\t},\n\tDATA_TYPE_UINT8:\n\t{\n\t\tordinal: 3,\n\t\tsize: 1\n\t},\n\tDATA_TYPE_INT16:\n\t{\n\t\tordinal: 4,\n\t\tsize: 2\n\t},\n\tDATA_TYPE_UINT16:\n\t{\n\t\tordinal: 5,\n\t\tsize: 2\n\t},\n\tDATA_TYPE_INT32:\n\t{\n\t\tordinal: 6,\n\t\tsize: 4\n\t},\n\tDATA_TYPE_UINT32:\n\t{\n\t\tordinal: 7,\n\t\tsize: 4\n\t},\n\tDATA_TYPE_INT64:\n\t{\n\t\tordinal: 8,\n\t\tsize: 8\n\t},\n\tDATA_TYPE_UINT64:\n\t{\n\t\tordinal: 9,\n\t\tsize: 8\n\t}\n};\n\nvar i = 0;\nfor(var obj in PointAttributeTypes)\n{\n\tPointAttributeTypes[i] = PointAttributeTypes[obj];\n\ti++;\n}\n\n/**\n * A single point attribute such as color/normal/.. and its data format/number of elements/...\n */\nfunction PointAttribute(name, type, numElements)\n{\n\tthis.name = name;\n\tthis.type = type;\n\tthis.numElements = numElements;\n\tthis.byteSize = this.numElements * this.type.size;\n}\nPointAttribute.POSITION_CARTESIAN = new PointAttribute(PointAttributeNames.POSITION_CARTESIAN, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\nPointAttribute.RGBA_PACKED = new PointAttribute(PointAttributeNames.COLOR_PACKED, PointAttributeTypes.DATA_TYPE_INT8, 4);\nPointAttribute.COLOR_PACKED = PointAttribute.RGBA_PACKED;\nPointAttribute.RGB_PACKED = new PointAttribute(PointAttributeNames.COLOR_PACKED, PointAttributeTypes.DATA_TYPE_INT8, 3);\nPointAttribute.NORMAL_FLOATS = new PointAttribute(PointAttributeNames.NORMAL_FLOATS, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\nPointAttribute.FILLER_1B = new PointAttribute(PointAttributeNames.FILLER, PointAttributeTypes.DATA_TYPE_UINT8, 1);\nPointAttribute.INTENSITY = new PointAttribute(PointAttributeNames.INTENSITY, PointAttributeTypes.DATA_TYPE_UINT16, 1);\nPointAttribute.CLASSIFICATION = new PointAttribute(PointAttributeNames.CLASSIFICATION, PointAttributeTypes.DATA_TYPE_UINT8, 1);\nPointAttribute.NORMAL_SPHEREMAPPED = new PointAttribute(PointAttributeNames.NORMAL_SPHEREMAPPED, PointAttributeTypes.DATA_TYPE_UINT8, 2);\nPointAttribute.NORMAL_OCT16 = new PointAttribute(PointAttributeNames.NORMAL_OCT16, PointAttributeTypes.DATA_TYPE_UINT8, 2);\nPointAttribute.NORMAL = new PointAttribute(PointAttributeNames.NORMAL, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\nPointAttribute.RETURN_NUMBER = new PointAttribute(PointAttributeNames.RETURN_NUMBER, PointAttributeTypes.DATA_TYPE_UINT8, 1);\nPointAttribute.NUMBER_OF_RETURNS = new PointAttribute(PointAttributeNames.NUMBER_OF_RETURNS, PointAttributeTypes.DATA_TYPE_UINT8, 1);\nPointAttribute.SOURCE_ID = new PointAttribute(PointAttributeNames.SOURCE_ID, PointAttributeTypes.DATA_TYPE_UINT8, 1);\nPointAttribute.INDICES = new PointAttribute(PointAttributeNames.INDICES, PointAttributeTypes.DATA_TYPE_UINT32, 1);\nPointAttribute.SPACING = new PointAttribute(PointAttributeNames.SPACING, PointAttributeTypes.DATA_TYPE_FLOAT, 1);\n\n/**\n * Ordered list of PointAttributes used to identify how points are aligned in a buffer.\n */\nfunction PointAttributes(pointAttributes)\n{\n\tthis.attributes = [];\n\tthis.byteSize = 0;\n\tthis.size = 0;\n\n\tif(pointAttributes != null)\n\t{\n\t\tfor(var i = 0; i < pointAttributes.length; i++)\n\t\t{\n\t\t\tvar pointAttributeName = pointAttributes[i];\n\t\t\tvar pointAttribute = PointAttribute[pointAttributeName];\n\t\t\tthis.attributes.push(pointAttribute);\n\t\t\tthis.byteSize += pointAttribute.byteSize;\n\t\t\tthis.size++;\n\t\t}\n\t}\n}\nPointAttributes.prototype.add = function(pointAttribute)\n{\n\tthis.attributes.push(pointAttribute);\n\tthis.byteSize += pointAttribute.byteSize;\n\tthis.size++;\n};\n\nPointAttributes.prototype.hasColors = function()\n{\n\tfor(var name in this.attributes)\n\t{\n\t\tvar pointAttribute = this.attributes[name];\n\t\tif(pointAttribute.name === PointAttributeNames.COLOR_PACKED)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nPointAttributes.prototype.hasNormals = function()\n{\n\tfor(var name in this.attributes)\n\t{\n\t\tvar pointAttribute = this.attributes[name];\n\t\tif(pointAttribute === PointAttribute.NORMAL_SPHEREMAPPED || pointAttribute === PointAttribute.NORMAL_FLOATS || pointAttribute === PointAttribute.NORMAL || pointAttribute === PointAttribute.NORMAL_OCT16)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n//index is in order xyzxyzxyz\nclass DEMNode\n{\n\tconstructor(name, box, tileSize)\n\t{\n\t\tthis.name = name;\n\t\tthis.box = box;\n\t\tthis.tileSize = tileSize;\n\t\tthis.level = this.name.length - 1;\n\t\tthis.data = new Float32Array(tileSize * tileSize);\n\t\tthis.data.fill(-Infinity);\n\t\tthis.children = [];\n\n\t\tthis.mipMap = [this.data];\n\t\tthis.mipMapNeedsUpdate = true;\n\t}\n\n\tcreateMipMap()\n\t{\n\t\tthis.mipMap = [this.data];\n\n\t\tvar sourceSize = this.tileSize;\n\t\tvar mipSize = parseInt(sourceSize / 2);\n\t\tvar mipSource = this.data;\n\t\twhile(mipSize > 1)\n\t\t{\n\t\t\tvar mipData = new Float32Array(mipSize * mipSize);\n\n\t\t\tfor(var i = 0; i < mipSize; i++)\n\t\t\t{\n\t\t\t\tfor(var j = 0; j < mipSize; j++)\n\t\t\t\t{\n\t\t\t\t\tvar h00 = mipSource[2 * i + 0 + 2 * j * sourceSize];\n\t\t\t\t\tvar h01 = mipSource[2 * i + 0 + 2 * j * sourceSize + sourceSize];\n\t\t\t\t\tvar h10 = mipSource[2 * i + 1 + 2 * j * sourceSize];\n\t\t\t\t\tvar h11 = mipSource[2 * i + 1 + 2 * j * sourceSize + sourceSize];\n\n\t\t\t\t\tvar [height, weight] = [0, 0];\n\n\t\t\t\t\tif(isFinite(h00))\n\t\t\t\t\t{\n\t\t\t\t\t\theight += h00;\n\t\t\t\t\t\tweight += 1;\n\t\t\t\t\t}\t\t\t\t\tif(isFinite(h01))\n\t\t\t\t\t{\n\t\t\t\t\t\theight += h01;\n\t\t\t\t\t\tweight += 1;\n\t\t\t\t\t}\t\t\t\t\tif(isFinite(h10))\n\t\t\t\t\t{\n\t\t\t\t\t\theight += h10;\n\t\t\t\t\t\tweight += 1;\n\t\t\t\t\t}\t\t\t\t\tif(isFinite(h11))\n\t\t\t\t\t{\n\t\t\t\t\t\theight += h11;\n\t\t\t\t\t\tweight += 1;\n\t\t\t\t\t}\n\t\t\t\t\theight = height / weight;\n\n\t\t\t\t\t//var hs = [h00, h01, h10, h11].filter(h => isFinite(h));\n\t\t\t\t\t//var height = hs.reduce((a, v, i) => a + v, 0) / hs.length;\n\n\t\t\t\t\tmipData[i + j * mipSize] = height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.mipMap.push(mipData);\n\n\t\t\tmipSource = mipData;\n\t\t\tsourceSize = mipSize;\n\t\t\tmipSize = parseInt(mipSize / 2);\n\t\t}\n\n\t\tthis.mipMapNeedsUpdate = false;\n\t}\n\n\tuv(position)\n\t{\n\t\tvar boxSize = this.box.getSize(new THREE.Vector3());\n\n\t\tvar u = (position.x - this.box.min.x) / boxSize.x;\n\t\tvar v = (position.y - this.box.min.y) / boxSize.y;\n\n\t\treturn [u, v];\n\t}\n\n\theightAtMipMapLevel(position, mipMapLevel)\n\t{\n\t\tvar uv = this.uv(position);\n\n\t\tvar tileSize = parseInt(this.tileSize / parseInt(2 ** mipMapLevel));\n\t\tvar data = this.mipMap[mipMapLevel];\n\n\t\tvar i = Math.min(uv[0] * tileSize, tileSize - 1);\n\t\tvar j = Math.min(uv[1] * tileSize, tileSize - 1);\n\n\t\tvar a = i % 1;\n\t\tvar b = j % 1;\n\n\t\tvar [i0, i1] = [Math.floor(i), Math.ceil(i)];\n\t\tvar [j0, j1] = [Math.floor(j), Math.ceil(j)];\n\n\t\tvar h00 = data[i0 + tileSize * j0];\n\t\tvar h01 = data[i0 + tileSize * j1];\n\t\tvar h10 = data[i1 + tileSize * j0];\n\t\tvar h11 = data[i1 + tileSize * j1];\n\n\t\tvar wh00 = isFinite(h00) ? (1 - a) * (1 - b) : 0;\n\t\tvar wh01 = isFinite(h01) ? (1 - a) * b : 0;\n\t\tvar wh10 = isFinite(h10) ? a * (1 - b) : 0;\n\t\tvar wh11 = isFinite(h11) ? a * b : 0;\n\n\t\tvar wsum = wh00 + wh01 + wh10 + wh11;\n\t\twh00 = wh00 / wsum;\n\t\twh01 = wh01 / wsum;\n\t\twh10 = wh10 / wsum;\n\t\twh11 = wh11 / wsum;\n\n\t\tif(wsum === 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tvar h = 0;\n\n\t\tif(isFinite(h00)) h += h00 * wh00;\n\t\tif(isFinite(h01)) h += h01 * wh01;\n\t\tif(isFinite(h10)) h += h10 * wh10;\n\t\tif(isFinite(h11)) h += h11 * wh11;\n\n\t\treturn h;\n\t}\n\n\theight(position)\n\t{\n\t\tvar h = null;\n\n\t\tfor(var i = 0; i < this.mipMap.length; i++)\n\t\t{\n\t\t\th = this.heightAtMipMapLevel(position, i);\n\n\t\t\tif(h !== null)\n\t\t\t{\n\t\t\t\treturn h;\n\t\t\t}\n\t\t}\n\n\t\treturn h;\n\t}\n\n\ttraverse(handler, level = 0)\n\t{\n\t\thandler(this, level);\n\n\t\tfor(var child of this.children.filter(c => c !== undefined))\n\t\t{\n\t\t\tchild.traverse(handler, level + 1);\n\t\t}\n\t}\n}\n\nclass DEM$1\n{\n\tconstructor(pointcloud)\n\t{\n\t\tthis.pointcloud = pointcloud;\n\t\tthis.matrix = null;\n\t\tthis.boundingBox = null;\n\t\tthis.tileSize = 64;\n\t\tthis.root = null;\n\t\tthis.version = 0;\n\t}\n\n\t//expands the tree to all nodes that intersect <box> at <level> returns the intersecting nodes at <level>\n\texpandAndFindByBox(box, level)\n\t{\n\t\tif(level === 0)\n\t\t{\n\t\t\treturn [this.root];\n\t\t}\n\n\t\tvar result = [];\n\t\tvar stack = [this.root];\n\n\t\twhile(stack.length > 0)\n\t\t{\n\t\t\tvar node = stack.pop();\n\t\t\tvar nodeBoxSize = node.box.getSize(new THREE.Vector3());\n\n\t\t\t//check which children intersect by transforming min/max to quadrants\n\t\t\tvar min = {\n\t\t\t\tx: (box.min.x - node.box.min.x) / nodeBoxSize.x,\n\t\t\t\ty: (box.min.y - node.box.min.y) / nodeBoxSize.y\n\t\t\t};\n\t\t\tvar max = {\n\t\t\t\tx: (box.max.x - node.box.max.x) / nodeBoxSize.x,\n\t\t\t\ty: (box.max.y - node.box.max.y) / nodeBoxSize.y\n\t\t\t};\n\n\t\t\tmin.x = min.x < 0.5 ? 0 : 1;\n\t\t\tmin.y = min.y < 0.5 ? 0 : 1;\n\t\t\tmax.x = max.x < 0.5 ? 0 : 1;\n\t\t\tmax.y = max.y < 0.5 ? 0 : 1;\n\n\t\t\tvar childIndices;\n\t\t\tif(min.x === 0 && min.y === 0 && max.x === 1 && max.y === 1)\n\t\t\t{\n\t\t\t\tchildIndices = [0, 1, 2, 3];\n\t\t\t}\n\t\t\telse if(min.x === max.x && min.y === max.y)\n\t\t\t{\n\t\t\t\tchildIndices = [(min.x << 1) | min.y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchildIndices = [(min.x << 1) | min.y, (max.x << 1) | max.y];\n\t\t\t}\n\n\t\t\tfor(var index of childIndices)\n\t\t\t{\n\t\t\t\tif(node.children[index] === undefined)\n\t\t\t\t{\n\t\t\t\t\tvar childBox = node.box.clone();\n\n\t\t\t\t\tif((index & 2) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchildBox.min.x += nodeBoxSize.x / 2.0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchildBox.max.x -= nodeBoxSize.x / 2.0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif((index & 1) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchildBox.min.y += nodeBoxSize.y / 2.0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tchildBox.max.y -= nodeBoxSize.y / 2.0;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar child = new DEMNode(node.name + index, childBox, this.tileSize);\n\t\t\t\t\tnode.children[index] = child;\n\t\t\t\t}\n\n\t\t\t\tvar child = node.children[index];\n\n\t\t\t\tif(child.level < level)\n\t\t\t\t{\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tchildIndex(uv)\n\t{\n\t\tvar [x, y] = uv.map(n => n < 0.5 ? 0 : 1);\n\n\t\tvar index = (x << 1) | y;\n\n\t\treturn index;\n\t}\n\n\theight(position)\n\t{\n\t\tif(!this.root)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar height = null;\n\t\tvar list = [this.root];\n\t\twhile(true)\n\t\t{\n\t\t\tvar node = list[list.length - 1];\n\n\t\t\tvar currentHeight = node.height(position);\n\n\t\t\tif(currentHeight !== null)\n\t\t\t{\n\t\t\t\theight = currentHeight;\n\t\t\t}\n\n\t\t\tvar uv = node.uv(position);\n\t\t\tvar childIndex = this.childIndex(uv);\n\n\t\t\tif(node.children[childIndex])\n\t\t\t{\n\t\t\t\tlist.push(node.children[childIndex]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn height + this.pointcloud.position.z;\n\t}\n\n\tupdate(visibleNodes)\n\t{\n\t\t//check if point cloud transformation changed\n\t\tif(this.matrix === null || !this.matrix.equals(this.pointcloud.matrixWorld))\n\t\t{\n\t\t\tthis.matrix = this.pointcloud.matrixWorld.clone();\n\t\t\tthis.boundingBox = this.pointcloud.boundingBox.clone().applyMatrix4(this.matrix);\n\t\t\tthis.root = new DEMNode(\"r\", this.boundingBox, this.tileSize);\n\t\t\tthis.version++;\n\t\t}\n\n\t\t//find node to update\n\t\tvar node = null;\n\t\tfor(var vn of visibleNodes)\n\t\t{\n\t\t\tif(vn.demVersion === undefined || vn.demVersion < this.version)\n\t\t\t{\n\t\t\t\tnode = vn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(node === null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//update node\n\t\tvar projectedBox = node.getBoundingBox().clone().applyMatrix4(this.matrix);\n\t\tvar projectedBoxSize = projectedBox.getSize(new THREE.Vector3());\n\n\t\tvar targetNodes = this.expandAndFindByBox(projectedBox, node.getLevel());\n\t\tnode.demVersion = this.version;\n\n\t\tvar position = node.geometryNode.geometry.attributes.position.array;\n\t\tvar message =\n\t\t{\n\t\t\tboundingBox:\n\t\t\t{\n\t\t\t\tmin: node.getBoundingBox().min.toArray(),\n\t\t\t\tmax: node.getBoundingBox().max.toArray()\n\t\t\t},\n\t\t\tposition: new Float32Array(position).buffer\n\t\t};\n\t\tvar transferables = [message.position];\n\n\t\tvar self = this;\n\n\t\tGlobal.workerPool.runTask(WorkerManager.DEM, function(e)\n\t\t{\n\t\t\tvar data = new Float32Array(e.data.dem.data);\n\n\t\t\tfor(var demNode of targetNodes)\n\t\t\t{\n\t\t\t\tvar boxSize = demNode.box.getSize(new THREE.Vector3());\n\n\t\t\t\tfor(var i = 0; i < self.tileSize; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(var j = 0; j < self.tileSize; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar u = (i / (self.tileSize - 1));\n\t\t\t\t\t\tvar v = (j / (self.tileSize - 1));\n\n\t\t\t\t\t\tvar x = demNode.box.min.x + u * boxSize.x;\n\t\t\t\t\t\tvar y = demNode.box.min.y + v * boxSize.y;\n\n\t\t\t\t\t\tvar ix = self.tileSize * (x - projectedBox.min.x) / projectedBoxSize.x;\n\t\t\t\t\t\tvar iy = self.tileSize * (y - projectedBox.min.y) / projectedBoxSize.y;\n\n\t\t\t\t\t\tif(ix < 0 || ix > self.tileSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(iy < 0 || iy > self.tileSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tix = Math.min(Math.floor(ix), self.tileSize - 1);\n\t\t\t\t\t\tiy = Math.min(Math.floor(iy), self.tileSize - 1);\n\n\t\t\t\t\t\tdemNode.data[i + self.tileSize * j] = data[ix + self.tileSize * iy];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdemNode.createMipMap();\n\t\t\t\tdemNode.mipMapNeedsUpdate = true;\n\t\t\t}\n\t\t}, message, transferables);\n\t}\n}\n\nclass PointCloudTreeNode\n{\n\tconstructor()\n\t{\n\t\tthis.needsTransformUpdate = true;\n\t}\n\n\tgetChildren(){}\n\n\tgetBoundingBox(){}\n\n\tisLoaded(){}\n\n\tisGeometryNode(){}\n\n\tisTreeNode(){}\n\n\tgetLevel(){}\n\n\tgetBoundingSphere(){}\n}\nclass PointCloudTree extends THREE.Object3D\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis.dem = new DEM$1(this);\n\t}\n\n\tinitialized()\n\t{\n\t\treturn this.root !== null;\n\t}\n}\n\nclass PointCloudGreyhoundGeometry\n{\n\tconstructor()\n\t{\n\t\tthis.spacing = 0;\n\t\tthis.boundingBox = null;\n\t\tthis.root = null;\n\t\tthis.nodes = null;\n\t\tthis.pointAttributes = {};\n\t\tthis.hierarchyStepSize = -1;\n\t\tthis.loader = null;\n\t\tthis.schema = null;\n\n\t\tthis.baseDepth = null;\n\t\tthis.offset = null;\n\t\tthis.projection = null;\n\n\t\tthis.boundingSphere = null;\n\n\t\t// the serverURL will contain the base URL of the greyhound server. f.e. http://dev.greyhound.io/resource/autzen/\n\t\tthis.serverURL = null;\n\t\tthis.normalize = {color: false, intensity: false};\n\t}\n}\n\nfunction PointCloudGreyhoundGeometryNode(name, pcoGeometry, boundingBox, scale, offset)\n{\n\tthis.id = PointCloudGreyhoundGeometryNode.IDCount++;\n\tthis.name = name;\n\tthis.index = parseInt(name.charAt(name.length - 1));\n\tthis.pcoGeometry = pcoGeometry;\n\tthis.geometry = null;\n\tthis.boundingBox = boundingBox;\n\tthis.boundingSphere = boundingBox.getBoundingSphere(new THREE.Sphere());\n\tthis.scale = scale;\n\tthis.offset = offset;\n\tthis.children = {};\n\tthis.numPoints = 0;\n\tthis.level = null;\n\tthis.loaded = false;\n\tthis.oneTimeDisposeHandlers = [];\n\tthis.baseLoaded = false;\n\n\tvar center = new THREE.Vector3();\n\n\tvar bounds = this.boundingBox.clone();\n\tbounds.min.sub(this.pcoGeometry.boundingBox.getCenter(center));\n\tbounds.max.sub(this.pcoGeometry.boundingBox.getCenter(center));\n\n\tif(this.scale)\n\t{\n\t\tbounds.min.multiplyScalar(1 / this.scale);\n\t\tbounds.max.multiplyScalar(1 / this.scale);\n\t}\n\n\t//This represents the bounds for this node in the reference frame of the\n\t//global bounds from `info`, centered around the origin, and then scaled\n\t//by our selected scale.\n\tthis.greyhoundBounds = bounds;\n\n\t//This represents the offset between the coordinate system described above\n\t//and our pcoGeometry bounds.\n\tthis.greyhoundOffset = this.pcoGeometry.offset.clone().add(this.pcoGeometry.boundingBox.getSize(new THREE.Vector3()).multiplyScalar(0.5));\n}\nPointCloudGreyhoundGeometryNode.IDCount = 0;\n\nPointCloudGreyhoundGeometryNode.prototype = Object.create(PointCloudTreeNode.prototype);\n\nPointCloudGreyhoundGeometryNode.prototype.isGeometryNode = function()\n{\n\treturn true;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.isTreeNode = function()\n{\n\treturn false;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.isLoaded = function()\n{\n\treturn this.loaded;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getBoundingSphere = function()\n{\n\treturn this.boundingSphere;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getBoundingBox = function()\n{\n\treturn this.boundingBox;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getLevel = function()\n{\n\treturn this.level;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getChildren = function()\n{\n\tvar children = [];\n\n\tfor(var i = 0; i < 8; ++i)\n\t{\n\t\tif(this.children[i])\n\t\t{\n\t\t\tchildren.push(this.children[i]);\n\t\t}\n\t}\n\n\treturn children;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getURL = function()\n{\n\tvar schema = this.pcoGeometry.schema;\n\tvar bounds = this.greyhoundBounds;\n\n\tvar boundsString = bounds.min.x + \",\" + bounds.min.y + \",\" + bounds.min.z + \",\" + bounds.max.x + \",\" + bounds.max.y + \",\" + bounds.max.z;\n\n\tvar url = \"\" + this.pcoGeometry.serverURL +\n\t\t\"read?depthBegin=\" +\n\t\t(this.baseLoaded ? (this.level + this.pcoGeometry.baseDepth) : 0) +\n\t\t\"&depthEnd=\" + (this.level + this.pcoGeometry.baseDepth + 1) +\n\t\t\"&bounds=[\" + boundsString + \"]\" +\n\t\t\"&schema=\" + JSON.stringify(schema) +\n\t\t\"&compress=true\";\n\n\tif(this.scale)\n\t{\n\t\turl += \"&scale=\" + this.scale;\n\t}\n\n\tif(this.greyhoundOffset)\n\t{\n\t\tvar offset = this.greyhoundOffset;\n\t\turl += \"&offset=[\" + offset.x + \",\" + offset.y + \",\" + offset.z + \"]\";\n\t}\n\n\tif(!this.baseLoaded) this.baseLoaded = true;\n\n\treturn url;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.addChild = function(child)\n{\n\tthis.children[child.index] = child;\n\tchild.parent = this;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.load = function()\n{\n\tif(this.loading === true || this.loaded === true || Global.numNodesLoading >= Global.maxNodesLoading)\n\t{\n\t\treturn;\n\t}\n\n\tthis.loading = true;\n\tGlobal.numNodesLoading++;\n\n\tif(this.level % this.pcoGeometry.hierarchyStepSize === 0 && this.hasChildren)\n\t{\n\t\tthis.loadHierarchyThenPoints();\n\t}\n\telse\n\t{\n\t\tthis.loadPoints();\n\t}\n};\n\nPointCloudGreyhoundGeometryNode.prototype.loadPoints = function()\n{\n\tthis.pcoGeometry.loader.load(this);\n};\n\nPointCloudGreyhoundGeometryNode.prototype.loadHierarchyThenPoints = function()\n{\n\t//From Greyhound (Cartesian) ordering for the octree to Potree-default\n\tvar transform = [0, 2, 1, 3, 4, 6, 5, 7];\n\n\tvar makeBitMask = function(node)\n\t{\n\t\tvar mask = 0;\n\t\tObject.keys(node).forEach(function(key)\n\t\t{\n\t\t\tif(key === \"swd\") mask += 1 << transform[0];\n\t\t\telse if(key === \"nwd\") mask += 1 << transform[1];\n\t\t\telse if(key === \"swu\") mask += 1 << transform[2];\n\t\t\telse if(key === \"nwu\") mask += 1 << transform[3];\n\t\t\telse if(key === \"sed\") mask += 1 << transform[4];\n\t\t\telse if(key === \"ned\") mask += 1 << transform[5];\n\t\t\telse if(key === \"seu\") mask += 1 << transform[6];\n\t\t\telse if(key === \"neu\") mask += 1 << transform[7];\n\t\t});\n\t\treturn mask;\n\t};\n\n\tvar parseChildrenCounts = function(base, parentName, stack)\n\t{\n\t\tvar keys = Object.keys(base);\n\t\tvar child;\n\t\tvar childName;\n\n\t\tkeys.forEach(function(key)\n\t\t{\n\t\t\tif(key === \"n\") return;\n\t\t\tswitch(key)\n\t\t\t{\n\t\t\t\tcase \"swd\":\n\t\t\t\t\tchild = base.swd;\n\t\t\t\t\tchildName = parentName + transform[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"nwd\":\n\t\t\t\t\tchild = base.nwd;\n\t\t\t\t\tchildName = parentName + transform[1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"swu\":\n\t\t\t\t\tchild = base.swu;\n\t\t\t\t\tchildName = parentName + transform[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"nwu\":\n\t\t\t\t\tchild = base.nwu;\n\t\t\t\t\tchildName = parentName + transform[3];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sed\":\n\t\t\t\t\tchild = base.sed;\n\t\t\t\t\tchildName = parentName + transform[4];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ned\":\n\t\t\t\t\tchild = base.ned;\n\t\t\t\t\tchildName = parentName + transform[5];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"seu\":\n\t\t\t\t\tchild = base.seu;\n\t\t\t\t\tchildName = parentName + transform[6];\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"neu\":\n\t\t\t\t\tchild = base.neu;\n\t\t\t\t\tchildName = parentName + transform[7];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstack.push(\n\t\t\t{\n\t\t\t\tchildren: makeBitMask(child),\n\t\t\t\tnumPoints: child.n,\n\t\t\t\tname: childName\n\t\t\t});\n\n\t\t\tparseChildrenCounts(child, childName, stack);\n\t\t});\n\t};\n\n\t//Load hierarchy.\n\tvar callback = function(node, greyhoundHierarchy)\n\t{\n\t\tvar decoded = [];\n\t\tnode.numPoints = greyhoundHierarchy.n;\n\t\tparseChildrenCounts(greyhoundHierarchy, node.name, decoded);\n\n\t\tvar nodes = {};\n\t\tnodes[node.name] = node;\n\t\tvar pgg = node.pcoGeometry;\n\n\t\tfor(var i = 0; i < decoded.length; i++)\n\t\t{\n\t\t\tvar name = decoded[i].name;\n\t\t\tvar numPoints = decoded[i].numPoints;\n\t\t\tvar index = parseInt(name.charAt(name.length - 1));\n\t\t\tvar parentName = name.substring(0, name.length - 1);\n\t\t\tvar parentNode = nodes[parentName];\n\t\t\tvar level = name.length - 1;\n\t\t\tvar boundingBox = GreyhoundLoader.createChildAABB(parentNode.boundingBox, index);\n\n\t\t\tvar currentNode = new PointCloudGreyhoundGeometryNode(name, pgg, boundingBox, node.scale, node.offset);\n\t\t\tcurrentNode.level = level;\n\t\t\tcurrentNode.numPoints = numPoints;\n\t\t\tcurrentNode.hasChildren = decoded[i].children > 0;\n\t\t\tcurrentNode.spacing = pgg.spacing / Math.pow(2, level);\n\n\t\t\tparentNode.addChild(currentNode);\n\t\t\tnodes[name] = currentNode;\n\t\t}\n\n\t\tnode.loadPoints();\n\t};\n\n\tif(this.level % this.pcoGeometry.hierarchyStepSize === 0)\n\t{\n\t\tvar depthBegin = this.level + this.pcoGeometry.baseDepth;\n\t\tvar depthEnd = depthBegin + this.pcoGeometry.hierarchyStepSize + 2;\n\n\t\tvar bounds = this.greyhoundBounds;\n\n\t\tvar boundsString = bounds.min.x + \",\" + bounds.min.y + \",\" + bounds.min.z + \",\" + bounds.max.x + \",\" + bounds.max.y + \",\" + bounds.max.z;\n\n\t\tvar hurl = \"\" + this.pcoGeometry.serverURL +\n\t\t\t\"hierarchy?bounds=[\" + boundsString + \"]\" +\n\t\t\t\"&depthBegin=\" + depthBegin +\n\t\t\t\"&depthEnd=\" + depthEnd;\n\n\t\tif(this.scale)\n\t\t{\n\t\t\thurl += \"&scale=\" + this.scale;\n\t\t}\n\n\t\tif(this.greyhoundOffset)\n\t\t{\n\t\t\tvar offset = this.greyhoundOffset;\n\t\t\thurl += \"&offset=[\" + offset.x + \",\" + offset.y + \",\" + offset.z + \"]\";\n\t\t}\n\n\t\tvar self = this;\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", hurl, true);\n\t\txhr.onload = function(event)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcallback(self, JSON.parse(xhr.responseText) || {});\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function(event)\n\t\t{\n\t\t\tconsole.log(\"Potree: Failed to load file! HTTP status \" + xhr.status + \", file:\" + hurl, event);\n\t\t};\n\t\txhr.send(null);\n\t}\n};\n\nPointCloudGreyhoundGeometryNode.prototype.getNumPoints = function()\n{\n\treturn this.numPoints;\n};\n\nPointCloudGreyhoundGeometryNode.prototype.dispose = function()\n{\n\tif(this.geometry && this.parent != null)\n\t{\n\t\tthis.geometry.dispose();\n\t\tthis.geometry = null;\n\t\tthis.loaded = false;\n\n\t\tfor(var i = 0; i < this.oneTimeDisposeHandlers.length; i++)\n\t\t{\n\t\t\tvar handler = this.oneTimeDisposeHandlers[i];\n\t\t\thandler();\n\t\t}\n\t\t\n\t\tthis.oneTimeDisposeHandlers = [];\n\t}\n};\n\nObject.assign(PointCloudGreyhoundGeometryNode.prototype, THREE.EventDispatcher.prototype);\n\nfunction VersionUtils(version)\n{\n\tthis.version = version;\n\tvar vmLength = (version.indexOf(\".\") === -1) ? version.length : version.indexOf(\".\");\n\tthis.versionMajor = parseInt(version.substr(0, vmLength));\n\tthis.versionMinor = parseInt(version.substr(vmLength + 1));\n\t\n\tif(this.versionMinor.length === 0)\n\t{\n\t\tthis.versionMinor = 0;\n\t}\n}\nVersionUtils.prototype.newerThan = function(version)\n{\n\tvar v = new VersionUtils(version);\n\n\tif((this.versionMajor > v.versionMajor) || (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor))\n\t{\n\t\treturn true;\n\t}\n\t\n\treturn false;\n};\n\nVersionUtils.prototype.equalOrHigher = function(version)\n{\n\tvar v = new VersionUtils(version);\n\n\tif((this.versionMajor > v.versionMajor) || (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor))\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nVersionUtils.prototype.upTo = function(version)\n{\n\treturn !this.newerThan(version);\n};\n\nclass GreyhoundBinaryLoader\n{\n\tconstructor(version, boundingBox, scale)\n\t{\n\t\tif(typeof(version) === \"string\")\n\t\t{\n\t\t\tthis.version = new VersionUtils(version);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.version = version;\n\t\t}\n\n\t\tthis.boundingBox = boundingBox;\n\t\tthis.scale = scale;\n\t}\n\n\tload(node)\n\t{\n\t\tif(node.loaded) return;\n\n\t\tvar self = this;\n\t\tvar url = node.getURL();\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.onload = function()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tself.parse(node, xhr.response);\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function(event)\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.error(\"Potree: Failed to load file.\", xhr, url);\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\tparse(node, buffer)\n\t{\n\t\tvar NUM_POINTS_BYTES = 4;\n\t\tvar view = new DataView(buffer, buffer.byteLength - NUM_POINTS_BYTES, NUM_POINTS_BYTES);\n\t\tvar numPoints = view.getUint32(0, true);\n\t\tvar pointAttributes = node.pcoGeometry.pointAttributes;\n\n\t\tnode.numPoints = numPoints;\n\n\t\tvar bb = node.boundingBox;\n\t\tvar center = new THREE.Vector3();\n\t\tvar nodeOffset = node.pcoGeometry.boundingBox.getCenter(center).sub(node.boundingBox.min);\n\n\t\tvar message =\n\t\t{\n\t\t\tbuffer: buffer,\n\t\t\tpointAttributes: pointAttributes,\n\t\t\tversion: this.version.version,\n\t\t\tschema: node.pcoGeometry.schema,\n\t\t\tmin: [bb.min.x, bb.min.y, bb.min.z],\n\t\t\tmax: [bb.max.x, bb.max.y, bb.max.z],\n\t\t\toffset: nodeOffset.toArray(),\n\t\t\tscale: this.scale,\n\t\t\tnormalize: node.pcoGeometry.normalize\n\t\t};\n\n\t\tGlobal.workerPool.runTask(WorkerManager.GREYHOUND, function(e)\n\t\t{\n\t\t\tvar data = e.data;\n\t\t\tvar buffers = data.attributeBuffers;\n\t\t\t\n\t\t\tvar tightBoundingBox = new THREE.Box3\n\t\t\t(\n\t\t\t\tnew THREE.Vector3().fromArray(data.tightBoundingBox.min),\n\t\t\t\tnew THREE.Vector3().fromArray(data.tightBoundingBox.max)\n\t\t\t);\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tfor(var property in buffers)\n\t\t\t{\n\t\t\t\tvar buffer = buffers[property].buffer;\n\n\t\t\t\tif(parseInt(property) === PointAttributeNames.POSITION_CARTESIAN)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.COLOR_PACKED)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"color\", new THREE.BufferAttribute(new Uint8Array(buffer), 4, true));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.INTENSITY)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"intensity\", new THREE.BufferAttribute(new Float32Array(buffer), 1));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.CLASSIFICATION)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"classification\", new THREE.BufferAttribute(new Uint8Array(buffer), 1));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL_SPHEREMAPPED)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL_OCT16)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.INDICES)\n\t\t\t\t{\n\t\t\t\t\tvar bufferAttribute = new THREE.BufferAttribute(new Uint8Array(buffer), 4);\n\t\t\t\t\tbufferAttribute.normalized = true;\n\t\t\t\t\tgeometry.setAttribute(\"indices\", bufferAttribute);\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.SPACING)\n\t\t\t\t{\n\t\t\t\t\tvar bufferAttribute = new THREE.BufferAttribute(new Float32Array(buffer), 1);\n\t\t\t\t\tgeometry.setAttribute(\"spacing\", bufferAttribute);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttightBoundingBox.max.sub(tightBoundingBox.min);\n\t\t\ttightBoundingBox.min.set(0, 0, 0);\n\n\t\t\tnode.numPoints = data.numPoints;\n\t\t\tnode.geometry = geometry;\n\t\t\tnode.mean = new THREE.Vector3(...data.mean);\n\t\t\tnode.tightBoundingBox = tightBoundingBox;\n\t\t\tnode.loaded = true;\n\t\t\tnode.loading = false;\n\t\t\tGlobal.numNodesLoading--;\n\t\t}, message, [message.buffer]);\n\t}\n}\n\n/**\n * @class Loads greyhound metadata and returns a PointcloudOctree\n *\n * @author Maarten van Meersbergen\n * @author Oscar Martinez Rubi\n * @author Connor Manning\n */\nclass GreyhoundUtils\n{\n\tstatic getQueryParam(name)\n\t{\n\t\tname = name.replace(/[[\\]]/g, \"\\\\$&\");\n\t\tvar regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\");\n\t\tvar results = regex.exec(window.location.href);\n\t\tif(!results) return null;\n\t\tif(!results[2]) return \"\";\n\t\treturn decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n\t}\n\n\tstatic createSchema(attributes)\n\t{\n\t\tvar schema = [\n\t\t\t{\n\t\t\t\t\"name\": \"X\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"signed\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Y\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"signed\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Z\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"signed\"\n\t\t\t}\n\t\t];\n\n\t\t//Once we include options in the UI to load a dynamic list of available\n\t\t//attributes for visualization (f.e. Classification, Intensity etc.)\n\t\t//we will be able to ask for that specific attribute from the server,\n\t\t//where we are now requesting all attributes for all points all the time.\n\t\t//If we do that though, we also need to tell Potree to redraw the points\n\t\t//that are already loaded (with different attributes).\n\t\t//This is not default behaviour.\n\t\tattributes.forEach(function(item)\n\t\t{\n\t\t\tif(item === \"COLOR_PACKED\")\n\t\t\t{\n\t\t\t\tschema.push(\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"Red\",\n\t\t\t\t\t\"size\": 2,\n\t\t\t\t\t\"type\": \"unsigned\"\n\t\t\t\t});\n\t\t\t\tschema.push(\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"Green\",\n\t\t\t\t\t\"size\": 2,\n\t\t\t\t\t\"type\": \"unsigned\"\n\t\t\t\t});\n\t\t\t\tschema.push(\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"Blue\",\n\t\t\t\t\t\"size\": 2,\n\t\t\t\t\t\"type\": \"unsigned\"\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if(item === \"INTENSITY\")\n\t\t\t{\n\t\t\t\tschema.push(\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"Intensity\",\n\t\t\t\t\t\"size\": 2,\n\t\t\t\t\t\"type\": \"unsigned\"\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if(item === \"CLASSIFICATION\")\n\t\t\t{\n\t\t\t\tschema.push(\n\t\t\t\t{\n\t\t\t\t\t\"name\": \"Classification\",\n\t\t\t\t\t\"size\": 1,\n\t\t\t\t\t\"type\": \"unsigned\"\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn schema;\n\t}\n\n\tstatic fetch(url, cb)\n\t{\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.onreadystatechange = function()\n\t\t{\n\t\t\tif(xhr.readyState === 4)\n\t\t\t{\n\t\t\t\tif(xhr.status === 200 || xhr.status === 0)\n\t\t\t\t{\n\t\t\t\t\tcb(null, xhr.responseText);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcb(xhr.responseText);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t};\n\n\tstatic fetchBinary(url, cb)\n\t{\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.onreadystatechange = function()\n\t\t{\n\t\t\tif(xhr.readyState === 4)\n\t\t\t{\n\t\t\t\tif(xhr.status === 200 || xhr.status === 0)\n\t\t\t\t{\n\t\t\t\t\tcb(null, xhr.response);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcb(xhr.responseText);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t};\n\n\tstatic pointSizeFrom(schema)\n\t{\n\t\treturn schema.reduce((p, c) => p + c.size, 0);\n\t};\n\n\tstatic getNormalization(serverURL, baseDepth, cb)\n\t{\n\t\tvar s = [\n\t\t\t{\n\t\t\t\t\"name\": \"X\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"floating\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Y\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"floating\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Z\",\n\t\t\t\t\"size\": 4,\n\t\t\t\t\"type\": \"floating\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Red\",\n\t\t\t\t\"size\": 2,\n\t\t\t\t\"type\": \"unsigned\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Green\",\n\t\t\t\t\"size\": 2,\n\t\t\t\t\"type\": \"unsigned\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Blue\",\n\t\t\t\t\"size\": 2,\n\t\t\t\t\"type\": \"unsigned\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"Intensity\",\n\t\t\t\t\"size\": 2,\n\t\t\t\t\"type\": \"unsigned\"\n\t\t\t}\n\t\t];\n\n\t\tvar url = serverURL + \"read?depth=\" + baseDepth + \"&schema=\" + JSON.stringify(s);\n\n\t\tGreyhoundUtils.fetchBinary(url, function(err, buffer)\n\t\t{\n\t\t\tif(err) throw new Error(err);\n\n\t\t\tvar view = new DataView(buffer);\n\t\t\tvar numBytes = buffer.byteLength - 4;\n\t\t\tvar pointSize = GreyhoundUtils.pointSizeFrom(s);\n\n\t\t\tvar colorNorm = false;\n\t\t\tvar intensityNorm = false;\n\n\t\t\tfor(var offset = 0; offset < numBytes; offset += pointSize)\n\t\t\t{\n\t\t\t\tif(view.getUint16(offset + 12, true) > 255 ||\n\t\t\t\t\tview.getUint16(offset + 14, true) > 255 ||\n\t\t\t\t\tview.getUint16(offset + 16, true) > 255)\n\t\t\t\t{\n\t\t\t\t\tcolorNorm = true;\n\t\t\t\t}\n\n\t\t\t\tif(view.getUint16(offset + 18, true) > 255)\n\t\t\t\t{\n\t\t\t\t\tintensityNorm = true;\n\t\t\t\t}\n\n\t\t\t\tif(colorNorm && intensityNorm) break;\n\t\t\t}\n\n\t\t\tcb(null,\n\t\t\t{\n\t\t\t\tcolor: colorNorm,\n\t\t\t\tintensity: intensityNorm\n\t\t\t});\n\t\t});\n\t};\n}\n\nfunction GreyhoundLoader(){}\n\nGreyhoundLoader.loadInfoJSON = function(url, callback){};\n\n/**\n * @return a point cloud octree with the root node data loaded.\n * loading of descendants happens asynchronously when they\"re needed\n *\n * @param url\n * @param loadingFinishedListener executed after loading the binary has been\n * finished\n */\nGreyhoundLoader.load = function(url, callback)\n{\n\tvar HIERARCHY_STEP_SIZE = 5;\n\n\ttry\n\t{\n\t\t//We assume everything ater the string \"greyhound://\" is the server url\n\t\tvar serverURL = url.split(\"greyhound://\")[1];\n\t\tif(serverURL.split(\"http://\").length === 1 && serverURL.split(\"https://\").length === 1)\n\t\t{\n\t\t\tserverURL = \"http://\" + serverURL;\n\t\t}\n\n\t\tGreyhoundUtils.fetch(serverURL + \"info\", function(err, data)\n\t\t{\n\t\t\tif(err) throw new Error(err);\n\n\t\t\t/* We parse the result of the info query, which should be a JSON datastructure somewhat like:\n\t\t\t{\n\t\t\t  \"bounds\": [635577, 848882, -1000, 639004, 853538, 2000],\n\t\t\t  \"numPoints\": 10653336,\n\t\t\t  \"schema\": [\n\t\t\t      { \"name\": \"X\", \"size\": 8, \"type\": \"floating\" },\n\t\t\t      { \"name\": \"Y\", \"size\": 8, \"type\": \"floating\" },\n\t\t\t      { \"name\": \"Z\", \"size\": 8, \"type\": \"floating\" },\n\t\t\t      { \"name\": \"Intensity\", \"size\": 2, \"type\": \"unsigned\" },\n\t\t\t      { \"name\": \"OriginId\", \"size\": 4, \"type\": \"unsigned\" },\n\t\t\t      { \"name\": \"Red\", \"size\": 2, \"type\": \"unsigned\" },\n\t\t\t      { \"name\": \"Green\", \"size\": 2, \"type\": \"unsigned\" },\n\t\t\t      { \"name\": \"Blue\", \"size\": 2, \"type\": \"unsigned\" }\n\t\t\t  ],\n\t\t\t  \"srs\": \"<omitted for brevity>\",\n\t\t\t  \"type\": \"octree\"\n\t\t\t}\n\t\t\t*/\n\t\t\tvar greyhoundInfo = JSON.parse(data);\n\t\t\tvar version = new VersionUtils(\"1.4\");\n\n\t\t\tvar bounds = greyhoundInfo.bounds;\n\n\t\t\t//TODO Unused: var boundsConforming = greyhoundInfo.boundsConforming;\n\t\t\t//TODO Unused: var width = bounds[3] - bounds[0];\n\t\t\t//TODO Unused: var depth = bounds[4] - bounds[1];\n\t\t\t//TODO Unused: var height = bounds[5] - bounds[2];\n\t\t\t//TODO Unused: var radius = width / 2;\n\t\t\t\n\t\t\tvar scale = greyhoundInfo.scale || 0.01;\n\t\t\tif(Array.isArray(scale))\n\t\t\t{\n\t\t\t\tscale = Math.min(scale[0], scale[1], scale[2]);\n\t\t\t}\n\n\t\t\tif(GreyhoundUtils.getQueryParam(\"scale\"))\n\t\t\t{\n\t\t\t\tscale = parseFloat(GreyhoundUtils.getQueryParam(\"scale\"));\n\t\t\t}\n\n\t\t\tvar baseDepth = Math.max(8, greyhoundInfo.baseDepth);\n\n\t\t\t//Ideally we want to change this bit completely, since\n\t\t\t//greyhound\"s options are wider than the default options for\n\t\t\t//visualizing pointclouds. If someone ever has time to build a\n\t\t\t//custom ui element for greyhound, the schema options from\n\t\t\t//this info request should be given to the UI, so the user can\n\t\t\t//choose between them. The selected option can then be\n\t\t\t//directly requested from the server in the\n\t\t\t//PointCloudGreyhoundGeometryNode without asking for\n\t\t\t//attributes that we are not currently visualizing.  We assume\n\t\t\t//XYZ are always available.\n\t\t\tvar attributes = [\"POSITION_CARTESIAN\"];\n\n\t\t\t//To be careful, we only add COLOR_PACKED as an option if all\n\t\t\t//colors are actually found.\n\t\t\tvar red = false;\n\t\t\tvar green = false;\n\t\t\tvar blue = false;\n\n\t\t\tgreyhoundInfo.schema.forEach(function(entry)\n\t\t\t{\n\t\t\t\t//Intensity and Classification are optional.\n\t\t\t\tif(entry.name === \"Intensity\")\n\t\t\t\t{\n\t\t\t\t\tattributes.push(\"INTENSITY\");\n\t\t\t\t}\n\t\t\t\tif(entry.name === \"Classification\")\n\t\t\t\t{\n\t\t\t\t\tattributes.push(\"CLASSIFICATION\");\n\t\t\t\t}\n\n\t\t\t\tif(entry.name === \"Red\") red = true;\n\t\t\t\telse if(entry.name === \"Green\") green = true;\n\t\t\t\telse if(entry.name === \"Blue\") blue = true;\n\t\t\t});\n\n\t\t\tif(red && green && blue) attributes.push(\"COLOR_PACKED\");\n\n\t\t\t//Fill in geometry fields.\n\t\t\tvar pgg = new PointCloudGreyhoundGeometry();\n\t\t\tpgg.serverURL = serverURL;\n\t\t\tpgg.spacing = (bounds[3] - bounds[0]) / Math.pow(2, baseDepth);\n\t\t\tpgg.baseDepth = baseDepth;\n\t\t\tpgg.hierarchyStepSize = HIERARCHY_STEP_SIZE;\n\n\t\t\tpgg.schema = GreyhoundUtils.createSchema(attributes);\n\t\t\tvar pointSize = GreyhoundUtils.pointSizeFrom(pgg.schema);\n\n\t\t\tpgg.pointAttributes = new PointAttributes(attributes);\n\t\t\tpgg.pointAttributes.byteSize = pointSize;\n\n\t\t\tvar boundingBox = new THREE.Box3(\n\t\t\t\tnew THREE.Vector3().fromArray(bounds, 0),\n\t\t\t\tnew THREE.Vector3().fromArray(bounds, 3)\n\t\t\t);\n\n\t\t\tvar offset = boundingBox.min.clone();\n\n\t\t\tboundingBox.max.sub(boundingBox.min);\n\t\t\tboundingBox.min.set(0, 0, 0);\n\n\t\t\tpgg.projection = greyhoundInfo.srs;\n\t\t\tpgg.boundingBox = boundingBox;\n\t\t\tpgg.boundingSphere = boundingBox.getBoundingSphere(new THREE.Sphere());\n\n\t\t\tpgg.scale = scale;\n\t\t\tpgg.offset = offset;\n\t\t\tpgg.loader = new GreyhoundBinaryLoader(version, boundingBox, pgg.scale);\n\n\t\t\tvar nodes = {};\n\n\t\t\t//load root\n\t\t\tvar name = \"r\";\n\n\t\t\tvar root = new PointCloudGreyhoundGeometryNode(name, pgg, boundingBox, scale, offset);\n\t\t\troot.level = 0;\n\t\t\troot.hasChildren = true;\n\t\t\troot.numPoints = greyhoundInfo.numPoints;\n\t\t\troot.spacing = pgg.spacing;\n\t\t\tpgg.root = root;\n\t\t\tpgg.root.load();\n\t\t\tnodes[name] = root;\n\t\n\t\t\tpgg.nodes = nodes;\n\n\t\t\tGreyhoundUtils.getNormalization(serverURL, greyhoundInfo.baseDepth,\n\t\t\t\tfunction(_, normalize)\n\t\t\t\t{\n\t\t\t\t\tif(normalize.color) pgg.normalize.color = true;\n\t\t\t\t\tif(normalize.intensity) pgg.normalize.intensity = true;\n\n\t\t\t\t\tcallback(pgg);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\tcatch(e)\n\t{\n\t\tconsole.log(\"Potree: Loading failed.\", url, e);\n\t\tcallback();\n\t}\n};\n\nGreyhoundLoader.loadPointAttributes = function(mno)\n{\n\tvar fpa = mno.pointAttributes;\n\tvar pa = new PointAttributes();\n\n\tfor(var i = 0; i < fpa.length; i++)\n\t{\n\t\tvar pointAttribute = PointAttribute[fpa[i]];\n\t\tpa.add(pointAttribute);\n\t}\n\n\treturn pa;\n};\n\nGreyhoundLoader.createChildAABB = function(aabb, childIndex)\n{\n\tvar min = aabb.min;\n\tvar max = aabb.max;\n\tvar dHalfLength = new THREE.Vector3().copy(max).sub(min).multiplyScalar(0.5);\n\tvar xHalfLength = new THREE.Vector3(dHalfLength.x, 0, 0);\n\tvar yHalfLength = new THREE.Vector3(0, dHalfLength.y, 0);\n\tvar zHalfLength = new THREE.Vector3(0, 0, dHalfLength.z);\n\n\tvar cmin = min;\n\tvar cmax = new THREE.Vector3().add(min).add(dHalfLength);\n\n\tif(childIndex === 1)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(zHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(zHalfLength);\n\t}\n\telse if(childIndex === 3)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(zHalfLength).add(yHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(zHalfLength).add(yHalfLength);\n\t}\n\telse if(childIndex === 0)\n\t{\n\t\tmin = cmin;\n\t\tmax = cmax;\n\t}\n\telse if(childIndex === 2)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(yHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(yHalfLength);\n\t}\n\telse if(childIndex === 5)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(zHalfLength).add(xHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(zHalfLength).add(xHalfLength);\n\t}\n\telse if(childIndex === 7)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(dHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(dHalfLength);\n\t}\n\telse if(childIndex === 4)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(xHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(xHalfLength);\n\t}\n\telse if(childIndex === 6)\n\t{\n\t\tmin = new THREE.Vector3().copy(cmin).add(xHalfLength).add(yHalfLength);\n\t\tmax = new THREE.Vector3().copy(cmax).add(xHalfLength).add(yHalfLength);\n\t}\n\n\treturn new THREE.Box3(min, max);\n};\n\nclass BinaryLoader\n{\n\tconstructor(version, boundingBox, scale)\n\t{\n\t\tif(typeof(version) === \"string\")\n\t\t{\n\t\t\tthis.version = new VersionUtils(version);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.version = version;\n\t\t}\n\n\t\tthis.boundingBox = boundingBox;\n\t\tthis.scale = scale;\n\t}\n\n\tload(node)\n\t{\n\t\tif(node.loaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar url = node.getURL();\n\n\t\tif(this.version.equalOrHigher(\"1.4\"))\n\t\t{\n\t\t\turl += \".bin\";\n\t\t}\n\t\t\n\t\tvar self = this;\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.onload = function()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tself.parse(node, xhr.response);\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function(event)\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.error(\"Potree: Failed to load file.\", xhr, url);\n\t\t};\n\n\t\txhr.send(null);\n\t};\n\n\tparse(node, buffer)\n\t{\n\t\tvar pointAttributes = node.pcoGeometry.pointAttributes;\n\t\tvar numPoints = buffer.byteLength / node.pcoGeometry.pointAttributes.byteSize;\n\n\t\tif(this.version.upTo(\"1.5\"))\n\t\t{\n\t\t\tnode.numPoints = numPoints;\n\t\t}\n\n\t\tvar message =\n\t\t{\n\t\t\tbuffer: buffer,\n\t\t\tpointAttributes: pointAttributes,\n\t\t\tversion: this.version.version,\n\t\t\tmin: [node.boundingBox.min.x, node.boundingBox.min.y, node.boundingBox.min.z],\n\t\t\toffset: [node.pcoGeometry.offset.x, node.pcoGeometry.offset.y, node.pcoGeometry.offset.z],\n\t\t\tscale: this.scale,\n\t\t\tspacing: node.spacing,\n\t\t\thasChildren: node.hasChildren,\n\t\t\tname: node.name\n\t\t};\n\n\t\tGlobal.workerPool.runTask(WorkerManager.BINARY_DECODER, function(e)\n\t\t{\n\t\t\tvar data = e.data;\n\n\t\t\tif(data.error !== undefined)\n\t\t\t{\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\tconsole.error(\"Potree: Binary worker error.\", data);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar buffers = data.attributeBuffers;\n\t\t\tvar tightBoundingBox = new THREE.Box3(new THREE.Vector3().fromArray(data.tightBoundingBox.min), new THREE.Vector3().fromArray(data.tightBoundingBox.max));\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tfor(var property in buffers)\n\t\t\t{\n\t\t\t\tvar buffer = buffers[property].buffer;\n\n\t\t\t\tif(parseInt(property) === PointAttributeNames.POSITION_CARTESIAN)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.COLOR_PACKED)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"color\", new THREE.BufferAttribute(new Uint8Array(buffer), 4, true));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.INTENSITY)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"intensity\", new THREE.BufferAttribute(new Float32Array(buffer), 1));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.CLASSIFICATION)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"classification\", new THREE.BufferAttribute(new Uint8Array(buffer), 1));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL_SPHEREMAPPED)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL_OCT16)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.NORMAL)\n\t\t\t\t{\n\t\t\t\t\tgeometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(buffer), 3));\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.INDICES)\n\t\t\t\t{\n\t\t\t\t\tvar bufferAttribute = new THREE.BufferAttribute(new Uint8Array(buffer), 4);\n\t\t\t\t\tbufferAttribute.normalized = true;\n\t\t\t\t\tgeometry.setAttribute(\"indices\", bufferAttribute);\n\t\t\t\t}\n\t\t\t\telse if(parseInt(property) === PointAttributeNames.SPACING)\n\t\t\t\t{\n\t\t\t\t\tvar bufferAttribute = new THREE.BufferAttribute(new Float32Array(buffer), 1);\n\t\t\t\t\tgeometry.setAttribute(\"spacing\", bufferAttribute);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttightBoundingBox.max.sub(tightBoundingBox.min);\n\t\t\ttightBoundingBox.min.set(0, 0, 0);\n\n\t\t\tvar numPoints = e.data.buffer.byteLength / pointAttributes.byteSize;\n\n\t\t\tnode.numPoints = numPoints;\n\t\t\tnode.geometry = geometry;\n\t\t\tnode.mean = new THREE.Vector3(...data.mean);\n\t\t\tnode.tightBoundingBox = tightBoundingBox;\n\t\t\tnode.loaded = true;\n\t\t\tnode.loading = false;\n\t\t\tnode.estimatedSpacing = data.estimatedSpacing;\n\t\t\tGlobal.numNodesLoading--;\n\t\t}, message, [message.buffer]);\n\t};\n}\n\nvar pointFormatReaders =\n[\n\tfunction(dv)\n\t{\n\t\treturn {\n\t\t\t\"position\": [ dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],\n\t\t\t\"intensity\": dv.getUint16(12, true),\n\t\t\t\"classification\": dv.getUint8(16, true)\n\t\t};\n\t},\n\tfunction(dv)\n\t{\n\t\treturn {\n\t\t\t\"position\": [ dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],\n\t\t\t\"intensity\": dv.getUint16(12, true),\n\t\t\t\"classification\": dv.getUint8(16, true)\n\t\t};\n\t},\n\tfunction(dv)\n\t{\n\t\treturn {\n\t\t\t\"position\": [ dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],\n\t\t\t\"intensity\": dv.getUint16(12, true),\n\t\t\t\"classification\": dv.getUint8(16, true),\n\t\t\t\"color\": [dv.getUint16(20, true), dv.getUint16(22, true), dv.getUint16(24, true)]\n\t\t};\n\t},\n\tfunction(dv)\n\t{\n\t\treturn {\n\t\t\t\"position\": [ dv.getInt32(0, true), dv.getInt32(4, true), dv.getInt32(8, true)],\n\t\t\t\"intensity\": dv.getUint16(12, true),\n\t\t\t\"classification\": dv.getUint8(16, true),\n\t\t\t\"color\": [dv.getUint16(28, true), dv.getUint16(30, true), dv.getUint16(32, true)]\n\t\t};\n\t}\n];\n\nfunction readAs(buf, Type, offset, count)\n{\n\tcount = (count === undefined || count === 0 ? 1 : count);\n\tvar sub = buf.slice(offset, offset + Type.BYTES_PER_ELEMENT * count);\n\n\tvar r = new Type(sub);\n\tif(count === undefined || count === 1)\n\t{\n\t\treturn r[0];\n\t}\n\n\tvar ret = [];\n\tfor(var i = 0 ; i < count ; i ++)\n\t{\n\t\tret.push(r[i]);\n\t}\n\n\treturn ret;\n}\n\nfunction parseLASHeader(arraybuffer)\n{\n\tvar data = {};\n\n\tdata.pointsOffset = readAs(arraybuffer, Uint32Array, 32*3);\n\tdata.pointsFormatId = readAs(arraybuffer, Uint8Array, 32*3+8);\n\tdata.pointsStructSize = readAs(arraybuffer, Uint16Array, 32*3+8+1);\n\tdata.pointsCount = readAs(arraybuffer, Uint32Array, 32*3 + 11);\n\n\tvar start = 32*3 + 35;\n\tdata.scale = readAs(arraybuffer, Float64Array, start, 3); start += 24; // 8*3\n\tdata.offset = readAs(arraybuffer, Float64Array, start, 3); start += 24;\n\n\tvar bounds = readAs(arraybuffer, Float64Array, start, 6); start += 48; // 8*6;\n\tdata.maxs = [bounds[0], bounds[2], bounds[4]];\n\tdata.mins = [bounds[1], bounds[3], bounds[5]];\n\n\treturn data;\n}\n\n// LAS Loader\n// Loads uncompressed files\n//\nfunction LASLoader(arraybuffer)\n{\n\tthis.arraybuffer = arraybuffer;\n}\nLASLoader.prototype.open = function()\n{\n\t// nothing needs to be done to open this file\n\t//\n\tthis.readOffset = 0;\n\treturn new Promise(function(res, rej)\n\t{\n\t\tsetTimeout(res, 0);\n\t});\n};\n\nLASLoader.prototype.getHeader = function()\n{\n\tvar self = this;\n\n\treturn new Promise(function(res, rej)\n\t{\n\t\tsetTimeout(function()\n\t\t{\n\t\t\tself.header = parseLASHeader(self.arraybuffer);\n\t\t\tres(self.header);\n\t\t}, 0);\n\t});\n};\n\nLASLoader.prototype.readData = function(count, offset, skip)\n{\n\tvar self = this;\n\n\treturn new Promise(function(res, rej)\n\t{\n\t\tsetTimeout(function()\n\t\t{\n\t\t\tif(!self.header)\n\t\t\t\treturn rej(new Error(\"Cannot start reading data till a header request is issued\"));\n\n\t\t\tvar start;\n\t\t\tif(skip <= 1)\n\t\t\t{\n\t\t\t\tcount = Math.min(count, self.header.pointsCount - self.readOffset);\n\t\t\t\tstart = self.header.pointsOffset + self.readOffset * self.header.pointsStructSize;\n\t\t\t\tvar end = start + count * self.header.pointsStructSize;\n\t\t\t\tres(\n\t\t\t\t{\n\t\t\t\t\tbuffer: self.arraybuffer.slice(start, end),\n\t\t\t\t\tcount: count,\n\t\t\t\t\thasMoreData: self.readOffset + count < self.header.pointsCount\n\t\t\t\t});\n\t\t\t\tself.readOffset += count;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar pointsToRead = Math.min(count * skip, self.header.pointsCount - self.readOffset);\n\t\t\t\tvar bufferSize = Math.ceil(pointsToRead / skip);\n\t\t\t\tvar pointsRead = 0;\n\n\t\t\t\tvar buf = new Uint8Array(bufferSize * self.header.pointsStructSize);\n\n\t\t\t\tfor(var i = 0 ; i < pointsToRead ; i++)\n\t\t\t\t{\n\t\t\t\t\tif(i % skip === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstart = self.header.pointsOffset + self.readOffset * self.header.pointsStructSize;\n\t\t\t\t\t\tvar src = new Uint8Array(self.arraybuffer, start, self.header.pointsStructSize);\n\n\t\t\t\t\t\tbuf.set(src, pointsRead * self.header.pointsStructSize);\n\t\t\t\t\t\tpointsRead ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tself.readOffset ++;\n\t\t\t\t}\n\n\t\t\t\tres(\n\t\t\t\t{\n\t\t\t\t\tbuffer: buf.buffer,\n\t\t\t\t\tcount: pointsRead,\n\t\t\t\t\thasMoreData: self.readOffset < self.header.pointsCount\n\t\t\t\t});\n\t\t\t}\n\t\t}, 0);\n\t});\n};\n\nLASLoader.prototype.close = function()\n{\n\tvar self = this;\n\treturn new Promise(function(res, rej)\n\t{\n\t\tself.arraybuffer = null;\n\t\tsetTimeout(res, 0);\n\t});\n};\n\n// LAZ Loader\n// Uses NaCL module to load LAZ files\n//\nfunction LAZLoader(arraybuffer)\n{\n\tvar self = this;\n\n\tthis.arraybuffer = arraybuffer;\n\tthis.nextCB = null;\n\n\tthis.dorr = function(req, cb)\n\t{\n\t\tself.nextCB = cb;\n\t\t\n\t\tGlobal.workerPool.runTask(WorkerManager.LAS_LAZ, function(e)\n\t\t{\n\t\t\tif(self.nextCB !== null)\n\t\t\t{\n\t\t\t\tself.nextCB(e.data);\n\t\t\t\tself.nextCB = null;\n\t\t\t}\n\t\t}, req);\n\t};\n}\nLAZLoader.prototype.open = function()\n{\n\t// nothing needs to be done to open this file\n\tvar self = this;\n\treturn new Promise(function(res, rej)\n\t{\n\t\tself.dorr({type:\"open\", arraybuffer: self.arraybuffer}, function(r)\n\t\t{\n\t\t\tif(r.status !== 1)\n\t\t\t{\n\t\t\t\treturn rej(new Error(\"Failed to open file\"));\n\t\t\t}\n\n\t\t\tres(true);\n\t\t});\n\t});\n};\n\nLAZLoader.prototype.getHeader = function()\n{\n\tvar self = this;\n\n\treturn new Promise(function(res, rej)\n\t{\n\t\tself.dorr({type:'header'}, function(r)\n\t\t{\n\t\t\tif(r.status !== 1)\n\t\t\t{\n\t\t\t\treturn rej(new Error(\"Failed to get header\"));\n\t\t\t}\n\n\t\t\tres(r.header);\n\t\t});\n\t});\n};\n\nLAZLoader.prototype.readData = function(count, offset, skip)\n{\n\tvar self = this;\n\n\treturn new Promise(function(res, rej)\n\t{\n\t\tself.dorr({type:'read', count: count, offset: offset, skip: skip}, function(r)\n\t\t{\n\t\t\tif(r.status !== 1)\n\t\t\t\treturn rej(new Error(\"Failed to read data\"));\n\t\t\tres({\n\t\t\t\tbuffer: r.buffer,\n\t\t\t\tcount: r.count,\n\t\t\t\thasMoreData: r.hasMoreData\n\t\t\t});\n\t\t});\n\t});\n};\n\nLAZLoader.prototype.close = function()\n{\n\tvar self = this;\n\n\treturn new Promise(function(res, rej)\n\t{\n\t\tself.dorr({type:'close'}, function(r)\n\t\t{\n\t\t\tif(r.status !== 1)\n\t\t\t{\n\t\t\t\treturn rej(new Error(\"Failed to close file\"));\n\t\t\t}\n\n\t\t\tres(true);\n\t\t});\n\t});\n};\n\n// A single consistent interface for loading LAS/LAZ files\nfunction LASFile(arraybuffer)\n{\n\tthis.arraybuffer = arraybuffer;\n\n\tthis.determineVersion();\n\tif(this.version > 12)\n\t{\n\t\tthrow new Error(\"Only file versions <= 1.2 are supported at this time\");\n\t}\n\n\tthis.determineFormat();\n\tif(pointFormatReaders[this.formatId] === undefined)\n\t{\n\t\tthrow new Error(\"The point format ID is not supported\");\n\t}\n\n\tthis.loader = this.isCompressed ? new LAZLoader(this.arraybuffer) : new LASLoader(this.arraybuffer);\n}\nLASFile.prototype.determineFormat = function()\n{\n\tvar formatId = readAs(this.arraybuffer, Uint8Array, 32*3+8);\n\tvar bit_7 = (formatId & 0x80) >> 7;\n\tvar bit_6 = (formatId & 0x40) >> 6;\n\n\tif(bit_7 === 1 && bit_6 === 1)\n\t{\n\t\tthrow new Error(\"Old style compression not supported\");\n\t}\n\n\tthis.formatId = formatId & 0x3f;\n\tthis.isCompressed = (bit_7 === 1 || bit_6 === 1);\n};\n\nLASFile.prototype.determineVersion = function()\n{\n\tvar ver = new Int8Array(this.arraybuffer, 24, 2);\n\tthis.version = ver[0] * 10 + ver[1];\n\tthis.versionAsString = ver[0] + \".\" + ver[1];\n};\n\nLASFile.prototype.open = function()\n{\n\treturn this.loader.open();\n};\n\nLASFile.prototype.getHeader = function()\n{\n\treturn this.loader.getHeader();\n};\n\nLASFile.prototype.readData = function(count, start, skip)\n{\n\treturn this.loader.readData(count, start, skip);\n};\n\nLASFile.prototype.close = function()\n{\n\treturn this.loader.close();\n};\n\n// Decodes LAS records into points\nfunction LASDecoder(buffer, pointFormatID, pointSize, pointsCount, scale, offset, mins, maxs)\n{\n\tthis.arrayb = buffer;\n\tthis.decoder = pointFormatReaders[pointFormatID];\n\tthis.pointsCount = pointsCount;\n\tthis.pointSize = pointSize;\n\tthis.scale = scale;\n\tthis.offset = offset;\n\tthis.mins = mins;\n\tthis.maxs = maxs;\n}\nLASDecoder.prototype.getPoint = function(index)\n{\n\tif(index < 0 || index >= this.pointsCount)\n\t{\n\t\tthrow new Error(\"Point index out of range\");\n\t}\n\n\treturn this.decoder(new DataView(this.arrayb, index * this.pointSize, this.pointSize));\n};\n\n/**\n * laslaz code taken and adapted from plas.io js-laslaz\n *\thttp://plas.io/\n *  https://github.com/verma/plasio\n *\n * Thanks to Uday Verma and Howard Butler\n */\nclass LASLAZLoader\n{\n\tconstructor(version)\n\t{\n\t\tif(typeof(version) === \"string\")\n\t\t{\n\t\t\tthis.version = new VersionUtils(version);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.version = version;\n\t\t}\n\t}\n\n\tload(node)\n\t{\n\t\tif(node.loaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar pointAttributes = node.pcoGeometry.pointAttributes;\n\t\tvar url = node.getURL();\n\n\t\tif(this.version.equalOrHigher(\"1.4\"))\n\t\t{\n\t\t\turl += \".\" + pointAttributes.toLowerCase();\n\t\t}\n\n\t\tvar self = this;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.onload = function()\n\t\t{\n\t\t\tif(xhr.response instanceof ArrayBuffer)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tself.parse(node, xhr.response);\n\t\t\t\t}\n\t\t\t\tcatch(e)\n\t\t\t\t{\n\t\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\tconsole.log(\"Potree: LASLAZLoader xhr response is not a ArrayBuffer.\");\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function()\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.log(\"Potree: LASLAZLoader failed to load file, \" + xhr.status + \", file: \" + url);\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\tparse(node, buffer)\n\t{\n\t\tvar lf = new LASFile(buffer);\n\t\tvar handler = new LASLAZBatcher(node);\n\n\t\tlf.open() .then(msg =>\n\t\t{\n\t\t\tlf.isOpen = true;\n\t\t\treturn lf;\n\t\t}).catch(msg =>\n\t\t{\n\t\t\tconsole.log(\"Potree: Failed to open file.\");\n\t\t}).then(lf =>\n\t\t{\n\t\t\treturn lf.getHeader().then(function(h)\n\t\t\t{\n\t\t\t\treturn [lf, h];\n\t\t\t});\n\t\t}).then(v =>\n\t\t{\n\t\t\tlet lf = v[0];\n\t\t\tlet header = v[1];\n\t\t\tlet skip = 1;\n\t\t\tlet totalRead = 0;\n\t\t\tlet totalToRead = ( header.pointsCount );\n\n\t\t\tvar reader = function()\n\t\t\t{\n\t\t\t\tlet p = lf.readData(1000000, 0, skip);\n\n\t\t\t\treturn p.then(function(data)\n\t\t\t\t{\n\t\t\t\t\thandler.push(new LASDecoder(data.buffer,\n\t\t\t\t\t\theader.pointsFormatId,\n\t\t\t\t\t\theader.pointsStructSize,\n\t\t\t\t\t\tdata.count,\n\t\t\t\t\t\theader.scale,\n\t\t\t\t\t\theader.offset,\n\t\t\t\t\t\theader.mins, header.maxs));\n\n\t\t\t\t\ttotalRead += data.count;\n\n\t\t\t\t\tif(data.hasMoreData)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn reader();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\theader.totalRead = totalRead;\n\t\t\t\t\t\theader.versionAsString = lf.versionAsString;\n\t\t\t\t\t\theader.isCompressed = lf.isCompressed;\n\t\t\t\t\t\treturn [lf, header, handler];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reader();\n\t\t}).then(v =>\n\t\t{\n\t\t\tlet lf = v[0];\n\n\t\t\t//Close it\n\t\t\treturn lf.close().then(function()\n\t\t\t{\n\t\t\t\tlf.isOpen = false;\n\t\t\t\treturn v.slice(1);\n\t\t\t}).catch(e =>\n\t\t\t{\n\t\t\t\t//If there was a cancellation, make sure the file is closed, if the file is open close and then fail\n\t\t\t\tif(lf.isOpen)\n\t\t\t\t{\n\t\t\t\t\treturn lf.close().then(function()\n\t\t\t\t\t{\n\t\t\t\t\t\tlf.isOpen = false;\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t});\n\t\t});\n\t}\n\n\thandle(node, url){}\n}\nclass LASLAZBatcher\n{\n\tconstructor(node)\n\t{\n\t\tthis.node = node;\n\t}\n\n\tpush(data)\n\t{\n\t\tvar self = this;\n\n\t\tvar message =\n\t\t{\n\t\t\tbuffer: data.arrayb,\n\t\t\tnumPoints: data.pointsCount,\n\t\t\tpointSize: data.pointSize,\n\t\t\tpointFormatID: 2,\n\t\t\tscale: data.scale,\n\t\t\toffset: data.offset,\n\t\t\tmins: data.mins,\n\t\t\tmaxs: data.maxs\n\t\t};\n\n\t\tvar worker = Global.workerPool.getWorker(WorkerManager.LAS_DECODER);\n\t\tworker.onmessage = function(e)\n\t\t{\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar numPoints = data.pointsCount;\n\n\t\t\tvar positions = new Float32Array(e.data.position);\n\t\t\tvar colors = new Uint8Array(e.data.color);\n\t\t\tvar intensities = new Float32Array(e.data.intensity);\n\t\t\tvar classifications = new Uint8Array(e.data.classification);\n\t\t\tvar returnNumbers = new Uint8Array(e.data.returnNumber);\n\t\t\tvar numberOfReturns = new Uint8Array(e.data.numberOfReturns);\n\t\t\tvar pointSourceIDs = new Uint16Array(e.data.pointSourceID);\n\t\t\tvar indices = new Uint8Array(e.data.indices);\n\n\t\t\tgeometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n\t\t\tgeometry.setAttribute(\"color\", new THREE.BufferAttribute(colors, 4, true));\n\t\t\tgeometry.setAttribute(\"intensity\", new THREE.BufferAttribute(intensities, 1));\n\t\t\tgeometry.setAttribute(\"classification\", new THREE.BufferAttribute(classifications, 1));\n\t\t\tgeometry.setAttribute(\"returnNumber\", new THREE.BufferAttribute(returnNumbers, 1));\n\t\t\tgeometry.setAttribute(\"numberOfReturns\", new THREE.BufferAttribute(numberOfReturns, 1));\n\t\t\tgeometry.setAttribute(\"pointSourceID\", new THREE.BufferAttribute(pointSourceIDs, 1));\n\t\t\t//geometry.setAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(numPoints * 3), 3));\n\t\t\tgeometry.setAttribute(\"indices\", new THREE.BufferAttribute(indices, 4));\n\t\t\tgeometry.attributes.indices.normalized = true;\n\n\t\t\tvar tightBoundingBox = new THREE.Box3\n\t\t\t(\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.min),\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.max)\n\t\t\t);\n\n\t\t\tgeometry.boundingBox = self.node.boundingBox;\n\t\t\tself.node.tightBoundingBox = tightBoundingBox;\n\n\t\t\tself.node.geometry = geometry;\n\t\t\tself.node.numPoints = numPoints;\n\t\t\tself.node.loaded = true;\n\t\t\tself.node.loading = false;\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tself.node.mean = new THREE.Vector3(...e.data.mean);\n\n\t\t\tGlobal.workerPool.returnWorker(WorkerManager.LAS_DECODER, worker);\n\t\t};\n\n\t\tworker.postMessage(message, [message.buffer]);\n\t};\n}\n\nclass PointCloudOctreeGeometry\n{\n\tconstructor()\n\t{\n\t\tthis.url = null;\n\t\tthis.octreeDir = null;\n\t\tthis.spacing = 0;\n\t\tthis.boundingBox = null;\n\t\tthis.root = null;\n\t\tthis.nodes = null;\n\t\tthis.pointAttributes = null;\n\t\tthis.hierarchyStepSize = -1;\n\t\tthis.loader = null;\n\t}\n}\nclass PointCloudOctreeGeometryNode extends PointCloudTreeNode\n{\n\tconstructor(name, pcoGeometry, boundingBox)\n\t{\n\t\tsuper();\n\n\t\tthis.id = PointCloudOctreeGeometryNode.IDCount++;\n\t\tthis.name = name;\n\t\tthis.index = parseInt(name.charAt(name.length - 1));\n\t\tthis.pcoGeometry = pcoGeometry;\n\t\tthis.geometry = null;\n\t\tthis.boundingBox = boundingBox;\n\t\tthis.boundingSphere = boundingBox.getBoundingSphere(new THREE.Sphere());\n\t\tthis.children = {};\n\t\tthis.numPoints = 0;\n\t\tthis.level = null;\n\t\tthis.loaded = false;\n\t\tthis.oneTimeDisposeHandlers = [];\n\t}\n\n\tisGeometryNode()\n\t{\n\t\treturn true;\n\t}\n\n\tgetLevel()\n\t{\n\t\treturn this.level;\n\t}\n\n\tisTreeNode()\n\t{\n\t\treturn false;\n\t}\n\n\tisLoaded()\n\t{\n\t\treturn this.loaded;\n\t}\n\n\tgetBoundingSphere()\n\t{\n\t\treturn this.boundingSphere;\n\t}\n\n\tgetBoundingBox()\n\t{\n\t\treturn this.boundingBox;\n\t}\n\n\tgetChildren()\n\t{\n\t\tvar children = [];\n\n\t\tfor(var i = 0; i < 8; i++)\n\t\t{\n\t\t\tif(this.children[i])\n\t\t\t{\n\t\t\t\tchildren.push(this.children[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn children;\n\t}\n\n\tgetURL()\n\t{\n\t\tvar url = \"\";\n\t\tvar version = this.pcoGeometry.loader.version;\n\n\t\tif(version.equalOrHigher(\"1.5\"))\n\t\t{\n\t\t\turl = this.pcoGeometry.octreeDir + \"/\" + this.getHierarchyPath() + \"/\" + this.name;\n\t\t}\n\t\telse if(version.equalOrHigher(\"1.4\"))\n\t\t{\n\t\t\turl = this.pcoGeometry.octreeDir + \"/\" + this.name;\n\t\t}\n\t\telse if(version.upTo(\"1.3\"))\n\t\t{\n\t\t\turl = this.pcoGeometry.octreeDir + \"/\" + this.name;\n\t\t}\n\n\t\treturn url;\n\t}\n\n\tgetHierarchyPath()\n\t{\n\t\tvar path = \"r/\";\n\t\tvar hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\n\t\tvar indices = this.name.substr(1);\n\n\t\tvar numParts = Math.floor(indices.length / hierarchyStepSize);\n\t\tfor(var i = 0; i < numParts; i++)\n\t\t{\n\t\t\tpath += indices.substr(i * hierarchyStepSize, hierarchyStepSize) + \"/\";\n\t\t}\n\n\t\tpath = path.slice(0, -1);\n\n\t\treturn path;\n\t}\n\n\taddChild(child)\n\t{\n\t\tthis.children[child.index] = child;\n\t\tchild.parent = this;\n\t}\n\n\tload()\n\t{\n\t\tif(this.loading === true || this.loaded === true || Global.numNodesLoading >= Global.maxNodesLoading)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.loading = true;\n\t\tGlobal.numNodesLoading++;\n\n\t\ttry\n\t\t{\n\t\t\tif(this.pcoGeometry.loader.version.equalOrHigher(\"1.5\"))\n\t\t\t{\n\t\t\t\tif((this.level % this.pcoGeometry.hierarchyStepSize) === 0 && this.hasChildren)\n\t\t\t\t{\n\t\t\t\t\tthis.loadHierachyThenPoints();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.loadPoints();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.loadPoints();\n\t\t\t}\n\t\t}\n\t\tcatch(e)\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.error(\"Potree: Exception thrown loading points file.\", e);\n\t\t}\n\n\t}\n\n\tloadPoints()\n\t{\n\t\tthis.pcoGeometry.loader.load(this);\n\t}\n\n\tloadHierachyThenPoints()\n\t{\n\t\tvar node = this;\n\n\t\tvar callback = function(node, hbuffer)\n\t\t{\n\t\t\tvar view = new DataView(hbuffer);\n\n\t\t\tvar stack = [];\n\t\t\tvar children = view.getUint8(0);\n\t\t\tvar numPoints = view.getUint32(1, true);\n\t\t\tnode.numPoints = numPoints;\n\t\t\tstack.push({children: children, numPoints: numPoints, name: node.name});\n\n\t\t\tvar decoded = [];\n\t\t\tvar offset = 5;\n\n\t\t\twhile(stack.length > 0)\n\t\t\t{\n\t\t\t\tvar snode = stack.shift();\n\t\t\t\tvar mask = 1;\n\t\t\t\tfor(var i = 0; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tif((snode.children & mask) !== 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar childName = snode.name + i;\n\t\t\t\t\t\tvar childChildren = view.getUint8(offset);\n\t\t\t\t\t\tvar childNumPoints = view.getUint32(offset + 1, true);\n\n\t\t\t\t\t\tstack.push({children: childChildren, numPoints: childNumPoints, name: childName});\n\t\t\t\t\t\tdecoded.push({children: childChildren, numPoints: childNumPoints, name: childName});\n\n\t\t\t\t\t\toffset += 5;\n\t\t\t\t\t}\n\n\t\t\t\t\tmask = mask * 2;\n\t\t\t\t}\n\n\t\t\t\tif(offset === hbuffer.byteLength)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nodes = {};\n\t\t\tnodes[node.name] = node;\n\t\t\tvar pco = node.pcoGeometry;\n\n\t\t\tfor(var i = 0; i < decoded.length; i++)\n\t\t\t{\n\t\t\t\tvar name = decoded[i].name;\n\t\t\t\tvar decodedNumPoints = decoded[i].numPoints;\n\t\t\t\tvar index = parseInt(name.charAt(name.length - 1));\n\t\t\t\tvar parentName = name.substring(0, name.length - 1);\n\t\t\t\tvar parentNode = nodes[parentName];\n\t\t\t\tvar level = name.length - 1;\n\t\t\t\tvar boundingBox = POCLoader.createChildAABB(parentNode.boundingBox, index);\n\n\t\t\t\tvar currentNode = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n\t\t\t\tcurrentNode.level = level;\n\t\t\t\tcurrentNode.numPoints = decodedNumPoints;\n\t\t\t\tcurrentNode.hasChildren = decoded[i].children > 0;\n\t\t\t\tcurrentNode.spacing = pco.spacing / Math.pow(2, level);\n\t\t\t\tparentNode.addChild(currentNode);\n\t\t\t\tnodes[name] = currentNode;\n\t\t\t}\n\n\t\t\tnode.loadPoints();\n\t\t};\n\t\t\n\t\tif((node.level % node.pcoGeometry.hierarchyStepSize) === 0)\n\t\t{\n\t\t\tvar hurl = node.pcoGeometry.octreeDir + \"/\" + node.getHierarchyPath() + \"/\" + node.name + \".hrc\";\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open(\"GET\", hurl, true);\n\t\t\txhr.responseType = \"arraybuffer\";\n\t\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\t\txhr.onload = function(event)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tcallback(node, xhr.response);\n\t\t\t\t}\n\t\t\t\tcatch(e)\n\t\t\t\t{\n\t\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\txhr.onerror = function(event)\n\t\t\t{\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t\tconsole.error(\"Potree: Failed to load file.\", xhr.status, hurl, event);\n\t\t\t};\n\t\t\txhr.send(null);\n\t\t}\n\t}\n\n\tgetNumPoints()\n\t{\n\t\treturn this.numPoints;\n\t}\n\n\tdispose()\n\t{\n\t\tif(this.geometry && this.parent != null)\n\t\t{\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.geometry = null;\n\t\t\tthis.loaded = false;\n\n\t\t\tfor(var i = 0; i < this.oneTimeDisposeHandlers.length; i++)\n\t\t\t{\n\t\t\t\tvar handler = this.oneTimeDisposeHandlers[i];\n\t\t\t\thandler();\n\t\t\t}\n\t\t\tthis.oneTimeDisposeHandlers = [];\n\t\t}\n\t}\n\n}\n\nPointCloudOctreeGeometryNode.IDCount = 0;\n\nObject.assign(PointCloudOctreeGeometryNode.prototype, THREE.EventDispatcher.prototype);\n\n/**\n * @class Loads mno files and returns a PointcloudOctree\n * for a description of the mno binary file format, read mnoFileFormat.txt\n *\n * @author Markus Schuetz\n */\nclass POCLoader\n{\n\t/**\n\t * @return a point cloud octree with the root node data loaded.\n\t * loading of descendants happens asynchronously when they\"re needed\n\t *\n\t * @param url\n\t * @param loadingFinishedListener executed after loading the binary has been finished\n\t */\n\tstatic load(url, callback)\n\t{\n\t\tvar pco = new PointCloudOctreeGeometry();\n\t\tpco.url = url;\n\t\t\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.onload = function()\n\t\t{\n\t\t\tvar data = JSON.parse(xhr.responseText);\n\t\t\tvar version = new VersionUtils(data.version);\n\n\t\t\t//Assume dir as absolute if it starts with http\n\t\t\tif(data.octreeDir.indexOf(\"http\") === 0)\n\t\t\t{\n\t\t\t\tpco.octreeDir = data.octreeDir;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpco.octreeDir = url + \"/../\" + data.octreeDir;\n\t\t\t}\n\n\t\t\tpco.spacing = data.spacing;\n\t\t\tpco.hierarchyStepSize = data.hierarchyStepSize;\n\t\t\tpco.pointAttributes = data.pointAttributes;\n\n\t\t\tvar min = new THREE.Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\n\t\t\tvar max = new THREE.Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\n\t\t\tvar boundingBox = new THREE.Box3(min, max);\n\t\t\tvar tightBoundingBox = boundingBox.clone();\n\n\t\t\tif(data.tightBoundingBox)\n\t\t\t{\n\t\t\t\ttightBoundingBox.min.copy(new THREE.Vector3(data.tightBoundingBox.lx, data.tightBoundingBox.ly, data.tightBoundingBox.lz));\n\t\t\t\ttightBoundingBox.max.copy(new THREE.Vector3(data.tightBoundingBox.ux, data.tightBoundingBox.uy, data.tightBoundingBox.uz));\n\t\t\t}\n\n\t\t\tvar offset = min.clone();\n\n\t\t\tboundingBox.min.sub(offset);\n\t\t\tboundingBox.max.sub(offset);\n\n\t\t\ttightBoundingBox.min.sub(offset);\n\t\t\ttightBoundingBox.max.sub(offset);\n\n\t\t\tpco.projection = data.projection;\n\t\t\tpco.boundingBox = boundingBox;\n\t\t\tpco.tightBoundingBox = tightBoundingBox;\n\t\t\tpco.boundingSphere = boundingBox.getBoundingSphere(new THREE.Sphere());\n\t\t\tpco.tightBoundingSphere = tightBoundingBox.getBoundingSphere(new THREE.Sphere());\n\t\t\tpco.offset = offset;\n\n\t\t\t//Select the appropiate loader\n\t\t\tif(data.pointAttributes === \"LAS\" || data.pointAttributes === \"LAZ\")\n\t\t\t{\n\t\t\t\tpco.loader = new LASLAZLoader(data.version);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpco.loader = new BinaryLoader(data.version, boundingBox, data.scale);\n\t\t\t\tpco.pointAttributes = new PointAttributes(pco.pointAttributes);\n\t\t\t}\n\n\t\t\tvar nodes = {};\n\t\t\tvar name = \"r\";\n\n\t\t\tvar root = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n\t\t\troot.level = 0;\n\t\t\troot.hasChildren = true;\n\t\t\troot.spacing = pco.spacing;\n\t\t\troot.numPoints = version.upTo(\"1.5\") ? data.hierarchy[0][1] : 0;\n\n\t\t\tpco.root = root;\n\t\t\tpco.root.load();\n\t\t\tnodes[name] = root;\n\n\t\t\t//Load remaining hierarchy\n\t\t\tif(version.upTo(\"1.4\"))\n\t\t\t{\n\t\t\t\tfor(var i = 1; i < data.hierarchy.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar name = data.hierarchy[i][0];\n\t\t\t\t\tvar numPoints = data.hierarchy[i][1];\n\t\t\t\t\tvar index = parseInt(name.charAt(name.length - 1));\n\t\t\t\t\tvar parentName = name.substring(0, name.length - 1);\n\t\t\t\t\tvar parentNode = nodes[parentName];\n\t\t\t\t\tvar level = name.length - 1;\n\t\t\t\t\tvar boundingBox = POCLoader.createChildAABB(parentNode.boundingBox, index);\n\n\t\t\t\t\tvar node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n\t\t\t\t\tnode.level = level;\n\t\t\t\t\tnode.numPoints = numPoints;\n\t\t\t\t\tnode.spacing = pco.spacing / Math.pow(2, level);\n\t\t\t\t\tparentNode.addChild(node);\n\t\t\t\t\tnodes[name] = node;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpco.nodes = nodes;\n\n\t\t\tcallback(pco);\n\t\t};\n\n\t\txhr.onerror = function(event)\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.log(\"Potree: loading file failed.\", url, event);\n\t\t\tcallback();\n\t\t};\n\n\t\txhr.send(null);\n\t}\n\n\tstatic loadPointAttributes(mno)\n\t{\n\t\tvar fpa = mno.pointAttributes;\n\t\tvar pa = new PointAttributes();\n\n\t\tfor(var i = 0; i < fpa.length; i++)\n\t\t{\n\t\t\tpa.add(PointAttribute[fpa[i]]);\n\t\t}\n\n\t\treturn pa;\n\t}\n\n\tstatic createChildAABB(aabb, index)\n\t{\n\t\tvar min = aabb.min.clone();\n\t\tvar max = aabb.max.clone();\n\t\tvar size = new THREE.Vector3().subVectors(max, min);\n\n\t\tif((index & 0b0001) > 0)\n\t\t{\n\t\t\tmin.z += size.z / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax.z -= size.z / 2;\n\t\t}\n\n\t\tif((index & 0b0010) > 0)\n\t\t{\n\t\t\tmin.y += size.y / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax.y -= size.y / 2;\n\t\t}\n\n\t\tif((index & 0b0100) > 0)\n\t\t{\n\t\t\tmin.x += size.x / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax.x -= size.x / 2;\n\t\t}\n\n\t\treturn new THREE.Box3(min, max);\n\t}\n}\n\nclass EptBinaryLoader\n{\n\tload(node)\n\t{\n\t\tif(node.loaded) return;\n\n\t\tvar url = node.url() + \".bin\";\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.onreadystatechange = () =>\n\t\t{\n\t\t\tif(xhr.readyState === 4)\n\t\t\t{\n\t\t\t\tif(xhr.status === 200)\n\t\t\t\t{\n\t\t\t\t\tvar buffer = xhr.response;\n\t\t\t\t\tthis.parse(node, buffer);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconsole.log(\"Failed \" + url + \": \" + xhr.status);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\ttry\n\t\t{\n\t\t\txhr.send(null);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tconsole.log(\"Failed request: \" + e);\n\t\t}\n\t}\n\n\tparse(node, buffer)\n\t{\n\t\tvar worker = Global.workerPool.getWorker(WorkerManager.EPT_BINARY_DECODER);\n\n\t\tworker.onmessage = function(e)\n\t\t{\n\t\t\tvar g = new THREE.BufferGeometry();\n\t\t\tvar numPoints = e.data.numPoints;\n\n\t\t\tvar position = new Float32Array(e.data.position);\n\t\t\tg.setAttribute(\"position\", new THREE.BufferAttribute(position, 3));\n\n\t\t\tvar indices = new Uint8Array(e.data.indices);\n\t\t\tg.setAttribute(\"indices\", new THREE.BufferAttribute(indices, 4));\n\n\t\t\tif(e.data.color)\n\t\t\t{\n\t\t\t\tvar color = new Uint8Array(e.data.color);\n\t\t\t\tg.setAttribute(\"color\", new THREE.BufferAttribute(color, 4, true));\n\t\t\t}\n\t\t\tif(e.data.intensity)\n\t\t\t{\n\t\t\t\tvar intensity = new Float32Array(e.data.intensity);\n\t\t\t\tg.setAttribute(\"intensity\", new THREE.BufferAttribute(intensity, 1));\n\t\t\t}\n\t\t\tif(e.data.classification)\n\t\t\t{\n\t\t\t\tvar classification = new Uint8Array(e.data.classification);\n\t\t\t\tg.setAttribute(\"classification\", new THREE.BufferAttribute(classification, 1));\n\t\t\t}\n\t\t\tif(e.data.returnNumber)\n\t\t\t{\n\t\t\t\tvar returnNumber = new Uint8Array(e.data.returnNumber);\n\t\t\t\tg.setAttribute(\"returnNumber\", new THREE.BufferAttribute(returnNumber, 1));\n\t\t\t}\n\t\t\tif(e.data.numberOfReturns)\n\t\t\t{\n\t\t\t\tvar numberOfReturns = new Uint8Array(e.data.numberOfReturns);\n\t\t\t\tg.setAttribute(\"numberOfReturns\", new THREE.BufferAttribute(numberOfReturns, 1));\n\t\t\t}\n\t\t\tif(e.data.pointSourceId)\n\t\t\t{\n\t\t\t\tvar pointSourceId = new Uint16Array(e.data.pointSourceId);\n\t\t\t\tg.setAttribute(\"pointSourceID\", new THREE.BufferAttribute(pointSourceId, 1));\n\t\t\t}\n\n\t\t\tg.attributes.indices.normalized = true;\n\n\t\t\tvar tightBoundingBox = new THREE.Box3(\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.min),\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.max)\n\t\t\t);\n\n\t\t\tnode.doneLoading(g, tightBoundingBox, numPoints, new THREE.Vector3(...e.data.mean));\n\n\t\t\tGlobal.workerPool.returnWorker(WorkerManager.EPT_BINARY_DECODER, worker);\n\t\t};\n\n\t\tvar toArray = (v) => [v.x, v.y, v.z];\n\t\tvar message = {\n\t\t\tbuffer: buffer,\n\t\t\tschema: node.ept.schema,\n\t\t\tscale: node.ept.eptScale,\n\t\t\toffset: node.ept.eptOffset,\n\t\t\tmins: toArray(node.key.b.min)\n\t\t};\n\n\t\tworker.postMessage(message, [message.buffer]);\n\t}\n}\n\n/**\n * laslaz code taken and adapted from plas.io js-laslaz\n *\thttp://plas.io/\n *\thttps://github.com/verma/plasio\n *\n * Thanks to Uday Verma and Howard Butler\n *\n */\nclass EptLaszipLoader\n{\n\tload(node)\n\t{\n\t\tif(node.loaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar url = node.url() + \".laz\";\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n\t\txhr.onreadystatechange = () =>\n\t\t{\n\t\t\tif(xhr.readyState === 4)\n\t\t\t{\n\t\t\t\tif(xhr.status === 200)\n\t\t\t\t{\n\t\t\t\t\tvar buffer = xhr.response;\n\t\t\t\t\tthis.parse(node, buffer);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconsole.log(\"Failed \" + url + \": \" + xhr.status);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\txhr.send(null);\n\t}\n\n\tparse(node, buffer)\n\t{\n\t\tvar lf = new LASFile(buffer);\n\t\tvar handler = new EptLazBatcher(node);\n\n\t\tlf.open()\n\t\t.then(() =>\n\t\t{\n\t\t\tlf.isOpen = true;\n\t\t\treturn lf.getHeader();\n\t\t})\n\t\t.then((header) =>\n\t\t{\n\t\t\tvar i = 0;\n\t\t\tvar np = header.pointsCount;\n\n\t\t\tvar toArray = (v) => [v.x, v.y, v.z];\n\t\t\tvar mins = toArray(node.key.b.min);\n\t\t\tvar maxs = toArray(node.key.b.max);\n\n\t\t\tvar read = () =>\n\t\t\t{\n\t\t\t\tvar p = lf.readData(1000000, 0, 1);\n\t\t\t\treturn p.then(function (data)\n\t\t\t\t{\n\t\t\t\t\tvar d = new LASDecoder(\n\t\t\t\t\t\t\tdata.buffer,\n\t\t\t\t\t\t\theader.pointsFormatId,\n\t\t\t\t\t\t\theader.pointsStructSize,\n\t\t\t\t\t\t\tdata.count,\n\t\t\t\t\t\t\theader.scale,\n\t\t\t\t\t\t\theader.offset,\n\t\t\t\t\t\t\tmins,\n\t\t\t\t\t\t\tmaxs);\n\t\t\t\t\td.extraBytes = header.extraBytes;\n\t\t\t\t\td.pointsFormatId = header.pointsFormatId;\n\t\t\t\t\thandler.push(d);\n\n\t\t\t\t\ti += data.count;\n\n\t\t\t\t\tif(data.hasMoreData)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn read();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\theader.totalRead = i;\n\t\t\t\t\t\theader.versionAsString = lf.versionAsString;\n\t\t\t\t\t\theader.isCompressed = lf.isCompressed;\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn read();\n\t\t})\n\t\t.then(() => lf.close())\n\t\t.then(() => lf.isOpen = false)\n\t\t.catch((err) =>\n\t\t{\n\t\t\tconsole.log(\"Error reading LAZ:\", err);\n\t\t\tif(lf.isOpen)\n\t\t\t{\n\t\t\t\tlf.close().then(() =>\n\t\t\t\t{\n\t\t\t\t\tlf.isOpen = false;\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse throw err;\n\t\t});\n\t}\n}\nclass EptLazBatcher\n{\n\tconstructor(node)\n\t{\n\t\tthis.node = node;\n\t}\n\n\tpush(las)\n\t{\n\t\tvar worker = Global.workerPool.getWorker(WorkerManager.EPT_LAS_ZIP_DECODER);\n\n\t\tworker.onmessage = (e) =>\n\t\t{\n\t\t\tvar g = new THREE.BufferGeometry();\n\t\t\tvar numPoints = las.pointsCount;\n\n\t\t\tvar positions = new Float32Array(e.data.position);\n\t\t\tvar colors = new Uint8Array(e.data.color);\n\n\t\t\tvar intensities = new Float32Array(e.data.intensity);\n\t\t\tvar classifications = new Uint8Array(e.data.classification);\n\t\t\tvar returnNumbers = new Uint8Array(e.data.returnNumber);\n\t\t\tvar numberOfReturns = new Uint8Array(e.data.numberOfReturns);\n\t\t\tvar pointSourceIDs = new Uint16Array(e.data.pointSourceID);\n\t\t\tvar indices = new Uint8Array(e.data.indices);\n\n\t\t\tg.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n\t\t\tg.setAttribute(\"color\", new THREE.BufferAttribute(colors, 4, true));\n\t\t\tg.setAttribute(\"intensity\", new THREE.BufferAttribute(intensities, 1));\n\t\t\tg.setAttribute(\"classification\", new THREE.BufferAttribute(classifications, 1));\n\t\t\tg.setAttribute(\"returnNumber\", new THREE.BufferAttribute(returnNumbers, 1));\n\t\t\tg.setAttribute(\"numberOfReturns\", new THREE.BufferAttribute(numberOfReturns, 1));\n\t\t\tg.setAttribute(\"pointSourceID\", new THREE.BufferAttribute(pointSourceIDs, 1));\n\t\t\tg.setAttribute(\"indices\", new THREE.BufferAttribute(indices, 4));\n\t\t\tg.attributes.indices.normalized = true;\n\n\t\t\tvar tightBoundingBox = new THREE.Box3(\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.min),\n\t\t\t\tnew THREE.Vector3().fromArray(e.data.tightBoundingBox.max)\n\t\t\t);\n\n\t\t\tthis.node.doneLoading(g, tightBoundingBox, numPoints, new THREE.Vector3(...e.data.mean));\n\n\t\t\tGlobal.workerPool.returnWorker(WorkerManager.EPT_LAS_ZIP_DECODER, worker);\n\t\t};\n\n\t\tvar message = {\n\t\t\tbuffer: las.arrayb,\n\t\t\tnumPoints: las.pointsCount,\n\t\t\tpointSize: las.pointSize,\n\t\t\tpointFormatID: las.pointsFormatId,\n\t\t\tscale: las.scale,\n\t\t\toffset: las.offset,\n\t\t\tmins: las.mins,\n\t\t\tmaxs: las.maxs\n\t\t};\n\n\t\tworker.postMessage(message, [message.buffer]);\n\t};\n}\n\nclass Utils\n{\n\tstatic toVector3(v, offset)\n\t{\n\t\treturn new THREE.Vector3().fromArray(v, offset || 0);\n\t}\n\n\tstatic toBox3(b)\n\t{\n\t\treturn new THREE.Box3(Utils.toVector3(b), Utils.toVector3(b, 3));\n\t};\n\n\tstatic findDim(schema, name)\n\t{\n\t\tvar dim = schema.find((dim) => dim.name == name);\n\t\tif(!dim) throw new Error(\"Failed to find \" + name + \" in schema\");\n\t\treturn dim;\n\t}\n\n\tstatic sphereFrom(b)\n\t{\n\t\treturn b.getBoundingSphere(new THREE.Sphere());\n\t}\n}\nclass PointCloudEptGeometry\n{\n\tconstructor(url, info)\n\t{\n\t\tlet version = info.version;\n\t\tlet schema = info.schema;\n\t\tlet bounds = info.bounds;\n\t\tlet boundsConforming = info.boundsConforming;\n\n\t\tlet xyz = [\n\t\t\tUtils.findDim(schema, \"X\"),\n\t\t\tUtils.findDim(schema, \"Y\"),\n\t\t\tUtils.findDim(schema, \"Z\")\n\t\t];\n\t\tlet scale = xyz.map((d) => d.scale || 1);\n\t\tlet offset = xyz.map((d) => d.offset || 0);\n\n\t\tthis.eptScale = Utils.toVector3(scale);\n\t\tthis.eptOffset = Utils.toVector3(offset);\n\n\t\tthis.url = url;\n\t\tthis.info = info;\n\t\tthis.type = \"ept\";\n\n\t\tthis.schema = schema;\n\t\tthis.span = info.span || info.ticks;\n\t\tthis.boundingBox = Utils.toBox3(bounds);\n\t\tthis.tightBoundingBox = Utils.toBox3(boundsConforming);\n\t\tthis.offset = Utils.toVector3([0, 0, 0]);\n\t\tthis.boundingSphere = Utils.sphereFrom(this.boundingBox);\n\t\tthis.tightBoundingSphere = Utils.sphereFrom(this.tightBoundingBox);\n\t\tthis.version = new VersionUtils(\"1.6\");\n\n\t\tthis.projection = null;\n\t\tthis.fallbackProjection = null;\n\n\t\tif(info.srs && info.srs.horizontal)\n\t\t{\n\t\t\tthis.projection = info.srs.authority + \":\" + info.srs.horizontal;\n\t\t}\n\n\t\tif(info.srs.wkt)\n\t\t{\n\t\t\tif(!this.projection) this.projection = info.srs.wkt;\n\t\t\telse this.fallbackProjection = info.srs.wkt;\n\t\t}\n\n\t\tthis.pointAttributes = \"LAZ\";\n\t\tthis.spacing =\n\t\t\t(this.boundingBox.max.x - this.boundingBox.min.x) / this.span;\n\n\t\tlet hierarchyType = info.hierarchyType || \"json\";\n\n\t\tlet dataType = info.dataType || \"laszip\";\n\t\tthis.loader = dataType == \"binary\" ? new EptBinaryLoader() : new EptLaszipLoader();\n\t}\n}\nclass EptKey\n{\n\tconstructor(ept, b, d, x, y, z)\n\t{\n\t\tthis.ept = ept;\n\t\tthis.b = b;\n\t\tthis.d = d;\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t}\n\n\tname()\n\t{\n\t\treturn this.d + \"-\" + this.x + \"-\" + this.y + \"-\" + this.z;\n\t}\n\n\tstep(a, b, c)\n\t{\n\t\tlet min = this.b.min.clone();\n\t\tlet max = this.b.max.clone();\n\t\tlet dst = new THREE.Vector3().subVectors(max, min);\n\n\t\tif(a) min.x += dst.x / 2;\n\t\telse max.x -= dst.x / 2;\n\n\t\tif(b) min.y += dst.y / 2;\n\t\telse max.y -= dst.y / 2;\n\n\t\tif(c) min.z += dst.z / 2;\n\t\telse max.z -= dst.z / 2;\n\n\t\treturn new EptKey(\n\t\t\t\tthis.ept,\n\t\t\t\tnew THREE.Box3(min, max),\n\t\t\t\tthis.d + 1,\n\t\t\t\tthis.x * 2 + a,\n\t\t\t\tthis.y * 2 + b,\n\t\t\t\tthis.z * 2 + c);\n\t}\n\n\tchildren()\n\t{\n\t\tvar result = [];\n\t\tfor (var a = 0; a < 2; ++a)\n\t\t{\n\t\t\tfor (var b = 0; b < 2; ++b)\n\t\t\t{\n\t\t\t\tfor (var c = 0; c < 2; ++c)\n\t\t\t\t{\n\t\t\t\t\tvar add = this.step(a, b, c).name();\n\t\t\t\t\tif(!result.includes(add)) result = result.concat(add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nclass PointCloudEptGeometryNode extends PointCloudTreeNode\n{\n\tconstructor(ept, b, d, x, y, z) {\n\t\tsuper();\n\n\t\tthis.ept = ept;\n\t\tthis.key = new EptKey(\n\t\t\t\tthis.ept,\n\t\t\t\tb || this.ept.boundingBox,\n\t\t\t\td || 0,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz);\n\n\t\tthis.id = PointCloudEptGeometryNode.IDCount++;\n\t\tthis.geometry = null;\n\t\tthis.boundingBox = this.key.b;\n\t\tthis.tightBoundingBox = this.boundingBox;\n\t\tthis.spacing = this.ept.spacing / Math.pow(2, this.key.d);\n\t\tthis.boundingSphere = Utils.sphereFrom(this.boundingBox);\n\n\t\t// These are set during hierarchy loading.\n\t\tthis.hasChildren = false;\n\t\tthis.children = { };\n\t\tthis.numPoints = -1;\n\n\t\tthis.level = this.key.d;\n\t\tthis.loaded = false;\n\t\tthis.loading = false;\n\t\tthis.oneTimeDisposeHandlers = [];\n\n\t\tlet k = this.key;\n\t\tthis.name = this.toPotreeName(k.d, k.x, k.y, k.z);\n\t\tthis.index = parseInt(this.name.charAt(this.name.length - 1));\n\t}\n\n\tisGeometryNode(){return true;}\n\tgetLevel(){return this.level;}\n\tisTreeNode(){return false;}\n\tisLoaded(){return this.loaded;}\n\tgetBoundingSphere(){return this.boundingSphere;}\n\tgetBoundingBox(){return this.boundingBox;}\n\turl(){return this.ept.url + \"ept-data/\" + this.filename();}\n\tgetNumPoints(){return this.numPoints;}\n\tfilename(){return this.key.name();}\n\n\tgetChildren()\n\t{\n\t\tlet children = [];\n\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tif(this.children[i]) {\n\t\t\t\tchildren.push(this.children[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn children;\n\t}\n\n\taddChild(child)\n\t{\n\t\tthis.children[child.index] = child;\n\t\tchild.parent = this;\n\t}\n\n\tload()\n\t{\n\t\tif(this.loaded || this.loading || Global.numNodesLoading >= Global.maxNodesLoading)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.loading = true;\n\t\tGlobal.numNodesLoading++;\n\n\t\tif(this.numPoints === -1)\n\t\t{\n\t\t\tthis.loadHierarchy();\n\t\t}\n\t\tthis.loadPoints();\n\t}\n\n\tloadPoints()\n\t{\n\t\tthis.ept.loader.load(this);\n\t}\n\n\tasync loadHierarchy()\n\t{\n\t\tlet nodes = { };\n\t\tnodes[this.filename()] = this;\n\t\tthis.hasChildren = false;\n\n\t\tlet eptHierarchyFile = `${this.ept.url}ept-hierarchy/${this.filename()}.json`;\n\n\t\tlet response = await fetch(eptHierarchyFile);\n\t\tlet hier = await response.json();\n\n\t\t// Since we want to traverse top-down, and 10 comes\n\t\t// lexicographically before 9 (for example), do a deep sort.\n\t\tvar keys = Object.keys(hier).sort((a, b) => {\n\t\t\tlet [da, xa, ya, za] = a.split(\"-\").map((n) => parseInt(n, 10));\n\t\t\tlet [db, xb, yb, zb] = b.split(\"-\").map((n) => parseInt(n, 10));\n\t\t\tif(da < db) return -1; if(da > db) return 1;\n\t\t\tif(xa < xb) return -1; if(xa > xb) return 1;\n\t\t\tif(ya < yb) return -1; if(ya > yb) return 1;\n\t\t\tif(za < zb) return -1; if(za > zb) return 1;\n\t\t\treturn 0;\n\t\t});\n\n\t\tkeys.forEach((v) => {\n\t\t\tlet [d, x, y, z] = v.split(\"-\").map((n) => parseInt(n, 10));\n\t\t\tlet a = x & 1, b = y & 1, c = z & 1;\n\t\t\tlet parentName =\n\t\t\t\t(d - 1) + \"-\" + (x >> 1) + \"-\" + (y >> 1) + \"-\" + (z >> 1);\n\n\t\t\tlet parentNode = nodes[parentName];\n\t\t\tif(!parentNode) return;\n\t\t\tparentNode.hasChildren = true;\n\n\t\t\tlet key = parentNode.key.step(a, b, c);\n\n\t\t\tlet node = new PointCloudEptGeometryNode(\n\t\t\t\t\tthis.ept,\n\t\t\t\t\tkey.b,\n\t\t\t\t\tkey.d,\n\t\t\t\t\tkey.x,\n\t\t\t\t\tkey.y,\n\t\t\t\t\tkey.z);\n\n\t\t\tnode.level = d;\n\t\t\tnode.numPoints = hier[v];\n\n\t\t\tparentNode.addChild(node);\n\t\t\tnodes[key.name()] = node;\n\t\t});\n\t}\n\n\tdoneLoading(bufferGeometry, tightBoundingBox, np, mean)\n\t{\n\t\tbufferGeometry.boundingBox = this.boundingBox;\n\t\tthis.geometry = bufferGeometry;\n\t\tthis.tightBoundingBox = tightBoundingBox;\n\t\tthis.numPoints = np;\n\t\tthis.mean = mean;\n\t\tthis.loaded = true;\n\t\tthis.loading = false;\n\t\tGlobal.numNodesLoading--;\n\t}\n\n\ttoPotreeName(d, x, y, z)\n\t{\n\t\tvar name = \"r\";\n\n\t\tfor (var i = 0; i < d; ++i)\n\t\t{\n\t\t\tvar shift = d - i - 1;\n\t\t\tvar mask = 1 << shift;\n\t\t\tvar step = 0;\n\n\t\t\tif(x & mask) step += 4;\n\t\t\tif(y & mask) step += 2;\n\t\t\tif(z & mask) step += 1;\n\n\t\t\tname += step;\n\t\t}\n\n\t\treturn name;\n\t}\n\n\tdispose()\n\t{\n\t\tif(this.geometry && this.parent != null)\n\t\t{\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.geometry = null;\n\t\t\tthis.loaded = false;\n\n\t\t\t// this.dispatchEvent( { type: \"dispose\" } );\n\t\t\tfor (let i = 0; i < this.oneTimeDisposeHandlers.length; i++)\n\t\t\t{\n\t\t\t\tlet handler = this.oneTimeDisposeHandlers[i];\n\t\t\t\thandler();\n\t\t\t}\n\t\t\t\n\t\t\tthis.oneTimeDisposeHandlers = [];\n\t\t}\n\t}\n}\n\nPointCloudEptGeometryNode.IDCount = 0;\n\n/**\n * @author Connor Manning\n */\nclass EptLoader\n{\n\tstatic async load(file, callback)\n\t{\n\t\tvar response = await fetch(file);\n\t\tvar json = await response.json();\n\t\tvar url = file.substr(0, file.lastIndexOf(\"ept.json\"));\n\n\t\tvar geometry = new PointCloudEptGeometry(url, json);\n\t\tvar root = new PointCloudEptGeometryNode(geometry);\n\t\tgeometry.root = root;\n\t\tgeometry.root.load();\n\n\t\tcallback(geometry);\n\t}\n}\n\nclass HelperUtils\n{\n\t/**\n\t * Craete a new data texture with a solid color.\n\t */\n\tstatic generateDataTexture(width, height, color)\n\t{\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array(4 * width * height);\n\n\t\tvar r = Math.floor(color.r * 255);\n\t\tvar g = Math.floor(color.g * 255);\n\t\tvar b = Math.floor(color.b * 255);\n\n\t\tfor(var i = 0; i < size; i++)\n\t\t{\n\t\t\tdata[i * 3] = r;\n\t\t\tdata[i * 3 + 1] = g;\n\t\t\tdata[i * 3 + 2] = b;\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n\t\ttexture.needsUpdate = true;\n\t\ttexture.magFilter = THREE.NearestFilter;\n\n\t\treturn texture;\n\t};\n\n\t/**\n\t * Compute a transformed bouding box from an original box and a transform matrix.\n\t */\n\tstatic computeTransformedBoundingBox(box, transform)\n\t{\n\t\tvar vertices = [\n\t\t\tnew THREE.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\n\t\t\tnew THREE.Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform)\n\t\t];\n\n\t\tvar boundingBox = new THREE.Box3();\n\t\tboundingBox.setFromPoints(vertices);\n\t\t\n\t\treturn boundingBox;\n\t};\n}\n\nvar Gradients = {\n\tRAINBOW: [\n\t\t[0, new THREE.Color(0.278, 0, 0.714)],\n\t\t[1 / 6, new THREE.Color(0, 0, 1)],\n\t\t[2 / 6, new THREE.Color(0, 1, 1)],\n\t\t[3 / 6, new THREE.Color(0, 1, 0)],\n\t\t[4 / 6, new THREE.Color(1, 1, 0)],\n\t\t[5 / 6, new THREE.Color(1, 0.64, 0)],\n\t\t[1, new THREE.Color(1, 0, 0)]\n\t],\n\t//From chroma spectral http://gka.github.io/chroma.js/\n\tSPECTRAL: [\n\t\t[0, new THREE.Color(0.3686, 0.3098, 0.6353)],\n\t\t[0.1, new THREE.Color(0.1961, 0.5333, 0.7412)],\n\t\t[0.2, new THREE.Color(0.4000, 0.7608, 0.6471)],\n\t\t[0.3, new THREE.Color(0.6706, 0.8667, 0.6431)],\n\t\t[0.4, new THREE.Color(0.9020, 0.9608, 0.5961)],\n\t\t[0.5, new THREE.Color(1.0000, 1.0000, 0.7490)],\n\t\t[0.6, new THREE.Color(0.9961, 0.8784, 0.5451)],\n\t\t[0.7, new THREE.Color(0.9922, 0.6824, 0.3804)],\n\t\t[0.8, new THREE.Color(0.9569, 0.4275, 0.2627)],\n\t\t[0.9, new THREE.Color(0.8353, 0.2431, 0.3098)],\n\t\t[1, new THREE.Color(0.6196, 0.0039, 0.2588)]\n\t],\n\tPLASMA: [\n\t\t[0.0, new THREE.Color(0.241, 0.015, 0.610)],\n\t\t[0.1, new THREE.Color(0.387, 0.001, 0.654)],\n\t\t[0.2, new THREE.Color(0.524, 0.025, 0.653)],\n\t\t[0.3, new THREE.Color(0.651, 0.125, 0.596)],\n\t\t[0.4, new THREE.Color(0.752, 0.227, 0.513)],\n\t\t[0.5, new THREE.Color(0.837, 0.329, 0.431)],\n\t\t[0.6, new THREE.Color(0.907, 0.435, 0.353)],\n\t\t[0.7, new THREE.Color(0.963, 0.554, 0.272)],\n\t\t[0.8, new THREE.Color(0.992, 0.681, 0.195)],\n\t\t[0.9, new THREE.Color(0.987, 0.822, 0.144)],\n\t\t[1.0, new THREE.Color(0.940, 0.975, 0.131)]\n\t],\n\tYELLOW_GREEN: [\n\t\t[0, new THREE.Color(0.1647, 0.2824, 0.3451)],\n\t\t[0.1, new THREE.Color(0.1338, 0.3555, 0.4227)],\n\t\t[0.2, new THREE.Color(0.0610, 0.4319, 0.4864)],\n\t\t[0.3, new THREE.Color(0.0000, 0.5099, 0.5319)],\n\t\t[0.4, new THREE.Color(0.0000, 0.5881, 0.5569)],\n\t\t[0.5, new THREE.Color(0.1370, 0.6650, 0.5614)],\n\t\t[0.6, new THREE.Color(0.2906, 0.7395, 0.5477)],\n\t\t[0.7, new THREE.Color(0.4453, 0.8099, 0.5201)],\n\t\t[0.8, new THREE.Color(0.6102, 0.8748, 0.4850)],\n\t\t[0.9, new THREE.Color(0.7883, 0.9323, 0.4514)],\n\t\t[1, new THREE.Color(0.9804, 0.9804, 0.4314)]\n\t],\n\tVIRIDIS: [\n\t\t[0.0, new THREE.Color(0.267, 0.005, 0.329)],\n\t\t[0.1, new THREE.Color(0.283, 0.141, 0.458)],\n\t\t[0.2, new THREE.Color(0.254, 0.265, 0.530)],\n\t\t[0.3, new THREE.Color(0.207, 0.372, 0.553)],\n\t\t[0.4, new THREE.Color(0.164, 0.471, 0.558)],\n\t\t[0.5, new THREE.Color(0.128, 0.567, 0.551)],\n\t\t[0.6, new THREE.Color(0.135, 0.659, 0.518)],\n\t\t[0.7, new THREE.Color(0.267, 0.749, 0.441)],\n\t\t[0.8, new THREE.Color(0.478, 0.821, 0.318)],\n\t\t[0.9, new THREE.Color(0.741, 0.873, 0.150)],\n\t\t[1.0, new THREE.Color(0.993, 0.906, 0.144)]\n\t],\n\tINFERNO: [\n\t\t[0.0, new THREE.Color(0.077, 0.042, 0.206)],\n\t\t[0.1, new THREE.Color(0.225, 0.036, 0.388)],\n\t\t[0.2, new THREE.Color(0.373, 0.074, 0.432)],\n\t\t[0.3, new THREE.Color(0.522, 0.128, 0.420)],\n\t\t[0.4, new THREE.Color(0.665, 0.182, 0.370)],\n\t\t[0.5, new THREE.Color(0.797, 0.255, 0.287)],\n\t\t[0.6, new THREE.Color(0.902, 0.364, 0.184)],\n\t\t[0.7, new THREE.Color(0.969, 0.516, 0.063)],\n\t\t[0.8, new THREE.Color(0.988, 0.683, 0.072)],\n\t\t[0.9, new THREE.Color(0.961, 0.859, 0.298)],\n\t\t[1.0, new THREE.Color(0.988, 0.998, 0.645)]\n\t],\n\tGRAYSCALE: [\n\t\t[0, new THREE.Color(0, 0, 0)],\n\t\t[1, new THREE.Color(1, 1, 1)]\n\t]\n};\n\nvar Shaders = {};\n\n//pointcloud.vs\nShaders.vertex = `\nprecision highp float;\nprecision highp int;\n\n#define MAX_CLIP_POLYGONS 8\n\n` + THREE.ShaderChunk.common + `\n` + THREE.ShaderChunk.logdepthbuf_pars_vertex + `\n\nattribute vec3 position;\nattribute vec3 color;\nattribute float intensity;\nattribute float classification;\nattribute float returnNumber;\nattribute float numberOfReturns;\nattribute float pointSourceID;\nattribute vec4 indices;\nattribute float spacing;\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 uViewInv;\n\nuniform float uScreenWidth;\nuniform float uScreenHeight;\nuniform float fov;\nuniform float near;\nuniform float far;\n\nuniform bool uDebug;\n\nuniform bool uUseOrthographicCamera;\nuniform float uOrthoWidth;\nuniform float uOrthoHeight;\n\n#define CLIPTASK_NONE 0\n#define CLIPTASK_HIGHLIGHT 1\n#define CLIPTASK_SHOW_INSIDE 2\n#define CLIPTASK_SHOW_OUTSIDE 3\n\n#define CLIPMETHOD_INSIDE_ANY 0\n#define CLIPMETHOD_INSIDE_ALL 1\n\nuniform int clipTask;\nuniform int clipMethod;\n\n#if defined(num_clipboxes) && num_clipboxes > 0\n\tuniform mat4 clipBoxes[num_clipboxes];\n#endif\n\n#if defined(num_clipspheres) && num_clipspheres > 0\n\tuniform mat4 uClipSpheres[num_clipspheres];\n#endif\n\n#if defined(num_clippolygons) && num_clippolygons > 0\n\tuniform int uClipPolygonVCount[num_clippolygons];\n\tuniform vec3 uClipPolygonVertices[num_clippolygons * 8];\n\tuniform mat4 uClipPolygonWVP[num_clippolygons];\n#endif\n\nuniform float size;\nuniform float minSize;\nuniform float maxSize;\n\nuniform float uPCIndex;\nuniform float uOctreeSpacing;\nuniform float uNodeSpacing;\nuniform float uOctreeSize;\nuniform vec3 uBBSize;\nuniform float uLevel;\nuniform float uVNStart;\nuniform bool uIsLeafNode;\n\nuniform vec3 uColor;\nuniform float uOpacity;\n\nuniform vec2 elevationRange;\nuniform vec2 intensityRange;\nuniform float intensityGamma;\nuniform float intensityContrast;\nuniform float intensityBrightness;\nuniform float rgbGamma;\nuniform float rgbContrast;\nuniform float rgbBrightness;\nuniform float uTransition;\nuniform float wRGB;\nuniform float wIntensity;\nuniform float wElevation;\nuniform float wClassification;\nuniform float wReturnNumber;\nuniform float wSourceID;\n\nuniform vec3 uShadowColor;\n\nuniform sampler2D visibleNodes;\nuniform sampler2D gradient;\nuniform sampler2D classificationLUT;\n\n#if defined(num_shadowmaps) && num_shadowmaps > 0\n\tuniform sampler2D uShadowMap[num_shadowmaps];\n\tuniform mat4 uShadowWorldView[num_shadowmaps];\n\tuniform mat4 uShadowProj[num_shadowmaps];\n#endif\n\nvarying vec3 vColor;\nvarying float vLogDepth;\nvarying vec3 vViewPosition;\nvarying float vRadius;\nvarying float vPointSize;\n\nfloat round(float number)\n{\n\treturn floor(number + 0.5);\n}\n\n//---------------------\n//OCTREE\n//---------------------\n\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\n\n\t/**\n\t * number of 1-bits up to inclusive index position\n\t * number is treated as if it were an integer in the range 0-255\n\t */\n\tint numberOfOnes(int number, int index)\n\t{\n\t\tint numOnes = 0;\n\t\tint tmp = 128;\n\n\t\tfor(int i = 7; i >= 0; i--)\n\t\t{\n\t\t\tif(number >= tmp)\n\t\t\t{\n\t\t\t\tnumber = number - tmp;\n\n\t\t\t\tif(i <= index)\n\t\t\t\t{\n\t\t\t\t\tnumOnes++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttmp = tmp / 2;\n\t\t}\n\n\t\treturn numOnes;\n\t}\n\n\t/**\n\t * checks whether the bit at index is 1\n\t * number is treated as if it were an integer in the range 0-255\n\t */\n\tbool isBitSet(int number, int index)\n\t{\n\t\t//weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\n\t\tint powi = 1;\n\n\t\tif(index == 0)\n\t\t{\n\t\t\tpowi = 1;\n\t\t}\n\t\telse if(index == 1)\n\t\t{\n\t\t\tpowi = 2;\n\t\t}\n\t\telse if(index == 2)\n\t\t{\n\t\t\tpowi = 4;\n\t\t}\n\t\telse if(index == 3)\n\t\t{\n\t\t\tpowi = 8;\n\t\t}\n\t\telse if(index == 4)\n\t\t{\n\t\t\tpowi = 16;\n\t\t}\n\t\telse if(index == 5)\n\t\t{\n\t\t\tpowi = 32;\n\t\t}\n\t\telse if(index == 6)\n\t\t{\n\t\t\tpowi = 64;\n\t\t}\n\t\telse if(index == 7)\n\t\t{\n\t\t\tpowi = 128;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tint ndp = number / powi;\n\n\t\treturn mod(float(ndp), 2.0) != 0.0;\n\t}\n\n\t/**\n\t * find the LOD at the point position\n\t */\n\tfloat getLOD()\n\t{\n\t\tvec3 offset = vec3(0.0, 0.0, 0.0);\n\t\tint iOffset = int(uVNStart);\n\t\tfloat depth = uLevel;\n\n\t\tfor(float i = 0.0; i <= 30.0; i++)\n\t\t{\n\t\t\tfloat nodeSizeAtLevel = uOctreeSize / pow(2.0, i + uLevel + 0.0);\n\t\t\t\n\t\t\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\n\t\t\tindex3d = floor(index3d + 0.5);\n\t\t\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\n\t\t\t\n\t\t\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\n\t\t\tint mask = int(round(value.r * 255.0));\n\n\t\t\tif(isBitSet(mask, index))\n\t\t\t{\n\t\t\t\t//there are more visible child nodes at this position\n\t\t\t\tint advanceG = int(round(value.g * 255.0)) * 256;\n\t\t\t\tint advanceB = int(round(value.b * 255.0));\n\t\t\t\tint advanceChild = numberOfOnes(mask, index - 1);\n\t\t\t\tint advance = advanceG + advanceB + advanceChild;\n\n\t\t\t\tiOffset = iOffset + advance;\n\t\t\t\t\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//no more visible child nodes at this position\n\t\t\t\treturn value.a * 255.0;\n\t\t\t\t//return depth;\n\t\t\t}\n\t\t\t\n\t\t\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\n\t\t}\n\t\t\t\n\t\treturn depth;\n\t}\n\n\tfloat getSpacing()\n\t{\n\t\tvec3 offset = vec3(0.0, 0.0, 0.0);\n\t\tint iOffset = int(uVNStart);\n\t\tfloat depth = uLevel;\n\t\tfloat spacing = uNodeSpacing;\n\n\t\tfor(float i = 0.0; i <= 30.0; i++)\n\t\t{\n\t\t\tfloat nodeSizeAtLevel = uOctreeSize / pow(2.0, i + uLevel + 0.0);\n\t\t\t\n\t\t\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\n\t\t\tindex3d = floor(index3d + 0.5);\n\t\t\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\n\t\t\t\n\t\t\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\n\t\t\tint mask = int(round(value.r * 255.0));\n\t\t\tfloat spacingFactor = value.a;\n\n\t\t\tif(i > 0.0)\n\t\t\t{\n\t\t\t\tspacing = spacing / (255.0 * spacingFactor);\n\t\t\t}\n\t\t\t\n\t\t\tif(isBitSet(mask, index))\n\t\t\t{\n\t\t\t\t//there are more visible child nodes at this position\n\t\t\t\tint advanceG = int(round(value.g * 255.0)) * 256;\n\t\t\t\tint advanceB = int(round(value.b * 255.0));\n\t\t\t\tint advanceChild = numberOfOnes(mask, index - 1);\n\t\t\t\tint advance = advanceG + advanceB + advanceChild;\n\n\t\t\t\tiOffset = iOffset + advance;\n\n\t\t\t\tdepth++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//no more visible child nodes at this position\n\t\t\t\treturn spacing;\n\t\t\t}\n\t\t\t\n\t\t\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\n\t\t}\n\t\t\t\n\t\treturn spacing;\n\t}\n\n\tfloat getPointSizeAttenuation()\n\t{\n\t\treturn pow(2.0, getLOD());\n\t}\n#endif\n\n//---------------------\n//KD-TREE\n//---------------------\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\n\tfloat getLOD()\n\t{\n\t\tvec3 offset = vec3(0.0, 0.0, 0.0);\n\t\tfloat iOffset = 0.0;\n\t\tfloat depth = 0.0;\n\t\t\t\n\t\tvec3 size = uBBSize;\t\n\t\tvec3 pos = position;\n\t\t\t\n\t\tfor(float i = 0.0; i <= 1000.0; i++)\n\t\t{\n\t\t\tvec4 value = texture2D(visibleNodes, vec2(iOffset / 2048.0, 0.0));\n\t\t\t\n\t\t\tint children = int(value.r * 255.0);\n\t\t\tfloat next = value.g * 255.0;\n\t\t\tint split = int(value.b * 255.0);\n\t\t\t\n\t\t\tif(next == 0.0)\n\t\t\t{\n\t\t\t \treturn depth;\n\t\t\t}\n\t\t\t\n\t\t\tvec3 splitv = vec3(0.0, 0.0, 0.0);\n\t\t\tif(split == 1)\n\t\t\t{\n\t\t\t\tsplitv.x = 1.0;\n\t\t\t}\n\t\t\telse if(split == 2)\n\t\t\t{\n\t\t\t \tsplitv.y = 1.0;\n\t\t\t}\n\t\t\telse if(split == 4)\n\t\t\t{\n\t\t\t \tsplitv.z = 1.0;\n\t\t\t}\n\t\t\t\n\t\t\tiOffset = iOffset + next;\n\t\t\t\n\t\t\tfloat factor = length(pos * splitv / size);\n\n\t\t\t//Left\n\t\t\tif(factor < 0.5)\n\t\t\t{\n\t\t\t\tif(children == 0 || children == 2)\n\t\t\t\t{\n\t\t\t\t\treturn depth;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Right\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = pos - size * splitv * 0.5;\n\t\t\t\tif(children == 0 || children == 1)\n\t\t\t\t{\n\t\t\t\t\treturn depth;\n\t\t\t\t}\n\t\t\t\tif(children == 3)\n\t\t\t\t{\n\t\t\t\t\tiOffset = iOffset + 1.0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\n\t\t\tdepth++;\n\t\t}\n\t\t\t\n\t\treturn depth;\t\n\t}\n\n\tfloat getPointSizeAttenuation()\n\t{\n\t\treturn 0.5 * pow(1.3, getLOD());\n\t}\n#endif\n\n//formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\nfloat getContrastFactor(float contrast)\n{\n\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\n}\n\nvec3 getRGB()\n{\n\tvec3 rgb = color;\n\t\n\trgb = pow(rgb, vec3(rgbGamma));\n\trgb = rgb + rgbBrightness;\n\trgb = clamp(rgb, 0.0, 1.0);\n\t\n\treturn rgb;\n}\n\nfloat getIntensity()\n{\n\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\n\tw = pow(w, intensityGamma);\n\tw = w + intensityBrightness;\n\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\n\tw = clamp(w, 0.0, 1.0);\n\n\treturn w;\n}\n\nvec3 getElevation()\n{\n\tvec4 world = modelMatrix * vec4( position, 1.0 );\n\tfloat w = (world.z - elevationRange.x) / (elevationRange.y - elevationRange.x);\n\treturn texture2D(gradient, vec2(w,1.0-w)).rgb;\n}\n\nvec4 getClassification()\n{\n\tvec2 uv = vec2(classification / 255.0, 0.5);\n\treturn texture2D(classificationLUT, uv);\n}\n\nvec3 getReturnNumber()\n{\n\tif(numberOfReturns == 1.0)\n\t{\n\t\treturn vec3(1.0, 1.0, 0.0);\n\t}\n\telse\n\t{\n\t\tif(returnNumber == 1.0)\n\t\t{\n\t\t\treturn vec3(1.0, 0.0, 0.0);\n\t\t}\n\t\telse if(returnNumber == numberOfReturns)\n\t\t{\n\t\t\treturn vec3(0.0, 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn vec3(0.0, 1.0, 0.0);\n\t\t}\n\t}\n}\n\nvec3 getSourceID()\n{\n\tfloat w = mod(pointSourceID, 10.0) / 10.0;\n\treturn texture2D(gradient, vec2(w,1.0 - w)).rgb;\n}\n\nvec3 getCompositeColor()\n{\n\tvec3 c;\n\tfloat w;\n\n\tc += wRGB * getRGB();\n\tw += wRGB;\n\t\n\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\n\tw += wIntensity;\n\t\n\tc += wElevation * getElevation();\n\tw += wElevation;\n\t\n\tc += wReturnNumber * getReturnNumber();\n\tw += wReturnNumber;\n\t\n\tc += wSourceID * getSourceID();\n\tw += wSourceID;\n\t\n\tvec4 cl = wClassification * getClassification();\n    c += cl.a * cl.rgb;\n\tw += wClassification * cl.a;\n\n\tc = c / w;\n\t\n\tif(w == 0.0)\n\t{\n\t\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\n\t}\n\t\n\treturn c;\n}\n\nvec3 getColor()\n{\n\tvec3 color;\n\t\n\t#ifdef color_type_rgb\n\t\tcolor = getRGB();\n\t#elif defined color_type_height\n\t\tcolor = getElevation();\n\t#elif defined color_type_rgb_height\n\t\tvec3 cHeight = getElevation();\n\t\tcolor = (1.0 - uTransition) * getRGB() + uTransition * cHeight;\n\t#elif defined color_type_depth\n\t\tfloat linearDepth = gl_Position.w;\n\t\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\n\t\tcolor = vec3(linearDepth, expDepth, 0.0);\n\t#elif defined color_type_intensity\n\t\tfloat w = getIntensity();\n\t\tcolor = vec3(w, w, w);\n\t#elif defined color_type_intensity_gradient\n\t\tfloat w = getIntensity();\n\t\tcolor = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\t#elif defined color_type_color\n\t\tcolor = uColor;\n\t#elif defined color_type_lod\n\t\tfloat depth = getLOD();\n\t\tfloat w = depth / 10.0;\n\t\tcolor = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\t#elif defined color_type_point_index\n\t\tcolor = indices.rgb;\n\t#elif defined color_type_classification\n\t\tvec4 cl = getClassification(); \n\t\tcolor = cl.rgb;\n\t#elif defined color_type_return_number\n\t\tcolor = getReturnNumber();\n\t#elif defined color_type_source\n\t\tcolor = getSourceID();\n\t#elif defined color_type_normal\n\t\tcolor = (modelMatrix * vec4(normal, 0.0)).xyz;\n\t#elif defined color_type_phong\n\t\tcolor = color;\n\t#elif defined color_type_composite\n\t\tcolor = getCompositeColor();\n\t#endif\n\t\n\treturn color;\n}\n\nfloat getPointSize()\n{\n\tfloat pointSize = 1.0;\n\t\n\tfloat slope = tan(fov / 2.0);\n\tfloat projFactor = -0.5 * uScreenHeight / (slope * vViewPosition.z);\n\t\n\tfloat r = uOctreeSpacing * 1.7;\n\tvRadius = r;\n\n\t#if defined fixed_point_size\n\t\tpointSize = size;\n\t#elif defined attenuated_point_size\n\t\tif(uUseOrthographicCamera)\n\t\t{\n\t\t\tpointSize = size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpointSize = size * spacing * projFactor;\n\t\t}\n\t#elif defined adaptive_point_size\n\t\tif(uUseOrthographicCamera)\n\t\t{\n\t\t\tfloat worldSpaceSize = 1.0 * size * r / getPointSizeAttenuation();\n\t\t\tpointSize = (worldSpaceSize / uOrthoWidth) * uScreenWidth;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(uIsLeafNode && false)\n\t\t\t{\n\t\t\t\tpointSize = size * spacing * projFactor;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat worldSpaceSize = 1.0 * size * r / getPointSizeAttenuation();\n\t\t\t\tpointSize = worldSpaceSize * projFactor;\n\t\t\t}\n\t\t}\n\t#endif\n\n\tpointSize = max(minSize, pointSize);\n\tpointSize = min(maxSize, pointSize);\n\t\n\tvRadius = pointSize / projFactor;\n\n\treturn pointSize;\n}\n\n#if defined num_clippolygons && num_clippolygons > 0\n\tbool pointInClipPolygon(vec3 point, int polyIdx)\n\t{\n\t\tmat4 wvp = uClipPolygonWVP[polyIdx];\n\n\t\tvec4 pointNDC = wvp * vec4(point, 1.0);\n\t\tpointNDC.xy = pointNDC.xy / pointNDC.w;\n\n\t\tint j = uClipPolygonVCount[polyIdx] - 1;\n\t\tbool c = false;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t{\n\t\t\tif(i == uClipPolygonVCount[polyIdx])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec3 verti = uClipPolygonVertices[polyIdx * 8 + i];\n\t\t\tvec3 vertj = uClipPolygonVertices[polyIdx * 8 + j];\n\n\t\t\tif(((verti.y > pointNDC.y) != (vertj.y > pointNDC.y)) && (pointNDC.x < (vertj.x-verti.x) * (pointNDC.y-verti.y) / (vertj.y-verti.y) + verti.x))\n\t\t\t{\n\t\t\t\tc = !c;\n\t\t\t}\n\n\t\t\tj = i;\n\t\t}\n\n\t\treturn c;\n\t}\n#endif\n\nvoid doClipping()\n{\n\t#if !defined color_type_composite\n\t\tvec4 cl = getClassification(); \n\t\tif(cl.a == 0.0)\n\t\t{\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t#endif\n\n\tint clipVolumesCount = 0;\n\tint insideCount = 0;\n\n\t#if defined(num_clipboxes) && num_clipboxes > 0\n\t\tfor(int i = 0; i < num_clipboxes; i++)\n\t\t{\n\t\t\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4( position, 1.0 );\n\t\t\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\n\t\t\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\n\t\t\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\n\n\t\t\tinsideCount = insideCount + (inside ? 1 : 0);\n\t\t\tclipVolumesCount++;\n\t\t}\t\n\t#endif\n\n\t#if defined(num_clippolygons) && num_clippolygons > 0\n\t\tfor(int i = 0; i < num_clippolygons; i++)\n\t\t{\n\t\t\tbool inside = pointInClipPolygon(position, i);\n\n\t\t\tinsideCount = insideCount + (inside ? 1 : 0);\n\t\t\tclipVolumesCount++;\n\t\t}\n\t#endif\n\n\tbool insideAny = insideCount > 0;\n\tbool insideAll = (clipVolumesCount > 0) && (clipVolumesCount == insideCount);\n\n\tif(clipMethod == CLIPMETHOD_INSIDE_ANY)\n\t{\n\t\tif(insideAny && clipTask == CLIPTASK_HIGHLIGHT)\n\t\t{\n\t\t\tvColor.r += 0.5;\n\t\t}\n\t\telse if(!insideAny && clipTask == CLIPTASK_SHOW_INSIDE)\n\t\t{\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 1.0);\n\t\t}\n\t\telse if(insideAny && clipTask == CLIPTASK_SHOW_OUTSIDE)\n\t\t{\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 1.0);\n\t\t}\n\t}\n\telse if(clipMethod == CLIPMETHOD_INSIDE_ALL)\n\t{\n\t\tif(insideAll && clipTask == CLIPTASK_HIGHLIGHT)\n\t\t{\n\t\t\tvColor.r += 0.5;\n\t\t}\n\t\telse if(!insideAll && clipTask == CLIPTASK_SHOW_INSIDE)\n\t\t{\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 1.0);\n\t\t}\n\t\telse if(insideAll && clipTask == CLIPTASK_SHOW_OUTSIDE)\n\t\t{\n\t\t\tgl_Position = vec4(100.0, 100.0, 100.0, 1.0);\n\t\t}\n\t}\n}\n\nvoid main()\n{\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n\tvViewPosition = mvPosition.xyz;\n\tgl_Position = projectionMatrix * mvPosition;\n\n\tvLogDepth = log2(-mvPosition.z);\n\n\t//POINT SIZE\n\tfloat pointSize = getPointSize();\n\tgl_PointSize = pointSize;\n\tvPointSize = pointSize;\n\n\t` + THREE.ShaderChunk.logdepthbuf_vertex + `\n\n\t//COLOR\n\tvColor = getColor();\n\n\t#if defined hq_depth_pass\n\t\tfloat originalDepth = gl_Position.w;\n\t\tfloat adjustedDepth = originalDepth + 2.0 * vRadius;\n\t\tfloat adjust = adjustedDepth / originalDepth;\n\n\t\tmvPosition.xyz = mvPosition.xyz * adjust;\n\t\tgl_Position = projectionMatrix * mvPosition;\n\t#endif\n\n\t//CLIPPING\n\tdoClipping();\n\n\t#if defined num_clipspheres && num_clipspheres > 0\n\t\tfor(int i = 0; i < num_clipspheres; i++)\n\t\t{\n\t\t\tvec4 sphereLocal = uClipSpheres[i] * mvPosition;\n\n\t\t\tfloat distance = length(sphereLocal.xyz);\n\n\t\t\tif(distance < 1.0)\n\t\t\t{\n\t\t\t\tfloat w = distance;\n\t\t\t\tvec3 cGradient = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\n\t\t\t\t\n\t\t\t\tvColor = cGradient;\n\t\t\t}\n\t\t}\n\t#endif\n\n\t#if defined num_shadowmaps && num_shadowmaps > 0\n\n\t\tconst float sm_near = 0.1;\n\t\tconst float sm_far = 10000.0;\n\n\t\tfor(int i = 0; i < num_shadowmaps; i++)\n\t\t{\n\t\t\tvec3 viewPos = (uShadowWorldView[i] * vec4(position, 1.0)).xyz;\n\t\t\tfloat distanceToLight = abs(viewPos.z);\n\t\t\t\n\t\t\tvec4 projPos = uShadowProj[i] * uShadowWorldView[i] * vec4(position, 1);\n\t\t\tvec3 nc = projPos.xyz / projPos.w;\n\t\t\t\n\t\t\tfloat u = nc.x * 0.5 + 0.5;\n\t\t\tfloat v = nc.y * 0.5 + 0.5;\n\n\t\t\tvec2 sampleStep = vec2(1.0 / (2.0*1024.0), 1.0 / (2.0*1024.0)) * 1.5;\n\t\t\tvec2 sampleLocations[9];\n\n\t\t\tsampleLocations[0] = vec2(0.0, 0.0);\n\t\t\tsampleLocations[1] = sampleStep;\n\t\t\tsampleLocations[2] = -sampleStep;\n\t\t\tsampleLocations[3] = vec2(sampleStep.x, -sampleStep.y);\n\t\t\tsampleLocations[4] = vec2(-sampleStep.x, sampleStep.y);\n\t\t\tsampleLocations[5] = vec2(0.0, sampleStep.y);\n\t\t\tsampleLocations[6] = vec2(0.0, -sampleStep.y);\n\t\t\tsampleLocations[7] = vec2(sampleStep.x, 0.0);\n\t\t\tsampleLocations[8] = vec2(-sampleStep.x, 0.0);\n\n\t\t\tfloat visibleSamples = 0.0;\n\t\t\tfloat numSamples = 0.0;\n\n\t\t\tfloat bias = vRadius * 2.0;\n\n\t\t\tfor(int j = 0; j < 9; j++)\n\t\t\t{\n\t\t\t\tvec4 depthMapValue = texture2D(uShadowMap[i], vec2(u, v) + sampleLocations[j]);\n\n\t\t\t\tfloat linearDepthFromSM = depthMapValue.x + bias;\n\t\t\t\tfloat linearDepthFromViewer = distanceToLight;\n\n\t\t\t\tif(linearDepthFromSM > linearDepthFromViewer)\n\t\t\t\t{\n\t\t\t\t\tvisibleSamples += 1.0;\n\t\t\t\t}\n\n\t\t\t\tnumSamples += 1.0;\n\t\t\t}\n\n\t\t\tfloat visibility = visibleSamples / numSamples;\n\n\t\t\tif(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0 || nc.x < -1.0 || nc.x > 1.0 || nc.y < -1.0 || nc.y > 1.0 || nc.z < -1.0 || nc.z > 1.0)\n\t\t\t{\n\t\t\t\t//vColor = vec3(0.0, 0.0, 0.2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvColor = vColor * visibility + vColor * uShadowColor * (1.0 - visibility);\n\t\t\t}\n\t\t}\n\n\t#endif\n}`;\n\n//\"pointcloud.fs\"\nShaders.fragment = `\n\n#if defined USE_LOGDEPTHBUF_EXT || defined paraboloid_point_shape\n\t#extension GL_EXT_frag_depth : enable\n#endif\n\nprecision highp float;\nprecision highp int;\n\n` + THREE.ShaderChunk.common + `\n` + THREE.ShaderChunk.logdepthbuf_pars_fragment + `\n\nuniform mat4 viewMatrix;\nuniform mat4 uViewInv;\nuniform mat4 uProjInv;\nuniform vec3 cameraPosition;\n\nuniform mat4 projectionMatrix;\nuniform float uOpacity;\n\nuniform float blendHardness;\nuniform float blendDepthSupplement;\nuniform float fov;\nuniform float uSpacing;\nuniform float near;\nuniform float far;\nuniform float uPCIndex;\nuniform float uScreenWidth;\nuniform float uScreenHeight;\n\nvarying vec3 vColor;\nvarying float vLogDepth;\nvarying vec3 vViewPosition;\nvarying float vRadius;\nvarying float vPointSize;\nvarying vec3 vPosition;\n\nvoid main()\n{\n\tvec3 color = vColor;\n\tfloat depth = gl_FragCoord.z;\n\n\t#if defined circle_point_shape || defined paraboloid_point_shape\n\t\tfloat u = (2.0 * gl_PointCoord.x) - 1.0;\n\t\tfloat v = (2.0 * gl_PointCoord.y) - 1.0;\n\t#endif\n\t\n\t#if defined circle_point_shape\n\t\tfloat cc = (u*u) + (v*v);\n\t\tif(cc > 1.0)\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n\n\t#if defined color_type_point_index\n\t\tgl_FragColor = vec4(color, uPCIndex / 255.0);\n\t#else\n\t\tgl_FragColor = vec4(color, uOpacity);\n\t#endif\n\n\t#if defined paraboloid_point_shape\n\t\tfloat wi = -( u*u + v*v);\n\t\tvec4 pos = vec4(vViewPosition, 1.0);\n\t\tpos.z += wi * vRadius;\n\t\tfloat linearDepth = -pos.z;\n\t\tpos = projectionMatrix * pos;\n\t\tpos = pos / pos.w;\n\t\tfloat expDepth = pos.z;\n\t\tdepth = (pos.z + 1.0) / 2.0;\n\n\t\tgl_FragDepthEXT = depth;\n\t\t\n\t\t#if defined color_type_depth\n\t\t\tcolor.r = linearDepth;\n\t\t\tcolor.g = expDepth;\n\t\t#endif\n\t#endif\n\t\n\t` + THREE.ShaderChunk.logdepthbuf_fragment +  `\n\n\t#if defined weighted_splats\n\t\tfloat distance = 2.0 * length(gl_PointCoord.xy - 0.5);\n\t\tfloat weight = max(0.0, 1.0 - distance);\n\t\tweight = pow(weight, 1.5);\n\n\t\tgl_FragColor.a = weight;\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * weight;\n\t#endif\n}`;\n\nclass PointCloudMaterial extends THREE.RawShaderMaterial\n{\n\tconstructor(parameters = {})\n\t{\n\t\tsuper();\n\t\t\n\t\tthis.visibleNodesTexture = HelperUtils.generateDataTexture(2048, 1, new THREE.Color(0xffffff));\n\t\tthis.visibleNodesTexture.minFilter = THREE.NearestFilter;\n\t\tthis.visibleNodesTexture.magFilter = THREE.NearestFilter;\n\n\t\tvar getValid = function(a, b)\n\t\t{\n\t\t\tif(a !== undefined)\n\t\t\t{\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn b;\n\t\t\t}\n\t\t};\n\n\t\tvar pointSize = getValid(parameters.size, 1.0);\n\t\tvar minSize = getValid(parameters.minSize, 2.0);\n\t\tvar maxSize = getValid(parameters.maxSize, 50.0);\n\t\tvar treeType = getValid(parameters.treeType, TreeType.OCTREE);\n\n\t\tthis._pointSizeType = PointSizeType.FIXED;\n\t\tthis._shape = PointShape.SQUARE;\n\t\tthis._pointColorType = PointColorType.RGB;\n\t\tthis._useClipBox = false;\n\t\tthis._weighted = false;\n\t\tthis._gradient = Gradients.SPECTRAL;\n\t\tthis._treeType = treeType;\n\t\tthis._useEDL = false;\n\t\tthis._snapEnabled = false;\n\t\tthis._numSnapshots = 0;\n\t\tthis._defaultIntensityRangeChanged = false;\n\t\tthis._defaultElevationRangeChanged = false;\n\n\t\tthis.clipBoxes = [];\n\t\tthis.clipPolygons = [];\n\t\t\n\t\tthis.gradientTexture = PointCloudMaterial.generateGradientTexture(this._gradient);\n\t\tthis.lights = false;\n\t\tthis.fog = false;\n\t\tthis.defines = new Map();\n\t\t\n\t\tthis.attributes =\n\t\t{\n\t\t\tposition: {type: 'fv', value: []},\n\t\t\tcolor: {type: 'fv', value: []},\n\t\t\tnormal: {type: 'fv', value: []},\n\t\t\tintensity: {type: 'f', value: []},\n\t\t\tclassification: {type: 'f', value: []},\n\t\t\treturnNumber: {type: 'f', value: []},\n\t\t\tnumberOfReturns: {type: 'f', value: []},\n\t\t\tpointSourceID: {type: 'f', value: []},\n\t\t\tindices: {type: 'fv', value: []}\n\t\t};\n\n\t\tthis.uniforms =\n\t\t{\n\t\t\tlevel: {type: \"f\", value: 0.0},\n\t\t\tvnStart: {type: \"f\", value: 0.0},\n\t\t\tspacing: {type: \"f\", value: 1.0},\n\t\t\tblendHardness: {type: \"f\", value: 2.0},\n\t\t\tblendDepthSupplement:\t{type: \"f\", value: 0.0},\n\t\t\tfov: {type: \"f\", value: 1.0},\n\t\t\tscreenWidth: {type: \"f\", value: 1.0},\n\t\t\tscreenHeight: {type: \"f\", value: 1.0},\n\t\t\tnear: {type: \"f\", value: 0.1},\n\t\t\tfar: {type: \"f\", value: 1.0},\n\t\t\tuColor: {type: \"c\", value: new THREE.Color( 0xffffff )},\n\t\t\tuOpacity: {type: \"f\", value: 1.0},\n\t\t\tsize: {type: \"f\", value: pointSize},\n\t\t\tminSize: {type: \"f\", value: minSize},\n\t\t\tmaxSize: {type: \"f\", value: maxSize},\n\t\t\toctreeSize: {type: \"f\", value: 0},\n\t\t\tbbSize: {type: \"fv\", value: [0, 0, 0]},\n\t\t\televationRange: {type: \"2fv\", value: [0, 0]},\n\n\t\t\tclipBoxCount: {type: \"f\", value: 0},\n\t\t\t//clipSphereCount: {type: \"f\", value: 0},\n\t\t\tclipPolygonCount: {type: \"i\", value: 0},\n\t\t\tclipBoxes: {type: \"Matrix4fv\", value: []},\n\t\t\t//clipSpheres: {type: \"Matrix4fv\", value: []},\n\t\t\tclipPolygons: {type: \"3fv\", value: []},\n\t\t\tclipPolygonVCount: {type: \"iv\", value: []},\n\t\t\tclipPolygonVP: {type: \"Matrix4fv\", value: []},\n\n\t\t\tvisibleNodes: {type: \"t\", value: this.visibleNodesTexture},\n\t\t\tpcIndex: {type: \"f\", value: 0},\n\t\t\tgradient: {type: \"t\", value: this.gradientTexture},\n\t\t\tclassificationLUT: {type: \"t\", value: this.classificationTexture},\n\t\t\tuHQDepthMap: {type: \"t\", value: null},\n\t\t\ttoModel: {type: \"Matrix4f\", value: []},\n\t\t\tdiffuse: {type: \"fv\", value: [1, 1, 1]},\n\t\t\ttransition: {type: \"f\", value: 0.5},\n\t\t\tintensityRange: {type: \"fv\", value: [0, 65000]},\n\t\t\tintensityGamma: {type: \"f\", value: 1},\n\t\t\tintensityContrast: {type: \"f\", value: 0},\n\t\t\tintensityBrightness:{type: \"f\", value: 0},\n\t\t\trgbGamma: {type: \"f\", value: 1},\n\t\t\trgbContrast: {type: \"f\", value: 0},\n\t\t\trgbBrightness: {type: \"f\", value: 0},\n\t\t\twRGB: {type: \"f\", value: 1},\n\t\t\twIntensity: {type: \"f\", value: 0},\n\t\t\twElevation: {type: \"f\", value: 0},\n\t\t\twClassification: {type: \"f\", value: 0},\n\t\t\twReturnNumber: {type: \"f\", value: 0},\n\t\t\twSourceID: {type: \"f\", value: 0},\n\t\t\tuseOrthographicCamera: {type: \"b\", value: false},\n\t\t\tclipTask: {type: \"i\", value: 1},\n\t\t\tclipMethod: {type: \"i\", value: 1},\n\t\t\tuSnapshot: {type: \"tv\", value: []},\n\t\t\tuSnapshotDepth: {type: \"tv\", value: []},\n\t\t\tuSnapView: {type: \"Matrix4fv\", value: []},\n\t\t\tuSnapProj: {type: \"Matrix4fv\", value: []},\n\t\t\tuSnapProjInv: {type: \"Matrix4fv\", value: []},\n\t\t\tuSnapViewInv: {type: \"Matrix4fv\", value: []},\n\t\t\tuShadowColor: {type: \"3fv\", value: [0, 0, 0]},\n\n\t\t\tuFilterReturnNumberRange: {type: \"fv\", value: [0, 7]},\n\t\t\tuFilterNumberOfReturnsRange: {type: \"fv\", value: [0, 7]},\n\t\t\tuFilterGPSTimeClipRange: {type: \"fv\", value: [0, 7]},\n\t\t};\n\t\t\n\t\tthis.classification = Classification.DEFAULT;\n\t\tthis.defaultAttributeValues.normal = [0, 0, 0];\n\t\tthis.defaultAttributeValues.classification = [0, 0, 0];\n\t\tthis.defaultAttributeValues.indices = [0, 0, 0, 0];\n\n\t\tvar defines = this.getDefines();\n\t\tthis.vertexShader = defines + Shaders.vertex;\n\t\tthis.fragmentShader = defines + Shaders.fragment;\n\t\tthis.vertexColors = THREE.VertexColors;\n\t}\n\n\tsetDefine(key, value)\n\t{\n\t\tif(value !== undefined && value !== null)\n\t\t{\n\t\t\tif(this.defines.get(key) !== value)\n\t\t\t{\n\t\t\t\tthis.defines.set(key, value);\n\t\t\t\tthis.updateShaderSource();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.removeDefine(key);\n\t\t}\n\t}\n\n\tremoveDefine(key)\n\t{\n\t\tthis.defines.delete(key);\n\t}\n\n\tupdateShaderSource()\n\t{\n\t\tvar defines = this.getDefines();\n\t\tthis.vertexShader = defines + Shaders.vertex;\n\t\tthis.fragmentShader = defines + Shaders.fragment;\n\n\t\tif(this.opacity === 1.0)\n\t\t{\n\t\t\tthis.blending = THREE.NoBlending;\n\t\t\tthis.transparent = false;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\t\tthis.depthFunc = THREE.LessEqualDepth;\n\t\t}\n\t\telse if(this.opacity < 1.0 && !this.useEDL)\n\t\t{\n\t\t\tthis.blending = THREE.AdditiveBlending;\n\t\t\tthis.transparent = true;\n\t\t\tthis.depthTest = false;\n\t\t\tthis.depthWrite = true;\n\t\t\tthis.depthFunc = THREE.AlwaysDepth;\n\t\t}\n\n\t\tif(this.weighted)\n\t\t{\n\t\t\tthis.blending = THREE.AdditiveBlending;\n\t\t\tthis.transparent = true;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = false;\n\t\t}\n\n\t\tthis.needsUpdate = true;\n\t}\n\n\tonBeforeCompile(shader, renderer)\n\t{\n\t\tif(renderer.capabilities.logarithmicDepthBuffer)\n\t\t{\n\t\t\tvar define = \"#define USE_LOGDEPTHBUF\\n#define USE_LOGDEPTHBUF_EXT\\n#define EPSILON 1e-6\\n\";\n\t\t\tshader.fragmentShader = define + shader.fragmentShader;\n\t\t\tshader.vertexShader = define + shader.vertexShader;\n\t\t}\n\t}\n\n\tgetDefines()\n\t{\n\t\tvar defines = [];\n\n\t\tif(this.pointSizeType === PointSizeType.FIXED)\n\t\t{\n\t\t\tdefines.push(\"#define fixed_point_size\");\n\t\t}\n\t\telse if(this.pointSizeType === PointSizeType.ATTENUATED)\n\t\t{\n\t\t\tdefines.push(\"#define attenuated_point_size\");\n\t\t}\n\t\telse if(this.pointSizeType === PointSizeType.ADAPTIVE)\n\t\t{\n\t\t\tdefines.push(\"#define adaptive_point_size\");\n\t\t}\n\n\t\tif(this.shape === PointShape.SQUARE)\n\t\t{\n\t\t\tdefines.push(\"#define square_point_shape\");\n\t\t}\n\t\telse if(this.shape === PointShape.CIRCLE)\n\t\t{\n\t\t\tdefines.push(\"#define circle_point_shape\");\n\t\t}\n\t\telse if(this.shape === PointShape.PARABOLOID)\n\t\t{\n\t\t\tdefines.push(\"#define paraboloid_point_shape\");\n\t\t}\n\n\t\tif(this._useEDL)\n\t\t{\n\t\t\tdefines.push(\"#define use_edl\");\n\t\t}\n\n\t\tif(this._snapEnabled)\n\t\t{\n\t\t\tdefines.push(\"#define snap_enabled\");\n\t\t}\n\n\t\tif(this._pointColorType === PointColorType.RGB)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_rgb\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.COLOR)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_color\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.DEPTH)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_depth\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.HEIGHT)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_height\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.INTENSITY)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_intensity\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.INTENSITY_GRADIENT)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_intensity_gradient\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.LOD)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_lod\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.POINT_INDEX)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_point_index\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.CLASSIFICATION)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_classification\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.RETURN_NUMBER)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_return_number\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.SOURCE)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_source\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.NORMAL)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_normal\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.PHONG)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_phong\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.RGB_HEIGHT)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_rgb_height\");\n\t\t}\n\t\telse if(this._pointColorType === PointColorType.COMPOSITE)\n\t\t{\n\t\t\tdefines.push(\"#define color_type_composite\");\n\t\t}\n\n\n\t\tif(this._treeType === TreeType.OCTREE)\n\t\t{\n\t\t\tdefines.push(\"#define tree_type_octree\");\n\t\t}\n\t\telse if(this._treeType === TreeType.KDTREE)\n\t\t{\n\t\t\tdefines.push(\"#define tree_type_kdtree\");\n\t\t}\n\n\t\tif(this.weighted)\n\t\t{\n\t\t\tdefines.push(\"#define weighted_splats\");\n\t\t}\n\n\t\tfor(var [key, value] of this.defines)\n\t\t{\n\t\t\tdefines.push(value);\n\t\t}\n\n\t\treturn defines.join(\"\\n\");\n\t}\n\n\tsetClipBoxes(clipBoxes)\n\t{\n\t\tif(!clipBoxes)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar doUpdate = (this.clipBoxes.length !== clipBoxes.length) && (clipBoxes.length === 0 || this.clipBoxes.length === 0);\n\t\tthis.uniforms.clipBoxCount.value = this.clipBoxes.length;\n\t\tthis.clipBoxes = clipBoxes;\n\n\t\tif(doUpdate)\n\t\t{\n\t\t\tthis.updateShaderSource();\n\t\t}\n\n\t\tthis.uniforms.clipBoxes.value = new Float32Array(this.clipBoxes.length * 16);\n\t\t\n\t\tfor(var i = 0; i < this.clipBoxes.length; i++)\n\t\t{\n\t\t\tvar box = clipBoxes[i];\n\t\t\tthis.uniforms.clipBoxes.value.set(box.inverse.elements, 16 * i);\n\t\t}\n\n\t\tfor(var i = 0; i < this.uniforms.clipBoxes.value.length; i++)\n\t\t{\n\t\t\tif(Number.isNaN(this.uniforms.clipBoxes.value[i]))\n\t\t\t{\n\t\t\t\tthis.uniforms.clipBoxes.value[i] = Infinity;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetClipPolygons(clipPolygons, maxPolygonVertices)\n\t{\n\t\tif(!clipPolygons)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tthis.clipPolygons = clipPolygons;\n\t\tvar doUpdate = (this.clipPolygons.length !== clipPolygons.length);\n\t\tif(doUpdate)\n\t\t{\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget gradient()\n\t{\n\t\treturn this._gradient;\n\t}\n\t\n\tset gradient(value)\n\t{\n\t\tif(this._gradient !== value)\n\t\t{\n\t\t\tthis._gradient = value;\n\t\t\tthis.gradientTexture = PointCloudMaterial.generateGradientTexture(this._gradient);\n\t\t\tthis.uniforms.gradient.value = this.gradientTexture;\n\t\t}\n\t}\n\n\tget useOrthographicCamera()\n\t{\n\t\treturn this.uniforms.useOrthographicCamera.value;\n\t}\n\t\n\tset useOrthographicCamera(value)\n\t{\n\t\tif(this.uniforms.useOrthographicCamera.value !== value)\n\t\t{\n\t\t\tthis.uniforms.useOrthographicCamera.value = value;\n\t\t}\n\t}\n\n\tget classification()\n\t{\n\t\treturn this._classification;\n\t}\n\t\n\tset classification(value)\n\t{\n\t\tvar copy = {};\n\t\tfor(var key of Object.keys(value))\n\t\t{\n\t\t\tcopy[key] = value[key].clone();\n\t\t}\n\t\t\n\t\tvar isEqual = false;\n\t\tif(this._classification === undefined)\n\t\t{\n\t\t\tisEqual = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisEqual = Object.keys(copy).length === Object.keys(this._classification).length;\n\t\t\tfor(var key of Object.keys(copy))\n\t\t\t{\n\t\t\t\tisEqual = isEqual && this._classification[key] !== undefined;\n\t\t\t\tisEqual = isEqual && copy[key].equals(this._classification[key]);\n\t\t\t}\n\t\t}\n\n\t\tif(!isEqual)\n\t\t{\n\t\t\tthis._classification = copy;\n\t\t\tthis.recomputeClassification();\n\t\t}\n\t}\n\t\n\trecomputeClassification()\n\t{\n\t\tthis.classificationTexture = PointCloudMaterial.generateClassificationTexture(this._classification);\n\t\tthis.uniforms.classificationLUT.value = this.classificationTexture;\n\t\tthis.dispatchEvent(\n\t\t{\n\t\t\ttype: \"material_property_changed\",\n\t\t\ttarget: this\n\t\t});\n\t}\n\n\tget numSnapshots()\n\t{\n\t\treturn this._numSnapshots;\n\t}\n\t\n\tset numSnapshots(value)\n\t{\n\t\tthis._numSnapshots = value;\n\t}\n\n\tget snapEnabled()\n\t{\n\t\treturn this._snapEnabled;\n\t}\n\t\n\tset snapEnabled(value)\n\t{\n\t\tif(this._snapEnabled !== value)\n\t\t{\n\t\t\tthis._snapEnabled = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget spacing()\n\t{\n\t\treturn this.uniforms.spacing.value;\n\t}\n\t\n\tset spacing(value)\n\t{\n\t\tif(this.uniforms.spacing.value !== value)\n\t\t{\n\t\t\tthis.uniforms.spacing.value = value;\n\t\t}\n\t}\n\n\tget useClipBox()\n\t{\n\t\treturn this._useClipBox;\n\t}\n\t\n\tset useClipBox(value)\n\t{\n\t\tif(this._useClipBox !== value)\n\t\t{\n\t\t\tthis._useClipBox = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget clipTask()\n\t{\n\t\treturn this.uniforms.clipTask.value;\n\t}\n\t\n\tset clipTask(mode)\n\t{\n\t\tthis.uniforms.clipTask.value = mode;\n\t}\n\n\tget clipMethod()\n\t{\n\t\treturn this.uniforms.clipMethod.value;\n\t}\n\t\n\tset clipMethod(mode)\n\t{\n\t\tthis.uniforms.clipMethod.value = mode;\n\t}\n\n\tget weighted()\n\t{\n\t\treturn this._weighted;\n\t}\n\t\n\tset weighted(value)\n\t{\n\t\tif(this._weighted !== value)\n\t\t{\n\t\t\tthis._weighted = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget fov()\n\t{\n\t\treturn this.uniforms.fov.value;\n\t}\n\t\n\tset fov(value)\n\t{\n\t\tif(this.uniforms.fov.value !== value)\n\t\t{\n\t\t\tthis.uniforms.fov.value = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget screenWidth()\n\t{\n\t\treturn this.uniforms.screenWidth.value;\n\t}\n\t\n\tset screenWidth(value)\n\t{\n\t\tif(this.uniforms.screenWidth.value !== value)\n\t\t{\n\t\t\tthis.uniforms.screenWidth.value = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget screenHeight()\n\t{\n\t\treturn this.uniforms.screenHeight.value;\n\t}\n\t\n\tset screenHeight(value)\n\t{\n\t\tif(this.uniforms.screenHeight.value !== value)\n\t\t{\n\t\t\tthis.uniforms.screenHeight.value = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget near()\n\t{\n\t\treturn this.uniforms.near.value;\n\t}\n\t\n\tset near(value)\n\t{\n\t\tif(this.uniforms.near.value !== value)\n\t\t{\n\t\t\tthis.uniforms.near.value = value;\n\t\t}\n\t}\n\n\tget far()\n\t{\n\t\treturn this.uniforms.far.value;\n\t}\n\t\n\tset far(value)\n\t{\n\t\tif(this.uniforms.far.value !== value)\n\t\t{\n\t\t\tthis.uniforms.far.value = value;\n\t\t}\n\t}\n\n\tget opacity()\n\t{\n\t\treturn this.uniforms.uOpacity.value;\n\t}\n\t\n\tset opacity(value)\n\t{\n\t\tif(this.uniforms && this.uniforms.uOpacity)\n\t\t{\n\t\t\tif(this.uniforms.uOpacity.value !== value)\n\t\t\t{\n\t\t\t\tthis.uniforms.uOpacity.value = value;\n\t\t\t\tthis.updateShaderSource();\n\t\t\t\tthis.dispatchEvent(\n\t\t\t\t{\n\t\t\t\t\ttype: \"opacity_changed\",\n\t\t\t\t\ttarget: this\n\t\t\t\t});\n\t\t\t\tthis.dispatchEvent(\n\t\t\t\t{\n\t\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\t\ttarget: this\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tget pointColorType()\n\t{\n\t\treturn this._pointColorType;\n\t}\n\t\n\tset pointColorType(value)\n\t{\n\t\tif(this._pointColorType !== value)\n\t\t{\n\t\t\tthis._pointColorType = value;\n\t\t\tthis.updateShaderSource();\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"point_color_type_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget pointSizeType()\n\t{\n\t\treturn this._pointSizeType;\n\t}\n\t\n\tset pointSizeType(value)\n\t{\n\t\tif(this._pointSizeType !== value)\n\t\t{\n\t\t\tthis._pointSizeType = value;\n\t\t\tthis.updateShaderSource();\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"point_size_type_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget useEDL()\n\t{\n\t\treturn this._useEDL;\n\t}\n\t\n\tset useEDL(value)\n\t{\n\t\tif(this._useEDL !== value)\n\t\t{\n\t\t\tthis._useEDL = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget color()\n\t{\n\t\treturn this.uniforms.uColor.value;\n\t}\n\t\n\tset color(value)\n\t{\n\t\tif(!this.uniforms.uColor.value.equals(value))\n\t\t{\n\t\t\tthis.uniforms.uColor.value.copy(value);\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"color_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget shape()\n\t{\n\t\treturn this._shape;\n\t}\n\t\n\tset shape(value)\n\t{\n\t\tif(this._shape !== value)\n\t\t{\n\t\t\tthis._shape = value;\n\t\t\tthis.updateShaderSource();\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"point_shape_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget treeType()\n\t{\n\t\treturn this._treeType;\n\t}\n\n\tset treeType(value)\n\t{\n\t\tif(this._treeType !== value)\n\t\t{\n\t\t\tthis._treeType = value;\n\t\t\tthis.updateShaderSource();\n\t\t}\n\t}\n\n\tget bbSize()\n\t{\n\t\treturn this.uniforms.bbSize.value;\n\t}\n\n\tset bbSize(value)\n\t{\n\t\tthis.uniforms.bbSize.value = value;\n\t}\n\n\tget size()\n\t{\n\t\treturn this.uniforms.size.value;\n\t}\n\n\tset size(value)\n\t{\n\t\tif(this.uniforms.size.value !== value)\n\t\t{\n\t\t\tthis.uniforms.size.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"point_size_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget elevationRange()\n\t{\n\t\treturn this.uniforms.elevationRange.value;\n\t}\n\n\tset elevationRange(value)\n\t{\n\t\tvar changed = this.uniforms.elevationRange.value[0] !== value[0] ||\n\t\t\tthis.uniforms.elevationRange.value[1] !== value[1];\n\t\tif(changed)\n\t\t{\n\t\t\tthis.uniforms.elevationRange.value = value;\n\t\t\tthis._defaultElevationRangeChanged = true;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget heightMin()\n\t{\n\t\treturn this.uniforms.elevationRange.value[0];\n\t}\n\n\tset heightMin(value)\n\t{\n\t\tthis.elevationRange = [value, this.elevationRange[1]];\n\t}\n\n\tget heightMax()\n\t{\n\t\treturn this.uniforms.elevationRange.value[1];\n\t}\n\n\tset heightMax(value)\n\t{\n\t\tthis.elevationRange = [this.elevationRange[0], value];\n\t}\n\n\tget transition()\n\t{\n\t\treturn this.uniforms.transition.value;\n\t}\n\n\tset transition(value)\n\t{\n\t\tthis.uniforms.transition.value = value;\n\t}\n\n\tget intensityRange()\n\t{\n\t\treturn this.uniforms.intensityRange.value;\n\t}\n\n\tset intensityRange(value)\n\t{\n\t\tif(!(value instanceof Array && value.length === 2))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif(value[0] === this.uniforms.intensityRange.value[0] && value[1] === this.uniforms.intensityRange.value[1])\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.uniforms.intensityRange.value = value;\n\t\tthis._defaultIntensityRangeChanged = true;\n\n\t\tthis.dispatchEvent(\n\t\t{\n\t\t\ttype: \"material_property_changed\",\n\t\t\ttarget: this\n\t\t});\n\t}\n\n\tget intensityGamma()\n\t{\n\t\treturn this.uniforms.intensityGamma.value;\n\t}\n\n\tset intensityGamma(value)\n\t{\n\t\tif(this.uniforms.intensityGamma.value !== value)\n\t\t{\n\t\t\tthis.uniforms.intensityGamma.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget intensityContrast()\n\t{\n\t\treturn this.uniforms.intensityContrast.value;\n\t}\n\n\tset intensityContrast(value)\n\t{\n\t\tif(this.uniforms.intensityContrast.value !== value)\n\t\t{\n\t\t\tthis.uniforms.intensityContrast.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget intensityBrightness()\n\t{\n\t\treturn this.uniforms.intensityBrightness.value;\n\t}\n\n\tset intensityBrightness(value)\n\t{\n\t\tif(this.uniforms.intensityBrightness.value !== value)\n\t\t{\n\t\t\tthis.uniforms.intensityBrightness.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget rgbGamma()\n\t{\n\t\treturn this.uniforms.rgbGamma.value;\n\t}\n\n\tset rgbGamma(value)\n\t{\n\t\tif(this.uniforms.rgbGamma.value !== value)\n\t\t{\n\t\t\tthis.uniforms.rgbGamma.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget rgbContrast()\n\t{\n\t\treturn this.uniforms.rgbContrast.value;\n\t}\n\n\tset rgbContrast(value)\n\t{\n\t\tif(this.uniforms.rgbContrast.value !== value)\n\t\t{\n\t\t\tthis.uniforms.rgbContrast.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget rgbBrightness()\n\t{\n\t\treturn this.uniforms.rgbBrightness.value;\n\t}\n\n\tset rgbBrightness(value)\n\t{\n\t\tif(this.uniforms.rgbBrightness.value !== value)\n\t\t{\n\t\t\tthis.uniforms.rgbBrightness.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightRGB()\n\t{\n\t\treturn this.uniforms.wRGB.value;\n\t}\n\n\tset weightRGB(value)\n\t{\n\t\tif(this.uniforms.wRGB.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wRGB.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightIntensity()\n\t{\n\t\treturn this.uniforms.wIntensity.value;\n\t}\n\n\tset weightIntensity(value)\n\t{\n\t\tif(this.uniforms.wIntensity.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wIntensity.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightElevation()\n\t{\n\t\treturn this.uniforms.wElevation.value;\n\t}\n\n\tset weightElevation(value)\n\t{\n\t\tif(this.uniforms.wElevation.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wElevation.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightClassification()\n\t{\n\t\treturn this.uniforms.wClassification.value;\n\t}\n\n\tset weightClassification(value)\n\t{\n\t\tif(this.uniforms.wClassification.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wClassification.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightReturnNumber()\n\t{\n\t\treturn this.uniforms.wReturnNumber.value;\n\t}\n\n\tset weightReturnNumber(value)\n\t{\n\t\tif(this.uniforms.wReturnNumber.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wReturnNumber.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tget weightSourceID()\n\t{\n\t\treturn this.uniforms.wSourceID.value;\n\t}\n\n\tset weightSourceID(value)\n\t{\n\t\tif(this.uniforms.wSourceID.value !== value)\n\t\t{\n\t\t\tthis.uniforms.wSourceID.value = value;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"material_property_changed\",\n\t\t\t\ttarget: this\n\t\t\t});\n\t\t}\n\t}\n\n\tstatic generateGradientTexture(gradient)\n\t{\n\t\tvar size = 64;\n\t\t\n\t\t//Create canvas\n\t\tvar canvas = document.createElement(\"canvas\");\n\t\tcanvas.width = size;\n\t\tcanvas.height = size;\n\n\t\t//Get context\n\t\tvar context = canvas.getContext(\"2d\");\n\n\t\t//Draw gradient\n\t\tcontext.rect(0, 0, size, size);\n\t\tvar ctxGradient = context.createLinearGradient(0, 0, size, size);\n\t\tfor(var i = 0; i < gradient.length; i++)\n\t\t{\n\t\t\tvar step = gradient[i];\n\t\t\tctxGradient.addColorStop(step[0], \"#\" + step[1].getHexString());\n\t\t}\n\t\tcontext.fillStyle = ctxGradient;\n\t\tcontext.fill();\n\n\t\tvar texture = new THREE.CanvasTexture(canvas);\n\t\ttexture.needsUpdate = true;\n\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\treturn texture;\n\t}\n\n\tstatic generateClassificationTexture(classification)\n\t{\n\t\tvar width = 256;\n\t\tvar height = 256;\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array(4 * size);\n\t\tfor(var x = 0; x < width; x++)\n\t\t{\n\t\t\tfor(var y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tvar i = x + width * y;\n\t\t\t\tvar color;\n\t\t\t\tif(classification[x])\n\t\t\t\t{\n\t\t\t\t\tcolor = classification[x];\n\t\t\t\t}\n\t\t\t\telse if(classification[x % 32])\n\t\t\t\t{\n\t\t\t\t\tcolor = classification[x % 32];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor = classification.DEFAULT;\n\t\t\t\t}\n\t\t\t\tdata[4 * i + 0] = 255 * color.x;\n\t\t\t\tdata[4 * i + 1] = 255 * color.y;\n\t\t\t\tdata[4 * i + 2] = 255 * color.z;\n\t\t\t\tdata[4 * i + 3] = 255 * color.w;\n\t\t\t}\n\t\t}\n\t\tvar texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n\t\ttexture.magFilter = THREE.NearestFilter;\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n\tdisableEvents()\n\t{\n\t\tif(this._hiddenListeners === undefined)\n\t\t{\n\t\t\tthis._hiddenListeners = this._listeners;\n\t\t\tthis._listeners = {};\n\t\t}\n\t}\n\n\tenableEvents()\n\t{\n\t\tthis._listeners = this._hiddenListeners;\n\t\tthis._hiddenListeners = undefined;\n\t}\n\n\tcopyFrom(from)\n\t{\n\t\tfor(var name of this.uniforms)\n\t\t{\n\t\t\tthis.uniforms[name].value = from.uniforms[name].value;\n\t\t}\n\t}\n}\n\nclass PointCloudOctreeNode extends PointCloudTreeNode\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis.children = {};\n\t\tthis.sceneNode = null;\n\t\tthis.octree = null;\n\t}\n\n\tgetNumPoints()\n\t{\n\t\treturn this.geometryNode.numPoints;\n\t}\n\n\tisLoaded()\n\t{\n\t\treturn true;\n\t}\n\n\tisTreeNode()\n\t{\n\t\treturn true;\n\t}\n\n\tisGeometryNode()\n\t{\n\t\treturn false;\n\t}\n\n\tgetLevel()\n\t{\n\t\treturn this.geometryNode.level;\n\t}\n\n\tgetBoundingSphere()\n\t{\n\t\treturn this.geometryNode.boundingSphere;\n\t}\n\n\tgetBoundingBox()\n\t{\n\t\treturn this.geometryNode.boundingBox;\n\t}\n\n\tgetChildren()\n\t{\n\t\tvar children = [];\n\n\t\tfor(var i = 0; i < 8; i++)\n\t\t{\n\t\t\tif(this.children[i])\n\t\t\t{\n\t\t\t\tchildren.push(this.children[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn children;\n\t}\n\n\tgetPointsInBox(boxNode)\n\t{\n\n\t\tif(!this.sceneNode)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tvar buffer = this.geometryNode.buffer;\n\n\t\tvar posOffset = buffer.offset(\"position\");\n\t\tvar stride = buffer.stride;\n\t\tvar view = new DataView(buffer.data);\n\n\t\tvar worldToBox = new THREE.Matrix4().getInverse(boxNode.matrixWorld);\n\t\tvar objectToBox = new THREE.Matrix4().multiplyMatrices(worldToBox, this.sceneNode.matrixWorld);\n\n\t\tvar inBox = [];\n\n\t\tvar pos = new THREE.Vector4();\n\t\tfor(var i = 0; i < buffer.numElements; i++)\n\t\t{\n\t\t\tvar x = view.getFloat32(i * stride + posOffset + 0, true);\n\t\t\tvar y = view.getFloat32(i * stride + posOffset + 4, true);\n\t\t\tvar z = view.getFloat32(i * stride + posOffset + 8, true);\n\n\t\t\tpos.set(x, y, z, 1);\n\t\t\tpos.applyMatrix4(objectToBox);\n\n\t\t\tif(-0.5 < pos.x && pos.x < 0.5)\n\t\t\t{\n\t\t\t\tif(-0.5 < pos.y && pos.y < 0.5)\n\t\t\t\t{\n\t\t\t\t\tif(-0.5 < pos.z && pos.z < 0.5)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos.set(x, y, z, 1).applyMatrix4(this.sceneNode.matrixWorld);\n\t\t\t\t\t\tinBox.push(new THREE.Vector3(pos.x, pos.y, pos.z));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn inBox;\n\t}\n\n\tget name()\n\t{\n\t\treturn this.geometryNode.name;\n\t}\n}\nclass PointCloudOctree extends PointCloudTree\n{\n\tconstructor(geometry, material)\n\t{\n\t\tsuper();\n\n\t\tthis.pointBudget = Infinity;\n\t\tthis.pcoGeometry = geometry;\n\t\tthis.boundingBox = this.pcoGeometry.boundingBox;\n\t\tthis.boundingSphere = this.boundingBox.getBoundingSphere(new THREE.Sphere());\n\t\tthis.material = material || new PointCloudMaterial();\n\t\tthis.visiblePointsTarget = 2 * 1000 * 1000;\n\t\tthis.minimumNodePixelSize = 150;\n\t\tthis.level = 0;\n\t\tthis.position.copy(geometry.offset);\n\t\tthis.updateMatrix();\n\n\t\tthis.showBoundingBox = false;\n\t\tthis.boundingBoxNodes = [];\n\t\tthis.loadQueue = [];\n\t\tthis.visibleBounds = new THREE.Box3();\n\t\tthis.visibleNodes = [];\n\t\tthis.visibleGeometry = [];\n\t\tthis.generateDEM = false;\n\t\tthis.profileRequests = [];\n\t\tthis.name = \"\";\n\n\t\tthis.tempVector3 = new THREE.Vector3();\n\n\t\tvar box = [this.pcoGeometry.tightBoundingBox, this.getBoundingBoxWorld()].find(v => v !== undefined);\n\n\t\tthis.updateMatrixWorld(true);\n\t\tbox = HelperUtils.computeTransformedBoundingBox(box, this.matrixWorld);\n\n\t\tvar bMin = box.min.z;\n\t\tvar bMax = box.max.z;\n\t\tthis.material.heightMin = bMin;\n\t\tthis.material.heightMax = bMax;\n\n\t\t//TODO <read projection from file instead>\n\t\tthis.projection = geometry.projection;\n\n\t\tthis.root = this.pcoGeometry.root;\n\t}\n\n\tsetName(name)\n\t{\n\t\tif(this.name !== name)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"name_changed\",\n\t\t\t\tname: name,\n\t\t\t\tpointcloud: this\n\t\t\t});\n\t\t}\n\t}\n\n\tgetName()\n\t{\n\t\treturn this.name;\n\t}\n\n\ttoTreeNode(geometryNode, parent)\n\t{\n\t\tvar node = new PointCloudOctreeNode();\n\n\t\tvar sceneNode = new THREE.Points(geometryNode.geometry, this.material);\n\t\tsceneNode.name = geometryNode.name;\n\t\tsceneNode.position.copy(geometryNode.boundingBox.min);\n\t\tsceneNode.frustumCulled = true;\n\t\tsceneNode.onBeforeRender = (_this, scene, camera, geometry, material, group) =>\n\t\t{\n\t\t\tif(material.program)\n\t\t\t{\n\t\t\t\t_this.getContext().useProgram(material.program.program);\n\n\t\t\t\tif(material.program.getUniforms().map.level)\n\t\t\t\t{\n\t\t\t\t\tvar level = geometryNode.getLevel();\n\t\t\t\t\tmaterial.uniforms.level.value = level;\n\t\t\t\t\tmaterial.program.getUniforms().map.level.setValue(_this.getContext(), level);\n\t\t\t\t}\n\n\t\t\t\tif(this.visibleNodeTextureOffsets && material.program.getUniforms().map.vnStart)\n\t\t\t\t{\n\t\t\t\t\tvar vnStart = this.visibleNodeTextureOffsets.get(node);\n\t\t\t\t\tmaterial.uniforms.vnStart.value = vnStart;\n\t\t\t\t\tmaterial.program.getUniforms().map.vnStart.setValue(_this.getContext(), vnStart);\n\t\t\t\t}\n\n\t\t\t\tif(material.program.getUniforms().map.pcIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i = node.pcIndex ? node.pcIndex : this.visibleNodes.indexOf(node);\n\t\t\t\t\tmaterial.uniforms.pcIndex.value = i;\n\t\t\t\t\tmaterial.program.getUniforms().map.pcIndex.setValue(_this.getContext(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tnode.geometryNode = geometryNode;\n\t\tnode.sceneNode = sceneNode;\n\t\tnode.pointcloud = this;\n\t\tnode.children = {};\n\t\tfor(var key in geometryNode.children)\n\t\t{\n\t\t\tnode.children[key] = geometryNode.children[key];\n\t\t}\n\n\t\tif(!parent)\n\t\t{\n\t\t\tthis.root = node;\n\t\t\tthis.add(sceneNode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar childIndex = parseInt(geometryNode.name[geometryNode.name.length - 1]);\n\t\t\tparent.sceneNode.add(sceneNode);\n\t\t\tparent.children[childIndex] = node;\n\t\t}\n\n\t\tvar disposeListener = function()\n\t\t{\n\t\t\tvar childIndex = parseInt(geometryNode.name[geometryNode.name.length - 1]);\n\t\t\tparent.sceneNode.remove(node.sceneNode);\n\t\t\tparent.children[childIndex] = geometryNode;\n\t\t};\n\t\tgeometryNode.oneTimeDisposeHandlers.push(disposeListener);\n\n\t\treturn node;\n\t}\n\n\tupdateVisibleBounds()\n\t{\n\t\tvar leafNodes = [];\n\t\tfor(var i = 0; i < this.visibleNodes.length; i++)\n\t\t{\n\t\t\tvar node = this.visibleNodes[i];\n\t\t\tvar isLeaf = true;\n\n\t\t\tfor(var j = 0; j < node.children.length; j++)\n\t\t\t{\n\t\t\t\tvar child = node.children[j];\n\t\t\t\tif(child instanceof PointCloudOctreeNode)\n\t\t\t\t{\n\t\t\t\t\tisLeaf = isLeaf && !child.sceneNode.visible;\n\t\t\t\t}\n\t\t\t\telse if(child instanceof PointCloudOctreeGeometryNode)\n\t\t\t\t{\n\t\t\t\t\tisLeaf = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(isLeaf)\n\t\t\t{\n\t\t\t\tleafNodes.push(node);\n\t\t\t}\n\t\t}\n\n\t\tthis.visibleBounds.min = new THREE.Vector3(Infinity, Infinity, Infinity);\n\t\tthis.visibleBounds.max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n\n\t\tfor(var i = 0; i < leafNodes.length; i++)\n\t\t{\n\t\t\tvar node = leafNodes[i];\n\t\t\tthis.visibleBounds.expandByPoint(node.getBoundingBox().min);\n\t\t\tthis.visibleBounds.expandByPoint(node.getBoundingBox().max);\n\t\t}\n\t}\n\n\tupdateMaterial(material, visibleNodes, camera, renderer)\n\t{\n\t\tmaterial.fov = camera.fov * (Math.PI / 180);\n\t\tmaterial.screenWidth = renderer.domElement.clientWidth;\n\t\tmaterial.screenHeight = renderer.domElement.clientHeight;\n\t\tmaterial.spacing = this.pcoGeometry.spacing * Math.max(this.scale.x, this.scale.y, this.scale.z);\n\t\tmaterial.near = camera.near;\n\t\tmaterial.far = camera.far;\n\t\tmaterial.uniforms.octreeSize.value = this.pcoGeometry.boundingBox.getSize(new THREE.Vector3()).x;\n\t}\n\n\tcomputeVisibilityTextureData(nodes, camera)\n\t{\n\t\tif(Global.measureTimings)\n\t\t{\n\t\t\tperformance.mark(\"computeVisibilityTextureData-start\");\n\t\t}\n\n\t\tvar data = new Uint8Array(nodes.length * 4);\n\t\tvar visibleNodeTextureOffsets = new Map();\n\n\t\t//copy array\n\t\tnodes = nodes.slice();\n\n\t\t//sort by level and index, e.g. r, r0, r3, r4, r01, r07, r30, ...\n\t\tvar sort = function(a, b)\n\t\t{\n\t\t\tvar na = a.geometryNode.name;\n\t\t\tvar nb = b.geometryNode.name;\n\t\t\tif(na.length !== nb.length) return na.length - nb.length;\n\t\t\tif(na < nb) return -1;\n\t\t\tif(na > nb) return 1;\n\t\t\treturn 0;\n\t\t};\n\t\tnodes.sort(sort);\n\n\t\t//code sample taken from three.js src/math/Ray.js\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar intersectSphereBack = (ray, sphere) =>\n\t\t{\n\t\t\tv1.subVectors(sphere.center, ray.origin);\n\t\t\tvar tca = v1.dot(ray.direction);\n\t\t\tvar d2 = v1.dot(v1) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif(d2 > radius2)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar thc = Math.sqrt(radius2 - d2);\n\n\t\t\t//t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\tif(t1 < 0)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn t1;\n\t\t};\n\n\t\tvar lodRanges = new Map();\n\t\tvar leafNodeLodRanges = new Map();\n\n\t\tfor(var i = 0; i < nodes.length; i++)\n\t\t{\n\t\t\tvar node = nodes[i];\n\n\t\t\tvisibleNodeTextureOffsets.set(node, i);\n\n\t\t\tvar children = [];\n\t\t\tfor(var j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tvar child = node.children[j];\n\n\t\t\t\tif(child && child.constructor === PointCloudOctreeNode && nodes.includes(child, i))\n\t\t\t\t{\n\t\t\t\t\tchildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar spacing = node.geometryNode.estimatedSpacing;\n\n\t\t\tdata[i * 4 + 0] = 0;\n\t\t\tdata[i * 4 + 1] = 0;\n\t\t\tdata[i * 4 + 2] = 0;\n\t\t\tdata[i * 4 + 3] = node.getLevel();\n\t\t\tfor(var j = 0; j < children.length; j++)\n\t\t\t{\n\t\t\t\tvar child = children[j];\n\t\t\t\tvar index = parseInt(child.geometryNode.name.substr(-1));\n\t\t\t\tdata[i * 4 + 0] += Math.pow(2, index);\n\n\t\t\t\tif(j === 0)\n\t\t\t\t{\n\t\t\t\t\tvar vArrayIndex = nodes.indexOf(child, i);\n\n\t\t\t\t\tdata[i * 4 + 1] = (vArrayIndex - i) >> 8;\n\t\t\t\t\tdata[i * 4 + 2] = (vArrayIndex - i) % 256;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//TODO performance optimization\n\t\t\t//for some reason, this part can be extremely slow in chrome during a debugging session, but not during profiling\n\t\t\tvar bBox = node.getBoundingBox().clone();\n\t\t\t//bBox.applyMatrix4(node.sceneNode.matrixWorld);\n\t\t\t//bBox.applyMatrix4(camera.matrixWorldInverse);\n\t\t\tvar bSphere = bBox.getBoundingSphere(new THREE.Sphere());\n\t\t\tbSphere.applyMatrix4(node.sceneNode.matrixWorld);\n\t\t\tbSphere.applyMatrix4(camera.matrixWorldInverse);\n\n\t\t\tvar ray = new THREE.Ray(camera.position, camera.getWorldDirection(this.tempVector3));\n\t\t\tvar distance = intersectSphereBack(ray, bSphere);\n\t\t\tvar distance2 = bSphere.center.distanceTo(camera.position) + bSphere.radius;\n\t\t\tif(distance === null)\n\t\t\t{\n\t\t\t\tdistance = distance2;\n\t\t\t}\n\t\t\tdistance = Math.max(distance, distance2);\n\n\t\t\tif(!lodRanges.has(node.getLevel()))\n\t\t\t{\n\t\t\t\tlodRanges.set(node.getLevel(), distance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar prevDistance = lodRanges.get(node.getLevel());\n\t\t\t\tvar newDistance = Math.max(prevDistance, distance);\n\t\t\t\tlodRanges.set(node.getLevel(), newDistance);\n\t\t\t}\n\n\t\t\tif(!node.geometryNode.hasChildren)\n\t\t\t{\n\t\t\t\tvar value = {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\ti: i\n\t\t\t\t};\n\t\t\t\tleafNodeLodRanges.set(node, value);\n\t\t\t}\n\t\t}\n\n\t\tfor(var [node, value] of leafNodeLodRanges)\n\t\t{\n\t\t\tvar level = node.getLevel();\n\t\t\tvar distance = value.distance;\n\t\t\tvar i = value.i;\n\n\t\t\tif(level < 4)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(var [lod, range] of lodRanges)\n\t\t\t{\n\t\t\t\tif(distance < range * 1.2)\n\t\t\t\t{\n\t\t\t\t\tdata[i * 4 + 3] = lod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(Global.measureTimings)\n\t\t{\n\t\t\tperformance.mark(\"computeVisibilityTextureData-end\");\n\t\t\tperformance.measure(\"render.computeVisibilityTextureData\", \"computeVisibilityTextureData-start\", \"computeVisibilityTextureData-end\");\n\t\t}\n\n\t\treturn {\n\t\t\tdata: data,\n\t\t\toffsets: visibleNodeTextureOffsets\n\t\t};\n\t}\n\n\tnodeIntersectsProfile(node, profile)\n\t{\n\t\tvar bbWorld = node.boundingBox.clone().applyMatrix4(this.matrixWorld);\n\t\tvar bsWorld = bbWorld.getBoundingSphere(new THREE.Sphere());\n\n\t\tvar intersects = false;\n\n\t\tfor(var i = 0; i < profile.points.length - 1; i++)\n\t\t{\n\n\t\t\tvar start = new THREE.Vector3(profile.points[i + 0].x, profile.points[i + 0].y, bsWorld.center.z);\n\t\t\tvar end = new THREE.Vector3(profile.points[i + 1].x, profile.points[i + 1].y, bsWorld.center.z);\n\n\t\t\tvar closest = new THREE.Line3(start, end).closestPointToPoint(bsWorld.center, true);\n\t\t\tvar distance = closest.distanceTo(bsWorld.center);\n\n\t\t\tintersects = intersects || (distance < (bsWorld.radius + profile.width));\n\t\t}\n\n\t\treturn intersects;\n\t}\n\n\tnodesOnRay(nodes, ray)\n\t{\n\t\tvar nodesOnRay = [];\n\n\t\tvar _ray = ray.clone();\n\t\tfor(var i = 0; i < nodes.length; i++)\n\t\t{\n\t\t\tvar node = nodes[i];\n\t\t\t//var inverseWorld = new THREE.Matrix4().getInverse(node.matrixWorld);\n\t\t\t//var sphere = node.getBoundingSphere(new THREE.Sphere()).clone().applyMatrix4(node.sceneNode.matrixWorld);\n\t\t\tvar sphere = node.getBoundingSphere(new THREE.Sphere()).clone().applyMatrix4(this.matrixWorld);\n\n\t\t\tif(_ray.intersectsSphere(sphere))\n\t\t\t{\n\t\t\t\tnodesOnRay.push(node);\n\t\t\t}\n\t\t}\n\n\t\treturn nodesOnRay;\n\t}\n\n\tupdateMatrixWorld(force)\n\t{\n\t\tif(this.matrixAutoUpdate === true) this.updateMatrix();\n\n\t\tif(this.matrixWorldNeedsUpdate === true || force === true)\n\t\t{\n\t\t\tif(!this.parent)\n\t\t\t{\n\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\t\t}\n\t}\n\n\thideDescendants(object)\n\t{\n\t\tvar stack = [];\n\t\tfor(var i = 0; i < object.children.length; i++)\n\t\t{\n\t\t\tvar child = object.children[i];\n\t\t\tif(child.visible)\n\t\t\t{\n\t\t\t\tstack.push(child);\n\t\t\t}\n\t\t}\n\n\t\twhile(stack.length > 0)\n\t\t{\n\t\t\tvar object = stack.shift();\n\n\t\t\tobject.visible = false;\n\n\t\t\tfor(var i = 0; i < object.children.length; i++)\n\t\t\t{\n\t\t\t\tvar child = object.children[i];\n\t\t\t\tif(child.visible)\n\t\t\t\t{\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmoveToOrigin()\n\t{\n\t\tthis.position.set(0, 0, 0);\n\t\tthis.updateMatrixWorld(true);\n\t\tvar box = this.boundingBox;\n\t\tvar transform = this.matrixWorld;\n\t\tvar tBox = HelperUtils.computeTransformedBoundingBox(box, transform);\n\n\t\tthis.position.set(0, 0, 0).sub(tBox.getCenter(new THREE.Vector3()));\n\t};\n\n\tmoveToGroundPlane()\n\t{\n\t\tthis.updateMatrixWorld(true);\n\t\tvar box = this.boundingBox;\n\t\tvar transform = this.matrixWorld;\n\t\tvar tBox = HelperUtils.computeTransformedBoundingBox(box, transform);\n\t\tthis.position.y += -tBox.min.y;\n\t};\n\n\tgetBoundingBoxWorld()\n\t{\n\t\tthis.updateMatrixWorld(true);\n\t\tvar box = this.boundingBox;\n\t\tvar transform = this.matrixWorld;\n\t\tvar tBox = HelperUtils.computeTransformedBoundingBox(box, transform);\n\n\t\treturn tBox;\n\t};\n\n\t/**\n\t * returns points inside the profile points\n\t *\n\t * maxDepth:\t\tsearch points up to the given octree depth\n\t *\n\t *\n\t * The return value is an array with all segments of the profile path\n\t *  var segment = {\n\t * \t\tstart: \tTHREE.Vector3,\n\t * \t\tend: \tTHREE.Vector3,\n\t * \t\tpoints: {}\n\t * \t\tproject: function()\n\t *  };\n\t *\n\t * The project() function inside each segment can be used to transform\n\t * that segments point coordinates to line up along the x-axis.\n\t *\n\t *\n\t */\n\tgetPointsInProfile(profile, maxDepth, callback)\n\t{\n\n\t\tvar points = {\n\t\t\tsegments: [],\n\t\t\tboundingBox: new THREE.Box3(),\n\t\t\tprojectedBoundingBox: new THREE.Box2()\n\t\t};\n\n\t\t//evaluate segments\n\t\tfor(var i = 0; i < profile.points.length - 1; i++)\n\t\t{\n\t\t\tvar start = profile.points[i];\n\t\t\tvar end = profile.points[i + 1];\n\t\t\tvar ps = this.getProfile(start, end, profile.width, maxDepth);\n\n\t\t\tvar segment = {\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tpoints: ps,\n\t\t\t\tproject: null\n\t\t\t};\n\n\t\t\tpoints.segments.push(segment);\n\n\t\t\tpoints.boundingBox.expandByPoint(ps.boundingBox.min);\n\t\t\tpoints.boundingBox.expandByPoint(ps.boundingBox.max);\n\t\t}\n\n\t\t//add projection functions to the segments\n\t\tvar mileage = new THREE.Vector3();\n\t\tfor(var i = 0; i < points.segments.length; i++)\n\t\t{\n\t\t\tvar segment = points.segments[i];\n\t\t\tvar start = segment.start;\n\t\t\tvar end = segment.end;\n\n\t\t\tvar project = (function(_start, _end, _mileage, _boundingBox)\n\t\t\t{\n\t\t\t\tvar start = _start;\n\t\t\t\tvar end = _end;\n\t\t\t\tvar mileage = _mileage;\n\t\t\t\tvar boundingBox = _boundingBox;\n\n\t\t\t\tvar xAxis = new THREE.Vector3(1, 0, 0);\n\t\t\t\tvar dir = new THREE.Vector3().subVectors(end, start);\n\t\t\t\tdir.y = 0;\n\t\t\t\tdir.normalize();\n\t\t\t\tvar alpha = Math.acos(xAxis.dot(dir));\n\t\t\t\tif(dir.z > 0)\n\t\t\t\t{\n\t\t\t\t\talpha = -alpha;\n\t\t\t\t}\n\n\t\t\t\treturn function(position)\n\t\t\t\t{\n\t\t\t\t\tvar toOrigin = new THREE.Matrix4().makeTranslation(-start.x, -boundingBox.min.y, -start.z);\n\t\t\t\t\tvar alignWithX = new THREE.Matrix4().makeRotationY(-alpha);\n\t\t\t\t\tvar applyMileage = new THREE.Matrix4().makeTranslation(mileage.x, 0, 0);\n\n\t\t\t\t\tvar pos = position.clone();\n\t\t\t\t\tpos.applyMatrix4(toOrigin);\n\t\t\t\t\tpos.applyMatrix4(alignWithX);\n\t\t\t\t\tpos.applyMatrix4(applyMileage);\n\n\t\t\t\t\treturn pos;\n\t\t\t\t};\n\t\t\t}(start, end, mileage.clone(), points.boundingBox.clone()));\n\n\t\t\tsegment.project = project;\n\n\t\t\tmileage.x += new THREE.Vector3(start.x, 0, start.z).distanceTo(new THREE.Vector3(end.x, 0, end.z));\n\t\t\tmileage.y += end.y - start.y;\n\t\t}\n\n\t\tpoints.projectedBoundingBox.min.x = 0;\n\t\tpoints.projectedBoundingBox.min.y = points.boundingBox.min.y;\n\t\tpoints.projectedBoundingBox.max.x = mileage.x;\n\t\tpoints.projectedBoundingBox.max.y = points.boundingBox.max.y;\n\n\t\treturn points;\n\t}\n\n\t/**\n\t * returns points inside the given profile bounds.\n\t *\n\t * start:\n\t * end:\n\t * width:\n\t * depth:\t\tsearch points up to the given octree depth\n\t * callback:\tif specified, points are loaded before searching\n\t *\n\t *\n\t */\n\tgetProfile(start, end, width, depth, callback)\n\t{\n\t\t//var request = new Potree.ProfileRequest(start, end, width, depth, callback);\n\t\t//this.profileRequests.push(request);\n\t};\n\n\tgetVisibleExtent()\n\t{\n\t\treturn this.visibleBounds.applyMatrix4(this.matrixWorld);\n\t};\n\n\t/**\n\t *\n\t *\n\t *\n\t * params.pickWindowSize:\tLook for points inside a pixel window of this size.\n\t * \t\t\t\t\t\t\tUse odd values: 1, 3, 5, ...\n\t *\n\t *\n\t * TODO: only draw pixels that are actually read with readPixels().\n\t *\n\t */\n\tpick(viewer, camera, ray, params = {})\n\t{\n\n\t\tvar renderer = viewer.renderer;\n\t\tvar pRenderer = viewer.pRenderer;\n\n\t\tperformance.mark(\"pick-start\");\n\n\t\tvar getVal = (a, b) => a !== undefined ? a : b;\n\n\t\tvar pickWindowSize = getVal(params.pickWindowSize, 17);\n\t\tvar pickOutsideClipRegion = getVal(params.pickOutsideClipRegion, false);\n\n\t\tvar size = renderer.getSize(new THREE.Vector3());\n\n\t\tvar width = Math.ceil(getVal(params.width, size.width));\n\t\tvar height = Math.ceil(getVal(params.height, size.height));\n\n\t\tvar pointSizeType = getVal(params.pointSizeType, this.material.pointSizeType);\n\t\tvar pointSize = getVal(params.pointSize, this.material.size);\n\n\t\tvar nodes = this.nodesOnRay(this.visibleNodes, ray);\n\n\t\tif(nodes.length === 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tif(!this.pickState)\n\t\t{\n\t\t\tvar scene = new THREE.Scene();\n\n\t\t\tvar material = new PointCloudMaterial();\n\t\t\tmaterial.pointColorType = PointColorType.POINT_INDEX;\n\n\t\t\tvar renderTarget = new THREE.WebGLRenderTarget(\n\t\t\t\t1, 1,\n\t\t\t\t{\n\t\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\t\t\tformat: THREE.RGBAFormat\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis.pickState = {\n\t\t\t\trenderTarget: renderTarget,\n\t\t\t\tmaterial: material,\n\t\t\t\tscene: scene\n\t\t\t};\n\t\t}\n\t\tvar pickState = this.pickState;\n\t\tvar pickMaterial = pickState.material;\n\n\t\t//Update pick material\n\t\tpickMaterial.pointSizeType = pointSizeType;\n\t\tpickMaterial.shape = this.material.shape;\n\n\t\tpickMaterial.size = pointSize;\n\t\tpickMaterial.uniforms.minSize.value = this.material.uniforms.minSize.value;\n\t\tpickMaterial.uniforms.maxSize.value = this.material.uniforms.maxSize.value;\n\t\tpickMaterial.classification = this.material.classification;\n\t\tif(params.pickClipped)\n\t\t{\n\t\t\tpickMaterial.clipBoxes = this.material.clipBoxes;\n\t\t\tif(this.material.clipTask === ClipTask.HIGHLIGHT)\n\t\t\t{\n\t\t\t\tpickMaterial.clipTask = ClipTask.NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpickMaterial.clipTask = this.material.clipTask;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpickMaterial.clipBoxes = [];\n\t\t}\n\n\t\tthis.updateMaterial(pickMaterial, nodes, camera, renderer);\n\n\t\tpickState.renderTarget.setSize(width, height);\n\n\t\tvar pixelPos = new THREE.Vector2(params.x, params.y);\n\n\t\tvar gl = renderer.getContext();\n\t\tgl.enable(gl.SCISSOR_TEST);\n\t\tgl.scissor(parseInt(pixelPos.x - (pickWindowSize - 1) / 2), parseInt(pixelPos.y - (pickWindowSize - 1) / 2), parseInt(pickWindowSize), parseInt(pickWindowSize));\n\n\t\trenderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n\t\trenderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\n\t\trenderer.state.setBlending(THREE.NoBlending);\n\n\t\t//Render\n\t\trenderer.setRenderTarget(pickState.renderTarget);\n\t\tgl.clearColor(0, 0, 0, 0);\n\t\trenderer.clearTarget(pickState.renderTarget, true, true, true);\n\n\t\tvar tmp = this.material;\n\t\tthis.material = pickMaterial;\n\n\t\tpRenderer.renderOctree(this, nodes, camera, pickState.renderTarget);\n\n\t\tthis.material = tmp;\n\n\t\tvar clamp = (number, min, max) => Math.min(Math.max(min, number), max);\n\n\t\tvar x = parseInt(clamp(pixelPos.x - (pickWindowSize - 1) / 2, 0, width));\n\t\tvar y = parseInt(clamp(pixelPos.y - (pickWindowSize - 1) / 2, 0, height));\n\t\tvar w = parseInt(Math.min(x + pickWindowSize, width) - x);\n\t\tvar h = parseInt(Math.min(y + pickWindowSize, height) - y);\n\n\t\tvar pixelCount = w * h;\n\t\tvar buffer = new Uint8Array(4 * pixelCount);\n\n\t\tgl.readPixels(x, y, pickWindowSize, pickWindowSize, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n\n\t\trenderer.setRenderTarget(null);\n\t\trenderer.resetGLState();\n\t\trenderer.setScissorTest(false);\n\t\tgl.disable(gl.SCISSOR_TEST);\n\n\t\tvar pixels = buffer;\n\t\tvar ibuffer = new Uint32Array(buffer.buffer);\n\t\tvar hits = [];\n\n\t\tfor(var u = 0; u < pickWindowSize; u++)\n\t\t{\n\t\t\tfor(var v = 0; v < pickWindowSize; v++)\n\t\t\t{\n\t\t\t\tvar offset = (u + v * pickWindowSize);\n\t\t\t\tvar distance = Math.pow(u - (pickWindowSize - 1) / 2, 2) + Math.pow(v - (pickWindowSize - 1) / 2, 2);\n\n\t\t\t\tvar pcIndex = pixels[4 * offset + 3];\n\t\t\t\tpixels[4 * offset + 3] = 0;\n\t\t\t\tvar pIndex = ibuffer[offset];\n\n\t\t\t\tif(!(pcIndex === 0 && pIndex === 0) && (pcIndex !== undefined) && (pIndex !== undefined))\n\t\t\t\t{\n\t\t\t\t\tvar hit = {\n\t\t\t\t\t\tpIndex: pIndex,\n\t\t\t\t\t\tpcIndex: pcIndex,\n\t\t\t\t\t\tdistanceToCenter: distance\n\t\t\t\t\t};\n\n\t\t\t\t\tif(params.all)\n\t\t\t\t\t{\n\t\t\t\t\t\thits.push(hit);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(hits.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(distance < hits[0].distanceToCenter)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thits[0] = hit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thits.push(hit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(var hit of hits)\n\t\t{\n\t\t\tvar point = {};\n\n\t\t\tif(!nodes[hit.pcIndex])\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar node = nodes[hit.pcIndex];\n\t\t\tvar pc = node.sceneNode;\n\t\t\tvar geometry = node.geometryNode.geometry;\n\n\t\t\tfor(var attributeName in geometry.attributes)\n\t\t\t{\n\t\t\t\tvar attribute = geometry.attributes[attributeName];\n\n\t\t\t\tif(attributeName === \"position\")\n\t\t\t\t{\n\t\t\t\t\tvar x = attribute.array[3 * hit.pIndex + 0];\n\t\t\t\t\tvar y = attribute.array[3 * hit.pIndex + 1];\n\t\t\t\t\tvar z = attribute.array[3 * hit.pIndex + 2];\n\n\t\t\t\t\tvar position = new THREE.Vector3(x, y, z);\n\t\t\t\t\tposition.applyMatrix4(pc.matrixWorld);\n\n\t\t\t\t\tpoint[attributeName] = position;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\telse if(attributeName === \"indices\")\n\t\t\t\t{\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//if (values.itemSize === 1) {\n\t\t\t\t\t//\tpoint[attribute.name] = values.array[hit.pIndex];\n\t\t\t\t\t//} else {\n\t\t\t\t\t//\tvar value = [];\n\t\t\t\t\t//\tfor (var j = 0; j < values.itemSize; j++) {\n\t\t\t\t\t//\t\tvalue.push(values.array[values.itemSize * hit.pIndex + j]);\n\t\t\t\t\t//\t}\n\t\t\t\t\t//\tpoint[attribute.name] = value;\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\thit.point = point;\n\t\t}\n\n\t\tperformance.mark(\"pick-end\");\n\t\tperformance.measure(\"pick\", \"pick-start\", \"pick-end\");\n\n\t\tif(params.all)\n\t\t{\n\t\t\treturn hits.map(hit => hit.point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(hits.length === 0)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn hits[0].point;\n\t\t\t\t//var sorted = hits.sort((a, b) => a.distanceToCenter - b.distanceToCenter);\n\t\t\t\t//return sorted[0].point;\n\t\t\t}\n\t\t}\n\n\t};\n\n\t*getFittedBoxGen(boxNode)\n\t{\n\t\tvar shrinkedLocalBounds = new THREE.Box3();\n\t\tvar worldToBox = new THREE.Matrix4().getInverse(boxNode.matrixWorld);\n\n\t\tfor(var node of this.visibleNodes)\n\t\t{\n\t\t\tif(!node.sceneNode)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar buffer = node.geometryNode.buffer;\n\n\t\t\tvar posOffset = buffer.offset(\"position\");\n\t\t\tvar stride = buffer.stride;\n\t\t\tvar view = new DataView(buffer.data);\n\n\t\t\tvar objectToBox = new THREE.Matrix4().multiplyMatrices(worldToBox, node.sceneNode.matrixWorld);\n\n\t\t\tvar pos = new THREE.Vector4();\n\t\t\tfor(var i = 0; i < buffer.numElements; i++)\n\t\t\t{\n\t\t\t\tvar x = view.getFloat32(i * stride + posOffset + 0, true);\n\t\t\t\tvar y = view.getFloat32(i * stride + posOffset + 4, true);\n\t\t\t\tvar z = view.getFloat32(i * stride + posOffset + 8, true);\n\n\t\t\t\tpos.set(x, y, z, 1);\n\t\t\t\tpos.applyMatrix4(objectToBox);\n\n\t\t\t\tif(-0.5 < pos.x && pos.x < 0.5)\n\t\t\t\t{\n\t\t\t\t\tif(-0.5 < pos.y && pos.y < 0.5)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(-0.5 < pos.z && pos.z < 0.5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshrinkedLocalBounds.expandByPoint(pos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tyield;\n\t\t}\n\n\n\t\tvar fittedPosition = shrinkedLocalBounds.getCenter(new THREE.Vector3()).applyMatrix4(boxNode.matrixWorld);\n\n\t\tvar fitted = new THREE.Object3D();\n\t\tfitted.position.copy(fittedPosition);\n\t\tfitted.scale.copy(boxNode.scale);\n\t\tfitted.rotation.copy(boxNode.rotation);\n\n\t\tvar ds = new THREE.Vector3().subVectors(shrinkedLocalBounds.max, shrinkedLocalBounds.min);\n\t\tfitted.scale.multiply(ds);\n\n\t\tyield fitted;\n\t}\n\n\tgetFittedBox(boxNode, maxLevel = Infinity)\n\t{\n\t\tvar shrinkedLocalBounds = new THREE.Box3();\n\t\tvar worldToBox = new THREE.Matrix4().getInverse(boxNode.matrixWorld);\n\n\t\tfor(var node of this.visibleNodes)\n\t\t{\n\t\t\tif(!node.sceneNode || node.getLevel() > maxLevel)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar buffer = node.geometryNode.buffer;\n\n\t\t\tvar posOffset = buffer.offset(\"position\");\n\t\t\tvar stride = buffer.stride;\n\t\t\tvar view = new DataView(buffer.data);\n\n\t\t\tvar objectToBox = new THREE.Matrix4().multiplyMatrices(worldToBox, node.sceneNode.matrixWorld);\n\n\t\t\tvar pos = new THREE.Vector4();\n\t\t\tfor(var i = 0; i < buffer.numElements; i++)\n\t\t\t{\n\t\t\t\tvar x = view.getFloat32(i * stride + posOffset + 0, true);\n\t\t\t\tvar y = view.getFloat32(i * stride + posOffset + 4, true);\n\t\t\t\tvar z = view.getFloat32(i * stride + posOffset + 8, true);\n\n\t\t\t\tpos.set(x, y, z, 1);\n\t\t\t\tpos.applyMatrix4(objectToBox);\n\n\t\t\t\tif(-0.5 < pos.x && pos.x < 0.5)\n\t\t\t\t{\n\t\t\t\t\tif(-0.5 < pos.y && pos.y < 0.5)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(-0.5 < pos.z && pos.z < 0.5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshrinkedLocalBounds.expandByPoint(pos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar fittedPosition = shrinkedLocalBounds.getCenter(new THREE.Vector3()).applyMatrix4(boxNode.matrixWorld);\n\n\t\tvar fitted = new THREE.Object3D();\n\t\tfitted.position.copy(fittedPosition);\n\t\tfitted.scale.copy(boxNode.scale);\n\t\tfitted.rotation.copy(boxNode.rotation);\n\n\t\tvar ds = new THREE.Vector3().subVectors(shrinkedLocalBounds.max, shrinkedLocalBounds.min);\n\t\tfitted.scale.multiply(ds);\n\n\t\treturn fitted;\n\t}\n\n\tget progress()\n\t{\n\t\treturn this.visibleNodes.length / this.visibleGeometry.length;\n\t}\n\n\tfind(name)\n\t{\n\t\tvar node = null;\n\t\tfor(var char of name)\n\t\t{\n\t\t\tif(char === \"r\")\n\t\t\t{\n\t\t\t\tnode = this.root;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = node.children[char];\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\nclass PointCloudArena4DNode extends PointCloudTreeNode\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.sceneNode = null;\n\t\tthis.kdtree = null;\n\t}\n\n\tgetNumPoints()\n\t{\n\t\treturn this.geometryNode.numPoints;\n\t}\n\n\tisLoaded()\n\t{\n\t\treturn true;\n\t}\n\n\tisTreeNode()\n\t{\n\t\treturn true;\n\t}\n\n\tisGeometryNode()\n\t{\n\t\treturn false;\n\t}\n\n\tgetLevel()\n\t{\n\t\treturn this.geometryNode.level;\n\t}\n\n\tgetBoundingSphere()\n\t{\n\t\treturn this.geometryNode.boundingSphere;\n\t}\n\n\tgetBoundingBox()\n\t{\n\t\treturn this.geometryNode.boundingBox;\n\t}\n\n\ttoTreeNode(child)\n\t{\n\t\tvar geometryNode = null;\n\n\t\tif(this.left === child)\n\t\t{\n\t\t\tgeometryNode = this.left;\n\t\t}\n\t\telse if(this.right === child)\n\t\t{\n\t\t\tgeometryNode = this.right;\n\t\t}\n\n\t\tif(!geometryNode.loaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar node = new PointCloudArena4DNode();\n\t\tvar sceneNode = THREE.PointCloud(geometryNode.geometry, this.kdtree.material);\n\t\tsceneNode.visible = false;\n\n\t\tnode.kdtree = this.kdtree;\n\t\tnode.geometryNode = geometryNode;\n\t\tnode.sceneNode = sceneNode;\n\t\tnode.parent = this;\n\t\tnode.left = this.geometryNode.left;\n\t\tnode.right = this.geometryNode.right;\n\t}\n\n\tgetChildren()\n\t{\n\t\tvar children = [];\n\n\t\tif(this.left)\n\t\t{\n\t\t\tchildren.push(this.left);\n\t\t}\n\n\t\tif(this.right)\n\t\t{\n\t\t\tchildren.push(this.right);\n\t\t}\n\n\t\treturn children;\n\t}\n}\nclass PointCloudArena4D extends PointCloudTree\n{\n\tconstructor(geometry)\n\t{\n\t\tsuper();\n\n\t\tthis.root = null;\n\t\tif(geometry.root)\n\t\t{\n\t\t\tthis.root = geometry.root;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeometry.addEventListener(\"hierarchy_loaded\", () =>\n\t\t\t{\n\t\t\t\tthis.root = geometry.root;\n\t\t\t});\n\t\t}\n\n\t\tthis.visiblePointsTarget = 2 * 1000 * 1000;\n\t\tthis.minimumNodePixelSize = 150;\n\n\t\tthis.position.sub(geometry.offset);\n\t\tthis.updateMatrix();\n\n\t\tthis.numVisibleNodes = 0;\n\t\tthis.numVisiblePoints = 0;\n\n\t\tthis.boundingBoxNodes = [];\n\t\tthis.loadQueue = [];\n\t\tthis.visibleNodes = [];\n\n\t\tthis.pcoGeometry = geometry;\n\t\tthis.boundingBox = this.pcoGeometry.boundingBox;\n\t\tthis.boundingSphere = this.pcoGeometry.boundingSphere;\n\t\tthis.material = new PointCloudMaterial(\n\t\t{\n\t\t\tvertexColors: THREE.VertexColors,\n\t\t\tsize: 0.05,\n\t\t\ttreeType: TreeType.KDTREE\n\t\t});\n\t\tthis.material.sizeType = PointSizeType.ATTENUATED;\n\t\tthis.material.size = 0.05;\n\t\tthis.profileRequests = [];\n\t\tthis.name = \"\";\n\t}\n\n\tgetBoundingBoxWorld()\n\t{\n\t\tthis.updateMatrixWorld(true);\n\t\tvar box = this.boundingBox;\n\t\tvar transform = this.matrixWorld;\n\t\tvar tBox = HelperUtils.computeTransformedBoundingBox(box, transform);\n\n\t\treturn tBox;\n\t};\n\n\tsetName(name)\n\t{\n\t\tif(this.name !== name)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"name_changed\",\n\t\t\t\tname: name,\n\t\t\t\tpointcloud: this\n\t\t\t});\n\t\t}\n\t}\n\n\tgetName()\n\t{\n\t\treturn this.name;\n\t}\n\n\tgetLevel()\n\t{\n\t\treturn this.level;\n\t}\n\n\ttoTreeNode(geometryNode, parent)\n\t{\n\t\tvar node = new PointCloudArena4DNode();\n\n\t\tvar sceneNode = new THREE.Points(geometryNode.geometry, this.material);\n\t\tsceneNode.frustumCulled = true;\n\t\tsceneNode.onBeforeRender = (_this, scene, camera, geometry, material, group) =>\n\t\t{\n\t\t\tif(material.program)\n\t\t\t{\n\t\t\t\t_this.getContext().useProgram(material.program.program);\n\n\t\t\t\tif(material.program.getUniforms().map.level)\n\t\t\t\t{\n\t\t\t\t\tvar level = geometryNode.getLevel();\n\t\t\t\t\tmaterial.uniforms.level.value = level;\n\t\t\t\t\tmaterial.program.getUniforms().map.level.setValue(_this.getContext(), level);\n\t\t\t\t}\n\n\t\t\t\tif(this.visibleNodeTextureOffsets && material.program.getUniforms().map.vnStart)\n\t\t\t\t{\n\t\t\t\t\tvar vnStart = this.visibleNodeTextureOffsets.get(node);\n\t\t\t\t\tmaterial.uniforms.vnStart.value = vnStart;\n\t\t\t\t\tmaterial.program.getUniforms().map.vnStart.setValue(_this.getContext(), vnStart);\n\t\t\t\t}\n\n\t\t\t\tif(material.program.getUniforms().map.pcIndex)\n\t\t\t\t{\n\t\t\t\t\tvar i = node.pcIndex ? node.pcIndex : this.visibleNodes.indexOf(node);\n\t\t\t\t\tmaterial.uniforms.pcIndex.value = i;\n\t\t\t\t\tmaterial.program.getUniforms().map.pcIndex.setValue(_this.getContext(), i);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tnode.geometryNode = geometryNode;\n\t\tnode.sceneNode = sceneNode;\n\t\tnode.pointcloud = this;\n\t\tnode.left = geometryNode.left;\n\t\tnode.right = geometryNode.right;\n\n\t\tif(!parent)\n\t\t{\n\t\t\tthis.root = node;\n\t\t\tthis.add(sceneNode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.sceneNode.add(sceneNode);\n\n\t\t\tif(parent.left === geometryNode)\n\t\t\t{\n\t\t\t\tparent.left = node;\n\t\t\t}\n\t\t\telse if(parent.right === geometryNode)\n\t\t\t{\n\t\t\t\tparent.right = node;\n\t\t\t}\n\t\t}\n\n\t\tvar disposeListener = function()\n\t\t{\n\t\t\tparent.sceneNode.remove(node.sceneNode);\n\n\t\t\tif(parent.left === node)\n\t\t\t{\n\t\t\t\tparent.left = geometryNode;\n\t\t\t}\n\t\t\telse if(parent.right === node)\n\t\t\t{\n\t\t\t\tparent.right = geometryNode;\n\t\t\t}\n\t\t};\n\t\tgeometryNode.oneTimeDisposeHandlers.push(disposeListener);\n\n\t\treturn node;\n\t}\n\n\tupdateMaterial(material, visibleNodes, camera, renderer)\n\t{\n\t\tmaterial.fov = camera.fov * (Math.PI / 180);\n\t\tmaterial.screenWidth = renderer.domElement.clientWidth;\n\t\tmaterial.screenHeight = renderer.domElement.clientHeight;\n\t\tmaterial.spacing = this.pcoGeometry.spacing;\n\t\tmaterial.near = camera.near;\n\t\tmaterial.far = camera.far;\n\n\t\t//reduce shader source updates by setting maxLevel slightly higher than actually necessary\n\t\tif(this.maxLevel > material.levels)\n\t\t{\n\t\t\tmaterial.levels = this.maxLevel + 2;\n\t\t}\n\n\t\t//material.uniforms.octreeSize.value = this.boundingBox.size().x;\n\t\tvar bbSize = this.boundingBox.getSize(new THREE.Vector3());\n\t\tmaterial.bbSize = [bbSize.x, bbSize.y, bbSize.z];\n\t}\n\n\tupdateVisibleBounds()\n\t{\n\n\t}\n\n\thideDescendants(object)\n\t{\n\t\tvar stack = [];\n\t\tfor(var i = 0; i < object.children.length; i++)\n\t\t{\n\t\t\tvar child = object.children[i];\n\t\t\tif(child.visible)\n\t\t\t{\n\t\t\t\tstack.push(child);\n\t\t\t}\n\t\t}\n\n\t\twhile(stack.length > 0)\n\t\t{\n\t\t\tvar child = stack.shift();\n\n\t\t\tchild.visible = false;\n\t\t\tif(child.boundingBoxNode)\n\t\t\t{\n\t\t\t\tchild.boundingBoxNode.visible = false;\n\t\t\t}\n\n\t\t\tfor(var i = 0; i < child.children.length; i++)\n\t\t\t{\n\t\t\t\tvar childOfChild = child.children[i];\n\t\t\t\tif(childOfChild.visible)\n\t\t\t\t{\n\t\t\t\t\tstack.push(childOfChild);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tupdateMatrixWorld(force)\n\t{\n\t\t//node.matrixWorld.multiplyMatrices( node.parent.matrixWorld, node.matrix );\n\n\t\tif(this.matrixAutoUpdate === true) this.updateMatrix();\n\n\t\tif(this.matrixWorldNeedsUpdate === true || force === true)\n\t\t{\n\t\t\tif(this.parent === undefined)\n\t\t\t{\n\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\t\t}\n\t}\n\n\tnodesOnRay(nodes, ray)\n\t{\n\t\tvar nodesOnRay = [];\n\n\t\tvar _ray = ray.clone();\n\t\tfor(var i = 0; i < nodes.length; i++)\n\t\t{\n\t\t\tvar node = nodes[i];\n\t\t\tvar sphere = node.getBoundingSphere(new THREE.Sphere()).clone().applyMatrix4(node.sceneNode.matrixWorld);\n\t\t\t//TODO Unused: var box = node.getBoundingBox().clone().applyMatrix4(node.sceneNode.matrixWorld);\n\n\t\t\tif(_ray.intersectsSphere(sphere))\n\t\t\t{\n\t\t\t\tnodesOnRay.push(node);\n\t\t\t}\n\t\t\t//if(_ray.isIntersectionBox(box)){\n\t\t\t//\tnodesOnRay.push(node);\n\t\t\t//}\n\t\t}\n\n\t\treturn nodesOnRay;\n\t}\n\n\tpick(viewer, camera, ray, params = {})\n\t{\n\n\t\tvar renderer = viewer.renderer;\n\t\tvar pRenderer = viewer.pRenderer;\n\n\t\tperformance.mark(\"pick-start\");\n\n\t\tvar getVal = (a, b) => a !== undefined ? a : b;\n\n\t\tvar pickWindowSize = getVal(params.pickWindowSize, 17);\n\t\tvar pickOutsideClipRegion = getVal(params.pickOutsideClipRegion, false);\n\n\t\tvar size = renderer.getSize(new THREE.Vector3());\n\n\t\tvar width = Math.ceil(getVal(params.width, size.width));\n\t\tvar height = Math.ceil(getVal(params.height, size.height));\n\n\t\tvar pointSizeType = getVal(params.pointSizeType, this.material.pointSizeType);\n\t\tvar pointSize = getVal(params.pointSize, this.material.size);\n\n\t\tvar nodes = this.nodesOnRay(this.visibleNodes, ray);\n\n\t\tif(nodes.length === 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tif(!this.pickState)\n\t\t{\n\t\t\tvar scene = new THREE.Scene();\n\n\t\t\tvar material = new PointCloudMaterial();\n\t\t\tmaterial.pointColorType = PointColorType.POINT_INDEX;\n\n\t\t\tvar renderTarget = new THREE.WebGLRenderTarget(\n\t\t\t\t1, 1,\n\t\t\t\t{\n\t\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\t\t\tformat: THREE.RGBAFormat\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tthis.pickState = {\n\t\t\t\trenderTarget: renderTarget,\n\t\t\t\tmaterial: material,\n\t\t\t\tscene: scene\n\t\t\t};\n\t\t}\n\t\tvar pickState = this.pickState;\n\t\tvar pickMaterial = pickState.material;\n\t\tpickMaterial.pointSizeType = pointSizeType;\n\t\tpickMaterial.shape = this.material.shape;\n\n\t\tpickMaterial.size = pointSize;\n\t\tpickMaterial.uniforms.minSize.value = this.material.uniforms.minSize.value;\n\t\tpickMaterial.uniforms.maxSize.value = this.material.uniforms.maxSize.value;\n\t\tpickMaterial.classification = this.material.classification;\n\t\tif(params.pickClipped)\n\t\t{\n\t\t\tpickMaterial.clipBoxes = this.material.clipBoxes;\n\t\t\tif(this.material.clipTask === ClipTask.HIGHLIGHT)\n\t\t\t{\n\t\t\t\tpickMaterial.clipTask = ClipTask.NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpickMaterial.clipTask = this.material.clipTask;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpickMaterial.clipBoxes = [];\n\t\t}\n\n\t\tthis.updateMaterial(pickMaterial, nodes, camera, renderer);\n\n\t\tpickState.renderTarget.setSize(width, height);\n\n\t\tvar pixelPos = new THREE.Vector2(params.x, params.y);\n\n\t\tvar gl = renderer.getContext();\n\t\tgl.enable(gl.SCISSOR_TEST);\n\t\tgl.scissor(parseInt(pixelPos.x - (pickWindowSize - 1) / 2), parseInt(pixelPos.y - (pickWindowSize - 1) / 2), parseInt(pickWindowSize), parseInt(pickWindowSize));\n\n\t\trenderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n\t\trenderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\n\t\trenderer.state.setBlending(THREE.NoBlending);\n\n\t\trenderer.clearTarget(pickState.renderTarget, true, true, true);\n\t\trenderer.setRenderTarget(pickState.renderTarget);\n\t\t\n\t\tgl.clearColor(0, 0, 0, 0);\n\t\trenderer.clearTarget(pickState.renderTarget, true, true, true);\n\n\t\tvar tmp = this.material;\n\t\tthis.material = pickMaterial;\n\n\t\tpRenderer.renderOctree(this, nodes, camera, pickState.renderTarget);\n\n\t\tthis.material = tmp;\n\n\t\tvar clamp = (number, min, max) => Math.min(Math.max(min, number), max);\n\n\t\tvar x = parseInt(clamp(pixelPos.x - (pickWindowSize - 1) / 2, 0, width));\n\t\tvar y = parseInt(clamp(pixelPos.y - (pickWindowSize - 1) / 2, 0, height));\n\t\tvar w = parseInt(Math.min(x + pickWindowSize, width) - x);\n\t\tvar h = parseInt(Math.min(y + pickWindowSize, height) - y);\n\n\t\tvar pixelCount = w * h;\n\t\tvar buffer = new Uint8Array(4 * pixelCount);\n\n\t\tgl.readPixels(x, y, pickWindowSize, pickWindowSize, gl.RGBA, gl.UNSIGNED_BYTE, buffer);\n\n\t\trenderer.setRenderTarget(null);\n\t\trenderer.resetGLState();\n\t\trenderer.setScissorTest(false);\n\t\tgl.disable(gl.SCISSOR_TEST);\n\n\t\tvar pixels = buffer;\n\t\tvar ibuffer = new Uint32Array(buffer.buffer);\n\t\tvar hits = [];\n\t\tfor(var u = 0; u < pickWindowSize; u++)\n\t\t{\n\t\t\tfor(var v = 0; v < pickWindowSize; v++)\n\t\t\t{\n\t\t\t\tvar offset = (u + v * pickWindowSize);\n\t\t\t\tvar distance = Math.pow(u - (pickWindowSize - 1) / 2, 2) + Math.pow(v - (pickWindowSize - 1) / 2, 2);\n\n\t\t\t\tvar pcIndex = pixels[4 * offset + 3];\n\t\t\t\tpixels[4 * offset + 3] = 0;\n\t\t\t\tvar pIndex = ibuffer[offset];\n\n\t\t\t\tif(!(pcIndex === 0 && pIndex === 0) && (pcIndex !== undefined) && (pIndex !== undefined))\n\t\t\t\t{\n\t\t\t\t\tvar hit = {\n\t\t\t\t\t\tpIndex: pIndex,\n\t\t\t\t\t\tpcIndex: pcIndex,\n\t\t\t\t\t\tdistanceToCenter: distance\n\t\t\t\t\t};\n\n\t\t\t\t\tif(params.all)\n\t\t\t\t\t{\n\t\t\t\t\t\thits.push(hit);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(hits.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(distance < hits[0].distanceToCenter)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\thits[0] = hit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thits.push(hit);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(var hit of hits)\n\t\t{\n\t\t\tvar point = {};\n\n\t\t\tif(!nodes[hit.pcIndex])\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar node = nodes[hit.pcIndex];\n\t\t\tvar pc = node.sceneNode;\n\t\t\tvar geometry = node.geometryNode.geometry;\n\n\t\t\tfor(var attributeName in geometry.attributes)\n\t\t\t{\n\t\t\t\tvar attribute = geometry.attributes[attributeName];\n\n\t\t\t\tif(attributeName === \"position\")\n\t\t\t\t{\n\t\t\t\t\tvar x = attribute.array[3 * hit.pIndex + 0];\n\t\t\t\t\tvar y = attribute.array[3 * hit.pIndex + 1];\n\t\t\t\t\tvar z = attribute.array[3 * hit.pIndex + 2];\n\n\t\t\t\t\tvar position = new THREE.Vector3(x, y, z);\n\t\t\t\t\tposition.applyMatrix4(pc.matrixWorld);\n\n\t\t\t\t\tpoint[attributeName] = position;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thit.point = point;\n\t\t}\n\n\t\tperformance.mark(\"pick-end\");\n\t\tperformance.measure(\"pick\", \"pick-start\", \"pick-end\");\n\n\t\tif(params.all)\n\t\t{\n\t\t\treturn hits.map(hit => hit.point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(hits.length === 0)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn hits[0].point;\n\t\t\t}\n\t\t}\n\t}\n\n\tcomputeVisibilityTextureData(nodes)\n\t{\n\t\tif(Global.measureTimings)\n\t\t{\n\t\t\tperformance.mark(\"computeVisibilityTextureData-start\");\n\t\t}\n\n\t\tvar data = new Uint8Array(nodes.length * 3);\n\t\tvar visibleNodeTextureOffsets = new Map();\n\n\t\t//copy array\n\t\tnodes = nodes.slice();\n\n\t\t//sort by level and number\n\t\tvar sort = function(a, b)\n\t\t{\n\t\t\tvar la = a.geometryNode.level;\n\t\t\tvar lb = b.geometryNode.level;\n\t\t\tvar na = a.geometryNode.number;\n\t\t\tvar nb = b.geometryNode.number;\n\t\t\tif(la !== lb) return la - lb;\n\t\t\tif(na < nb) return -1;\n\t\t\tif(na > nb) return 1;\n\t\t\treturn 0;\n\t\t};\n\t\tnodes.sort(sort);\n\n\t\tvar visibleNodeNames = [];\n\t\tfor(var i = 0; i < nodes.length; i++)\n\t\t{\n\t\t\tvisibleNodeNames.push(nodes[i].geometryNode.number);\n\t\t}\n\n\t\tfor(var i = 0; i < nodes.length; i++)\n\t\t{\n\t\t\tvar node = nodes[i];\n\n\t\t\tvisibleNodeTextureOffsets.set(node, i);\n\n\t\t\tvar b1 = 0; //children\n\t\t\tvar b2 = 0; //offset to first child\n\t\t\tvar b3 = 0; //split\n\n\t\t\tif(node.geometryNode.left && visibleNodeNames.indexOf(node.geometryNode.left.number) > 0)\n\t\t\t{\n\t\t\t\tb1 += 1;\n\t\t\t\tb2 = visibleNodeNames.indexOf(node.geometryNode.left.number) - i;\n\t\t\t}\n\t\t\tif(node.geometryNode.right && visibleNodeNames.indexOf(node.geometryNode.right.number) > 0)\n\t\t\t{\n\t\t\t\tb1 += 2;\n\t\t\t\tb2 = (b2 === 0) ? visibleNodeNames.indexOf(node.geometryNode.right.number) - i : b2;\n\t\t\t}\n\n\t\t\tif(node.geometryNode.split === \"X\")\n\t\t\t{\n\t\t\t\tb3 = 1;\n\t\t\t}\n\t\t\telse if(node.geometryNode.split === \"Y\")\n\t\t\t{\n\t\t\t\tb3 = 2;\n\t\t\t}\n\t\t\telse if(node.geometryNode.split === \"Z\")\n\t\t\t{\n\t\t\t\tb3 = 4;\n\t\t\t}\n\n\t\t\tdata[i * 3 + 0] = b1;\n\t\t\tdata[i * 3 + 1] = b2;\n\t\t\tdata[i * 3 + 2] = b3;\n\t\t}\n\n\t\tif(Global.measureTimings)\n\t\t{\n\t\t\tperformance.mark(\"computeVisibilityTextureData-end\");\n\t\t\tperformance.measure(\"render.computeVisibilityTextureData\", \"computeVisibilityTextureData-start\", \"computeVisibilityTextureData-end\");\n\t\t}\n\n\t\treturn {\n\t\t\tdata: data,\n\t\t\toffsets: visibleNodeTextureOffsets\n\t\t};\n\t}\n\n\tget progress()\n\t{\n\t\tif(this.pcoGeometry.root)\n\t\t{\n\t\t\treturn Global.numNodesLoading > 0 ? 0 : 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nclass PointCloudArena4DGeometryNode\n{\n\tconstructor()\n\t{\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.boundingBox = null;\n\t\tthis.number = null;\n\t\tthis.pcoGeometry = null;\n\t\tthis.loaded = false;\n\t\tthis.numPoints = 0;\n\t\tthis.level = 0;\n\t\tthis.children = [];\n\t\tthis.oneTimeDisposeHandlers = [];\n\t}\n\n\tisGeometryNode()\n\t{\n\t\treturn true;\n\t}\n\n\tisTreeNode()\n\t{\n\t\treturn false;\n\t}\n\n\tisLoaded()\n\t{\n\t\treturn this.loaded;\n\t}\n\n\tgetBoundingSphere()\n\t{\n\t\treturn this.boundingSphere;\n\t}\n\n\tgetBoundingBox()\n\t{\n\t\treturn this.boundingBox;\n\t}\n\n\tgetChildren()\n\t{\n\t\tvar children = [];\n\n\t\tif(this.left)\n\t\t{\n\t\t\tchildren.push(this.left);\n\t\t}\n\n\t\tif(this.right)\n\t\t{\n\t\t\tchildren.push(this.right);\n\t\t}\n\n\t\treturn children;\n\t}\n\n\tgetLevel()\n\t{\n\t\treturn this.level;\n\t}\n\n\tload()\n\t{\n\t\tif(this.loaded || this.loading)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif(Global.numNodesLoading >= Global.maxNodesLoading)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.loading = true;\n\n\t\tGlobal.numNodesLoading++;\n\n\t\tvar self = this;\n\t\tvar url = this.pcoGeometry.url + \"?node=\" + this.number;\n\t\t\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\t\txhr.onload = function()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar buffer = xhr.response;\n\t\t\t\tvar sourceView = new DataView(buffer);\n\t\t\t\tvar numPoints = buffer.byteLength / 17;\n\t\t\t\tvar bytesPerPoint = 28;\n\n\t\t\t\tvar data = new ArrayBuffer(numPoints * bytesPerPoint);\n\t\t\t\tvar targetView = new DataView(data);\n\n\t\t\t\tvar attributes = [\n\t\t\t\t\tPointAttribute.POSITION_CARTESIAN,\n\t\t\t\t\tPointAttribute.RGBA_PACKED,\n\t\t\t\t\tPointAttribute.INTENSITY,\n\t\t\t\t\tPointAttribute.CLASSIFICATION,\n\t\t\t\t];\n\n\t\t\t\tvar position = new Float32Array(numPoints * 3);\n\t\t\t\tvar color = new Uint8Array(numPoints * 4);\n\t\t\t\tvar intensities = new Float32Array(numPoints);\n\t\t\t\tvar classifications = new Uint8Array(numPoints);\n\t\t\t\tvar indices = new ArrayBuffer(numPoints * 4);\n\t\t\t\tvar u32Indices = new Uint32Array(indices);\n\n\t\t\t\tvar tightBoundingBox = new THREE.Box3();\n\n\t\t\t\tfor(var i = 0; i < numPoints; i++)\n\t\t\t\t{\n\t\t\t\t\tvar x = sourceView.getFloat32(i * 17 + 0, true) + self.boundingBox.min.x;\n\t\t\t\t\tvar y = sourceView.getFloat32(i * 17 + 4, true) + self.boundingBox.min.y;\n\t\t\t\t\tvar z = sourceView.getFloat32(i * 17 + 8, true) + self.boundingBox.min.z;\n\n\t\t\t\t\tvar r = sourceView.getUint8(i * 17 + 12, true);\n\t\t\t\t\tvar g = sourceView.getUint8(i * 17 + 13, true);\n\t\t\t\t\tvar b = sourceView.getUint8(i * 17 + 14, true);\n\n\t\t\t\t\tvar intensity = sourceView.getUint8(i * 17 + 15, true);\n\n\t\t\t\t\tvar classification = sourceView.getUint8(i * 17 + 16, true);\n\n\t\t\t\t\ttightBoundingBox.expandByPoint(new THREE.Vector3(x, y, z));\n\n\t\t\t\t\tposition[i * 3 + 0] = x;\n\t\t\t\t\tposition[i * 3 + 1] = y;\n\t\t\t\t\tposition[i * 3 + 2] = z;\n\n\t\t\t\t\tcolor[i * 4 + 0] = r;\n\t\t\t\t\tcolor[i * 4 + 1] = g;\n\t\t\t\t\tcolor[i * 4 + 2] = b;\n\t\t\t\t\tcolor[i * 4 + 3] = 255;\n\n\t\t\t\t\tintensities[i] = intensity;\n\t\t\t\t\tclassifications[i] = classification;\n\n\t\t\t\t\tu32Indices[i] = i;\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute(\"position\", new THREE.BufferAttribute(position, 3));\n\t\t\t\tgeometry.setAttribute(\"color\", new THREE.BufferAttribute(color, 4, true));\n\t\t\t\tgeometry.setAttribute(\"intensity\", new THREE.BufferAttribute(intensities, 1));\n\t\t\t\tgeometry.setAttribute(\"classification\", new THREE.BufferAttribute(classifications, 1));\n\t\t\t\t{\n\t\t\t\t\tvar bufferAttribute = new THREE.BufferAttribute(new Uint8Array(indices), 4, true);\n\t\t\t\t\tgeometry.setAttribute(\"indices\", bufferAttribute);\n\t\t\t\t}\n\n\t\t\t\tself.geometry = geometry;\n\t\t\t\tself.numPoints = numPoints;\n\t\t\t\tself.loaded = true;\n\t\t\t\tself.loading = false;\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tconsole.error(\"Potree: Exception thrown parsing points.\", e);\n\t\t\t\tGlobal.numNodesLoading--;\n\t\t\t}\n\n\t\t};\n\t\txhr.onerror = function()\n\t\t{\n\t\t\tGlobal.numNodesLoading--;\n\t\t\tconsole.log(\"Potree: Failed to load file, \" + xhr.status + \", file: \" + url);\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\tdispose()\n\t{\n\t\tif(this.geometry && this.parent != null)\n\t\t{\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.geometry = null;\n\t\t\tthis.loaded = false;\n\n\t\t\t//this.dispatchEvent( { type: \"dispose\" } );\n\t\t\tfor(var i = 0; i < this.oneTimeDisposeHandlers.length; i++)\n\t\t\t{\n\t\t\t\tvar handler = this.oneTimeDisposeHandlers[i];\n\t\t\t\thandler();\n\t\t\t}\n\t\t\tthis.oneTimeDisposeHandlers = [];\n\t\t}\n\t}\n\n\tgetNumPoints()\n\t{\n\t\treturn this.numPoints;\n\t}\n}\nclass PointCloudArena4DGeometry extends THREE.EventDispatcher\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis.numPoints = 0;\n\t\tthis.version = 0;\n\t\tthis.boundingBox = null;\n\t\tthis.numNodes = 0;\n\t\tthis.name = null;\n\t\tthis.provider = null;\n\t\tthis.url = null;\n\t\tthis.root = null;\n\t\tthis.levels = 0;\n\t\tthis._spacing = null;\n\t\tthis.pointAttributes = new PointAttributes([\n\t\t\t\"POSITION_CARTESIAN\",\n\t\t\t\"COLOR_PACKED\"\n\t\t]);\n\t}\n\n\tstatic load(url, callback)\n\t{\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url + \"?info\", true);\n\n\t\txhr.onreadystatechange = function()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif(xhr.readyState === 4 && xhr.status === 200)\n\t\t\t\t{\n\t\t\t\t\tvar response = JSON.parse(xhr.responseText);\n\n\t\t\t\t\tvar geometry = new PointCloudArena4DGeometry();\n\t\t\t\t\tgeometry.url = url;\n\t\t\t\t\tgeometry.name = response.Name;\n\t\t\t\t\tgeometry.provider = response.Provider;\n\t\t\t\t\tgeometry.numNodes = response.Nodes;\n\t\t\t\t\tgeometry.numPoints = response.Points;\n\t\t\t\t\tgeometry.version = response.Version;\n\t\t\t\t\tgeometry.boundingBox = new THREE.Box3(\n\t\t\t\t\t\tnew THREE.Vector3().fromArray(response.BoundingBox.slice(0, 3)),\n\t\t\t\t\t\tnew THREE.Vector3().fromArray(response.BoundingBox.slice(3, 6))\n\t\t\t\t\t);\n\t\t\t\t\tif(response.Spacing)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeometry.spacing = response.Spacing;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset = geometry.boundingBox.min.clone().multiplyScalar(-1);\n\n\t\t\t\t\tgeometry.boundingBox.min.add(offset);\n\t\t\t\t\tgeometry.boundingBox.max.add(offset);\n\t\t\t\t\tgeometry.offset = offset;\n\n\t\t\t\t\tvar center = new THREE.Vector3();\n\t\t\t\t\tgeometry.boundingBox.getCenter(center);\n\t\t\t\t\tvar radius = geometry.boundingBox.getSize(new THREE.Vector3()).length() / 2;\n\t\t\t\t\tgeometry.boundingSphere = new THREE.Sphere(center, radius);\n\n\t\t\t\t\tgeometry.loadHierarchy();\n\n\t\t\t\t\tcallback(geometry);\n\t\t\t\t}\n\t\t\t\telse if(xhr.readyState === 4)\n\t\t\t\t{\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(e)\n\t\t\t{\n\t\t\t\tconsole.error(e.message);\n\t\t\t\tcallback(null);\n\t\t\t}\n\t\t};\n\n\t\txhr.send(null);\n\t};\n\n\tloadHierarchy()\n\t{\n\t\tvar url = this.url + \"?tree\";\n\t\t\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.overrideMimeType(\"text/plain\");\n\t\txhr.open(\"GET\", url, true);\n\t\txhr.responseType = \"arraybuffer\";\n\n\t\txhr.onreadystatechange = () =>\n\t\t{\n\t\t\tif(!(xhr.readyState === 4 && xhr.status === 200))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar buffer = xhr.response;\n\t\t\tvar numNodes = buffer.byteLength / 3;\n\t\t\tvar view = new DataView(buffer);\n\t\t\tvar stack = [];\n\t\t\tvar root = null;\n\n\t\t\tvar levels = 0;\n\n\t\t\t//TODO Debug: var start = new Date().getTime();\n\t\t\t//read hierarchy\n\t\t\tfor(var i = 0; i < numNodes; i++)\n\t\t\t{\n\t\t\t\tvar mask = view.getUint8(i * 3 + 0, true);\n\n\t\t\t\tvar hasLeft = (mask & 1) > 0;\n\t\t\t\tvar hasRight = (mask & 2) > 0;\n\t\t\t\tvar splitX = (mask & 4) > 0;\n\t\t\t\tvar splitY = (mask & 8) > 0;\n\t\t\t\tvar splitZ = (mask & 16) > 0;\n\t\t\t\tvar split = null;\n\t\t\t\tif(splitX)\n\t\t\t\t{\n\t\t\t\t\tsplit = \"X\";\n\t\t\t\t}\n\t\t\t\telse if(splitY)\n\t\t\t\t{\n\t\t\t\t\tsplit = \"Y\";\n\t\t\t\t}\n\t\t\t\tif(splitZ)\n\t\t\t\t{\n\t\t\t\t\tsplit = \"Z\";\n\t\t\t\t}\n\n\t\t\t\tvar node = new PointCloudArena4DGeometryNode();\n\t\t\t\tnode.hasLeft = hasLeft;\n\t\t\t\tnode.hasRight = hasRight;\n\t\t\t\tnode.split = split;\n\t\t\t\tnode.isLeaf = !hasLeft && !hasRight;\n\t\t\t\tnode.number = i;\n\t\t\t\tnode.left = null;\n\t\t\t\tnode.right = null;\n\t\t\t\tnode.pcoGeometry = this;\n\t\t\t\tnode.level = stack.length;\n\t\t\t\tlevels = Math.max(levels, node.level);\n\n\t\t\t\t\n\n\t\t\t\tif(stack.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar parent = stack[stack.length - 1];\n\t\t\t\t\tnode.boundingBox = parent.boundingBox.clone();\n\t\t\t\t\tvar parentBBSize = parent.boundingBox.getSize(new THREE.Vector3());\n\n\t\t\t\t\tif(parent.hasLeft && !parent.left)\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.left = node;\n\t\t\t\t\t\tparent.children.push(node);\n\n\t\t\t\t\t\tif(parent.split === \"X\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.max.x = node.boundingBox.min.x + parentBBSize.x / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(parent.split === \"Y\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.max.y = node.boundingBox.min.y + parentBBSize.y / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(parent.split === \"Z\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.max.z = node.boundingBox.min.z + parentBBSize.z / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar center = new THREE.Vector3();\n\t\t\t\t\t\tnode.boundingBox.getCenter(center);\n\t\t\t\t\t\tvar radius = node.boundingBox.getSize(new THREE.Vector3()).length() / 2;\n\t\t\t\t\t\tnode.boundingSphere = new THREE.Sphere(center, radius);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.right = node;\n\t\t\t\t\t\tparent.children.push(node);\n\n\t\t\t\t\t\tif(parent.split === \"X\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.min.x = node.boundingBox.min.x + parentBBSize.x / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(parent.split === \"Y\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.min.y = node.boundingBox.min.y + parentBBSize.y / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(parent.split === \"Z\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.boundingBox.min.z = node.boundingBox.min.z + parentBBSize.z / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar center = new THREE.Vector3();\n\t\t\t\t\t\tnode.boundingBox.getCenter(center);\n\t\t\t\t\t\tvar radius = node.boundingBox.getSize(new THREE.Vector3()).length() / 2;\n\t\t\t\t\t\tnode.boundingSphere = new THREE.Sphere(center, radius);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\troot = node;\n\t\t\t\t\troot.boundingBox = this.boundingBox.clone();\n\n\t\t\t\t\tvar center = new THREE.Vector3();\n\t\t\t\t\troot.boundingBox.getCenter(center);\n\t\t\t\t\tvar radius = root.boundingBox.getSize(new THREE.Vector3()).length() / 2;\n\t\t\t\t\troot.boundingSphere = new THREE.Sphere(center, radius);\n\t\t\t\t}\n\n\t\t\t\tvar bbSize = node.boundingBox.getSize(new THREE.Vector3());\n\t\t\t\tnode.spacing = ((bbSize.x + bbSize.y + bbSize.z) / 3) / 75;\n\t\t\t\tnode.estimatedSpacing = node.spacing;\n\n\t\t\t\tstack.push(node);\n\n\t\t\t\tif(node.isLeaf)\n\t\t\t\t{\n\t\t\t\t\tvar done = false;\n\t\t\t\t\twhile(!done && stack.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstack.pop();\n\n\t\t\t\t\t\tvar top = stack[stack.length - 1];\n\n\t\t\t\t\t\tdone = stack.length > 0 && top.hasRight && top.right == null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.root = root;\n\t\t\tthis.levels = levels;\n\n\t\t\tthis.dispatchEvent(\n\t\t\t{\n\t\t\t\ttype: \"hierarchy_loaded\"\n\t\t\t});\n\t\t};\n\n\t\txhr.send(null);\n\t};\n\n\tget spacing()\n\t{\n\t\tif(this._spacing)\n\t\t{\n\t\t\treturn this._spacing;\n\t\t}\n\t\telse if(this.root)\n\t\t{\n\t\t\treturn this.root.spacing;\n\t\t}\n\t}\n\n\tset spacing(value)\n\t{\n\t\tthis._spacing = value;\n\t}\n}\n\n/*\n** Binary Heap implementation in Javascript\n** From: http://eloquentjavascript.net/1st_edition/appendix2.htmlt\n**\n** Copyright (c) 2007 Marijn Haverbeke, last modified on November 28 2013.\n**\n** Licensed under a Creative Commons attribution-noncommercial license. \n** All code in this book may also be considered licensed under an MIT license.\n*/\n\nfunction BinaryHeap(scoreFunction)\n{\n\tthis.content = [];\n\tthis.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype =\n{\n\tpush: function(element)\n\t{\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push(element);\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp(this.content.length - 1);\n\t},\n\n\tpop: function()\n\t{\n\t\t// Store the first element so we can return it later.\n\t\tvar result = this.content[0];\n\t\t// Get the element at the end of the array.\n\t\tvar end = this.content.pop();\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif(this.content.length > 0)\n\t\t{\n\t\t\tthis.content[0] = end;\n\t\t\tthis.sinkDown(0);\n\t\t}\n\t\treturn result;\n\t},\n\n\tremove: function(node)\n\t{\n\t\tvar length = this.content.length;\n\t\t// To remove a value, we must search through the array to find\n\t\t// it.\n\t\tfor(var i = 0; i < length; i++)\n\t\t{\n\t\t\tif(this.content[i] != node) continue;\n\t\t\t// When it is found, the process seen in 'pop' is repeated\n\t\t\t// to fill up the hole.\n\t\t\tvar end = this.content.pop();\n\t\t\t// If the element we popped was the one we needed to remove,\n\t\t\t// we're done.\n\t\t\tif(i == length - 1) break;\n\t\t\t// Otherwise, we replace the removed element with the popped\n\t\t\t// one, and allow it to float up or sink down as appropriate.\n\t\t\tthis.content[i] = end;\n\t\t\tthis.bubbleUp(i);\n\t\t\tthis.sinkDown(i);\n\t\t\tbreak;\n\t\t}\n\t},\n\n\tsize: function()\n\t{\n\t\treturn this.content.length;\n\t},\n\n\tbubbleUp: function(n)\n\t{\n\t\t// Fetch the element that has to be moved.\n\t\tvar element = this.content[n], score = this.scoreFunction(element);\n\t\t// When at 0, an element can not go up any further.\n\t\twhile(n > 0)\n\t\t{\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tvar parentN = Math.floor((n + 1) / 2) - 1,\n\t\t\tparent = this.content[parentN];\n\t\t\t// If the parent has a lesser score, things are in order and we\n\t\t\t// are done.\n\t\t\tif(score >= this.scoreFunction(parent))\n\t\t\t\tbreak;\n\n\t\t\t// Otherwise, swap the parent with the current element and\n\t\t\t// continue.\n\t\t\tthis.content[parentN] = element;\n\t\t\tthis.content[n] = parent;\n\t\t\tn = parentN;\n\t\t}\n\t},\n\n\tsinkDown: function(n)\n\t{\n\t\t// Look up the target element and its score.\n\t\tvar length = this.content.length,\n\t\telement = this.content[n],\n\t\telemScore = this.scoreFunction(element);\n\n\t\twhile(true)\n\t\t{\n\t\t\t// Compute the indices of the child elements.\n\t\t\tvar child2N = (n + 1) * 2, child1N = child2N - 1;\n\t\t\t// This is used to store the new position of the element,\n\t\t\t// if any.\n\t\t\tvar swap = null;\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif(child1N < length)\n\t\t\t{\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tvar child1 = this.content[child1N],\n\t\t\t\tchild1Score = this.scoreFunction(child1);\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif(child1Score < elemScore)\n\t\t\t\t\tswap = child1N;\n\t\t\t}\n\t\t\t// Do the same checks for the other child.\n\t\t\tif(child2N < length)\n\t\t\t{\n\t\t\t\tvar child2 = this.content[child2N],\n\t\t\t\tchild2Score = this.scoreFunction(child2);\n\t\t\t\tif(child2Score < (swap == null ? elemScore : child1Score))\n\t\t\t\t\tswap = child2N;\n\t\t\t}\n\n\t\t\t// No need to swap further, we are done.\n\t\t\tif(swap == null) break;\n\n\t\t\t// Otherwise, swap and continue.\n\t\t\tthis.content[n] = this.content[swap];\n\t\t\tthis.content[swap] = element;\n\t\t\tn = swap;\n\t\t}\n\t}\n};\n\nvar AttributeLocations =\n{\n\tposition: 0,\n\tcolor: 1,\n\tintensity: 2,\n\tclassification: 3,\n\treturnNumber: 4,\n\tnumberOfReturns: 5,\n\tpointSourceID: 6,\n\tindices: 7,\n\tnormal: 8,\n\tspacing: 9,\n};\n\nvar Classification =\n{\n\tDEFAULT:\n\t{\n\t\t0: new THREE.Vector4(0.5, 0.5, 0.5, 1.0),\n\t\t1: new THREE.Vector4(0.5, 0.5, 0.5, 1.0),\n\t\t2: new THREE.Vector4(0.63, 0.32, 0.18, 1.0),\n\t\t3: new THREE.Vector4(0.0, 1.0, 0.0, 1.0),\n\t\t4: new THREE.Vector4(0.0, 0.8, 0.0, 1.0),\n\t\t5: new THREE.Vector4(0.0, 0.6, 0.0, 1.0),\n\t\t6: new THREE.Vector4(1.0, 0.66, 0.0, 1.0),\n\t\t7: new THREE.Vector4(1.0, 0, 1.0, 1.0),\n\t\t8: new THREE.Vector4(1.0, 0, 0.0, 1.0),\n\t\t9: new THREE.Vector4(0.0, 0.0, 1.0, 1.0),\n\t\t12: new THREE.Vector4(1.0, 1.0, 0.0, 1.0),\n\t\tDEFAULT: new THREE.Vector4(0.3, 0.6, 0.6, 0.5)\n\t}\n};\n\nvar ClipTask =\n{\n\tNONE: 0,\n\tHIGHLIGHT: 1,\n\tSHOW_INSIDE: 2,\n\tSHOW_OUTSIDE: 3\n};\n\nvar ClipMethod =\n{\n\tINSIDE_ANY: 0,\n\tINSIDE_ALL: 1\n};\n\nvar PointSizeType =\n{\n\tFIXED: 0,\n\tATTENUATED: 1,\n\tADAPTIVE: 2\n};\n\nvar PointShape =\n{\n\tSQUARE: 0,\n\tCIRCLE: 1,\n\tPARABOLOID: 2\n};\n\nvar PointColorType =\n{\n\tRGB: 0,\n\tCOLOR: 1,\n\tDEPTH: 2,\n\tHEIGHT: 3,\n\tELEVATION: 3,\n\tINTENSITY: 4,\n\tINTENSITY_GRADIENT: 5,\n\tLOD: 6,\n\tLEVEL_OF_DETAIL: 6,\n\tPOINT_INDEX: 7,\n\tCLASSIFICATION: 8,\n\tRETURN_NUMBER: 9,\n\tSOURCE: 10,\n\tNORMAL: 11,\n\tPHONG: 12,\n\tRGB_HEIGHT: 13,\n\tCOMPOSITE: 50\n};\n\nvar TreeType =\n{\n\tOCTREE: 0,\n\tKDTREE: 1\n};\n\nfunction loadPointCloud(path, name, callback)\n{\n\tvar loaded = function(pointcloud)\n\t{\n\t\tif(name !== undefined)\n\t\t{\n\t\t\tpointcloud.name = name;\n\t\t}\n\t\t\n\t\tcallback(\n\t\t{\n\t\t\ttype: \"pointcloud_loaded\",\n\t\t\tpointcloud: pointcloud\n\t\t});\n\t};\n\n\t//Greyhound pointcloud server URL.\n\tif(path.indexOf(\"greyhound://\") === 0)\n\t{\n\t\tGreyhoundLoader.load(path, function(geometry)\n\t\t{\n\t\t\tif(geometry !== undefined)\n\t\t\t{\n\t\t\t\tloaded(new PointCloudOctree(geometry));\n\t\t\t}\n\t\t});\n\t}\n\t//Potree point cloud\n\telse if(path.indexOf(\"cloud.js\") > 0)\n\t{\n\t\tPOCLoader.load(path, function(geometry)\n\t\t{\n\t\t\tif(geometry !== undefined)\n\t\t\t{\n\t\t\t\tloaded(new PointCloudOctree(geometry));\n\t\t\t}\n\t\t});\n\t}\n\telse if (path.indexOf('ept.json') > 0)\n\t{\n\t\tEptLoader.load(path, function(geometry)\n\t\t{\n\t\t\tif(geometry !== undefined)\n\t\t\t{\n\t\t\t\tloaded(new PointCloudOctree(geometry));\n\t\t\t}\n\t\t});\n\t}\n\t//Arena 4D point cloud\n\telse if(path.indexOf(\".vpc\") > 0)\n\t{\n\t\tPointCloudArena4DGeometry.load(path, function(geometry)\n\t\t{\n\t\t\tif(geometry !== undefined)\n\t\t\t{\n\t\t\t\tloaded(new PointCloudArena4D(geometry));\n\t\t\t}\n\t\t});\n\t}\n\telse\n\t{\n\t\tthrow new Error(\"Potree: Failed to load point cloud from URL \" + path);\n\t}\n}\n\nfunction updateVisibility(pointclouds, camera, renderer)\n{\n\tvar numVisiblePoints = 0;\n\tvar numVisiblePointsInPointclouds = new Map(pointclouds.map(pc => [pc, 0]));\n\tvar visibleNodes = [];\n\tvar unloadedGeometry = [];\n\tvar lowestSpacing = Infinity;\n\n\t//Calculate object space frustum and cam pos and setup priority queue\n\tvar structures = updateVisibilityStructures(pointclouds, camera);\n\tvar frustums = structures.frustums;\n\tvar camObjPositions = structures.camObjPositions;\n\tvar priorityQueue = structures.priorityQueue;\n\n\tvar loadedToGPUThisFrame = 0;\n\tvar domWidth = renderer.domElement.clientWidth;\n\tvar domHeight = renderer.domElement.clientHeight;\n\n\t//Check if pointcloud has been transformed, some code will only be executed if changes have been detected\n\tif(!Global.pointcloudTransformVersion)\n\t{\n\t\tGlobal.pointcloudTransformVersion = new Map();\n\t}\n\n\tvar pointcloudTransformVersion = Global.pointcloudTransformVersion;\n\n\tfor(var i = 0; i < pointclouds.length; i++)\n\t{\n\t\tvar pointcloud = pointclouds[i];\n\n\t\tif(!pointcloud.visible)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tpointcloud.updateMatrixWorld();\n\n\t\tif(!pointcloudTransformVersion.has(pointcloud))\n\t\t{\n\t\t\tpointcloudTransformVersion.set(pointcloud,\n\t\t\t{\n\t\t\t\tnumber: 0,\n\t\t\t\ttransform: pointcloud.matrixWorld.clone()\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar version = pointcloudTransformVersion.get(pointcloud);\n\t\t\tif(!version.transform.equals(pointcloud.matrixWorld))\n\t\t\t{\n\t\t\t\tversion.number++;\n\t\t\t\tversion.transform.copy(pointcloud.matrixWorld);\n\n\t\t\t\tpointcloud.dispatchEvent(\n\t\t\t\t{\n\t\t\t\t\ttype: \"transformation_changed\",\n\t\t\t\t\ttarget: pointcloud\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t//Process priority queue\n\twhile(priorityQueue.size() > 0)\n\t{\n\t\tvar element = priorityQueue.pop();\n\t\tvar node = element.node;\n\t\tvar parent = element.parent;\n\t\tvar pointcloud = pointclouds[element.pointcloud];\n\t\tvar box = node.getBoundingBox();\n\t\tvar frustum = frustums[element.pointcloud];\n\t\tvar camObjPos = camObjPositions[element.pointcloud];\n\n\t\tvar insideFrustum = frustum.intersectsBox(box);\n\t\tvar maxLevel = pointcloud.maxLevel || Infinity;\n\t\tvar level = node.getLevel();\n\n\t\tvar visible = insideFrustum;\n\t\tvisible = visible && !(numVisiblePointsInPointclouds.get(pointcloud) + node.getNumPoints() > pointcloud.pointBudget);\n\t\tvisible = visible && level < maxLevel;\n\n\t\t//TODO <CLIPPING TASKS>\n\t\t/*\n\t\tif(false && pointcloud.material.clipBoxes.length > 0)\n\t\t{\n\t\t\tvar numIntersecting = 0;\n\t\t\tvar numIntersectionVolumes = 0;\n\n\t\t\tfor(var clipBox of pointcloud.material.clipBoxes)\n\t\t\t{\n\t\t\t\tvar pcWorldInverse = new THREE.Matrix4().getInverse(pointcloud.matrixWorld);\n\t\t\t\tvar toPCObject = pcWorldInverse.multiply(clipBox.box.matrixWorld);\n\n\t\t\t\tvar px = new THREE.Vector3(+1, 0, 0).applyMatrix4(toPCObject);\n\t\t\t\tvar nx = new THREE.Vector3(-1, 0, 0).applyMatrix4(toPCObject);\n\t\t\t\tvar py = new THREE.Vector3(0, +1, 0).applyMatrix4(toPCObject);\n\t\t\t\tvar ny = new THREE.Vector3(0, -1, 0).applyMatrix4(toPCObject);\n\t\t\t\tvar pz = new THREE.Vector3(0, 0, +1).applyMatrix4(toPCObject);\n\t\t\t\tvar nz = new THREE.Vector3(0, 0, -1).applyMatrix4(toPCObject);\n\n\t\t\t\tvar pxN = new THREE.Vector3().subVectors(nx, px).normalize();\n\t\t\t\tvar nxN = pxN.clone().multiplyScalar(-1);\n\t\t\t\tvar pyN = new THREE.Vector3().subVectors(ny, py).normalize();\n\t\t\t\tvar nyN = pyN.clone().multiplyScalar(-1);\n\t\t\t\tvar pzN = new THREE.Vector3().subVectors(nz, pz).normalize();\n\t\t\t\tvar nzN = pzN.clone().multiplyScalar(-1);\n\n\t\t\t\tvar pxPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(pxN, px);\n\t\t\t\tvar nxPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(nxN, nx);\n\t\t\t\tvar pyPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(pyN, py);\n\t\t\t\tvar nyPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(nyN, ny);\n\t\t\t\tvar pzPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(pzN, pz);\n\t\t\t\tvar nzPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(nzN, nz);\n\n\t\t\t\tvar frustum = new THREE.Frustum(pxPlane, nxPlane, pyPlane, nyPlane, pzPlane, nzPlane);\n\t\t\t\tvar intersects = frustum.intersectsBox(box);\n\n\t\t\t\tif(intersects)\n\t\t\t\t{\n\t\t\t\t\tnumIntersecting++;\n\t\t\t\t}\n\t\t\t\tnumIntersectionVolumes++;\n\t\t\t}\n\n\t\t\tvar insideAny = numIntersecting > 0;\n\t\t\tvar insideAll = numIntersecting === numIntersectionVolumes;\n\n\t\t\tif(pointcloud.material.clipTask === ClipTask.SHOW_INSIDE)\n\t\t\t{\n\t\t\t\tif(pointcloud.material.clipMethod === ClipMethod.INSIDE_ANY && insideAny)\n\t\t\t\t{\n\t\t\t\t\t//node.debug = true\n\t\t\t\t}\n\t\t\t\telse if(pointcloud.material.clipMethod === ClipMethod.INSIDE_ALL && insideAll)\n\t\t\t\t{\n\t\t\t\t\t//node.debug = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvisible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\tif(node.spacing)\n\t\t{\n\t\t\tlowestSpacing = Math.min(lowestSpacing, node.spacing);\n\t\t}\n\t\telse if(node.geometryNode && node.geometryNode.spacing)\n\t\t{\n\t\t\tlowestSpacing = Math.min(lowestSpacing, node.geometryNode.spacing);\n\t\t}\n\n\t\tif(!visible)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tnumVisiblePoints += node.getNumPoints();\n\n\t\tvar numVisiblePointsInPointcloud = numVisiblePointsInPointclouds.get(pointcloud);\n\t\tnumVisiblePointsInPointclouds.set(pointcloud, numVisiblePointsInPointcloud + node.getNumPoints());\n\n\t\tpointcloud.numVisibleNodes++;\n\t\tpointcloud.numVisiblePoints += node.getNumPoints();\n\n\t\tif(node.isGeometryNode() && (!parent || parent.isTreeNode()))\n\t\t{\n\t\t\tif(node.isLoaded() && loadedToGPUThisFrame < Global.maxNodesLoadGPUFrame)\n\t\t\t{\n\t\t\t\tnode = pointcloud.toTreeNode(node, parent);\n\t\t\t\tloadedToGPUThisFrame++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tunloadedGeometry.push(node);\n\t\t\t}\n\t\t}\n\n\t\tif(node.isTreeNode())\n\t\t{\n\t\t\tGlobal.lru.touch(node.geometryNode);\n\n\t\t\tnode.sceneNode.visible = true;\n\t\t\tnode.sceneNode.material = pointcloud.material;\n\n\t\t\tvisibleNodes.push(node);\n\t\t\tpointcloud.visibleNodes.push(node);\n\n\t\t\tif(node._transformVersion === undefined)\n\t\t\t{\n\t\t\t\tnode._transformVersion = -1;\n\t\t\t}\n\n\t\t\tvar transformVersion = pointcloudTransformVersion.get(pointcloud);\n\t\t\tif(node._transformVersion !== transformVersion.number)\n\t\t\t{\n\t\t\t\tnode.sceneNode.updateMatrix();\n\t\t\t\tnode.sceneNode.matrixWorld.multiplyMatrices(pointcloud.matrixWorld, node.sceneNode.matrix);\n\t\t\t\tnode._transformVersion = transformVersion.number;\n\t\t\t}\n\n\t\t\tif(pointcloud.showBoundingBox && !node.boundingBoxNode && node.getBoundingBox)\n\t\t\t{\n\t\t\t\tvar boxHelper = new THREE.Box3Helper(node.getBoundingBox());\n\t\t\t\tboxHelper.matrixAutoUpdate = false;\n\t\t\t\tpointcloud.boundingBoxNodes.push(boxHelper);\n\t\t\t\tnode.boundingBoxNode = boxHelper;\n\t\t\t\tnode.boundingBoxNode.matrix.copy(pointcloud.matrixWorld);\n\t\t\t}\n\t\t\telse if(pointcloud.showBoundingBox)\n\t\t\t{\n\t\t\t\tnode.boundingBoxNode.visible = true;\n\t\t\t\tnode.boundingBoxNode.matrix.copy(pointcloud.matrixWorld);\n\t\t\t}\n\t\t\telse if(!pointcloud.showBoundingBox && node.boundingBoxNode)\n\t\t\t{\n\t\t\t\tnode.boundingBoxNode.visible = false;\n\t\t\t}\n\t\t}\n\n\t\t//Add child nodes to priorityQueue\n\t\tvar children = node.getChildren();\n\t\tfor(var i = 0; i < children.length; i++)\n\t\t{\n\t\t\tvar child = children[i];\n\t\t\tvar weight = 0;\n\n\t\t\t//Perspective camera\n\t\t\tif(camera.isPerspectiveCamera)\n\t\t\t{\n\t\t\t\tvar sphere = child.getBoundingSphere(new THREE.Sphere());\n\t\t\t\tvar center = sphere.center;\n\t\t\t\tvar distance = sphere.center.distanceTo(camObjPos);\n\n\t\t\t\tvar radius = sphere.radius;\n\t\t\t\tvar fov = (camera.fov * Math.PI) / 180;\n\t\t\t\tvar slope = Math.tan(fov / 2);\n\t\t\t\tvar projFactor = (0.5 * domHeight) / (slope * distance);\n\t\t\t\tvar screenPixelRadius = radius * projFactor;\n\n\t\t\t\t//If pixel radius bellow minimum discard\n\t\t\t\tif(screenPixelRadius < pointcloud.minimumNodePixelSize)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tweight = screenPixelRadius;\n\n\t\t\t\t//Really close to the camera\n\t\t\t\tif(distance - radius < 0)\n\t\t\t\t{\n\t\t\t\t\tweight = Number.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//Orthographic camera\n\t\t\telse\n\t\t\t{\n\t\t\t\t//TODO <IMPROVE VISIBILITY>\n\t\t\t\tvar bb = child.getBoundingBox();\n\t\t\t\tvar distance = child.getBoundingSphere(new THREE.Sphere()).center.distanceTo(camObjPos);\n\t\t\t\tvar diagonal = bb.max.clone().sub(bb.min).length();\n\t\t\t\tweight = diagonal / distance;\n\t\t\t}\n\n\t\t\tpriorityQueue.push(\n\t\t\t{\n\t\t\t\tpointcloud: element.pointcloud,\n\t\t\t\tnode: child,\n\t\t\t\tparent: node,\n\t\t\t\tweight: weight\n\t\t\t});\n\t\t}\n\t}\n\n\t//Update DEM\n\tvar candidates = pointclouds.filter(p => (p.generateDEM && p.dem instanceof DEM));\n\t\n\tfor(var pointcloud of candidates)\n\t{\n\t\tvar updatingNodes = pointcloud.visibleNodes.filter(n => n.getLevel() <= Global.maxDEMLevel);\n\t\tpointcloud.dem.update(updatingNodes);\n\t}\n\t\n\tfor(var i = 0; i < Math.min(Global.maxNodesLoading, unloadedGeometry.length); i++)\n\t{\n\t\tunloadedGeometry[i].load();\n\t}\n\n\treturn {\n\t\tvisibleNodes: visibleNodes,\n\t\tnumVisiblePoints: numVisiblePoints,\n\t\tlowestSpacing: lowestSpacing\n\t};\n}\n\nfunction updatePointClouds(pointclouds, camera, renderer)\n{\n\tvar result = updateVisibility(pointclouds, camera, renderer);\n\n\tfor(var i = 0; i < pointclouds.length; i++)\n\t{\n\t\tpointclouds[i].updateMaterial(pointclouds[i].material, pointclouds[i].visibleNodes, camera, renderer);\n\t\tpointclouds[i].updateVisibleBounds();\n\t}\n\n\tGlobal.lru.freeMemory();\n\n\treturn result;\n}\n\nfunction updateVisibilityStructures(pointclouds, camera, renderer)\n{\n\tvar frustums = [];\n\tvar camObjPositions = [];\n\tvar priorityQueue = new BinaryHeap(function(x)\n\t{\n\t\treturn 1 / x.weight;\n\t});\n\n\tfor(var i = 0; i < pointclouds.length; i++)\n\t{\n\t\tvar pointcloud = pointclouds[i];\n\n\t\tif(!pointcloud.initialized())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tpointcloud.numVisibleNodes = 0;\n\t\tpointcloud.numVisiblePoints = 0;\n\t\tpointcloud.deepestVisibleLevel = 0;\n\t\tpointcloud.visibleNodes = [];\n\t\tpointcloud.visibleGeometry = [];\n\n\t\t//Frustum in object space\n\t\tcamera.updateMatrixWorld();\n\t\tvar frustum = new THREE.Frustum();\n\t\tvar viewI = camera.matrixWorldInverse;\n\t\tvar world = pointcloud.matrixWorld;\n\n\t\t//Use close near plane for frustum intersection\n\t\tvar frustumCam = camera.clone();\n\t\tfrustumCam.near = camera.near; //Math.min(camera.near, 0.1);\n\t\tfrustumCam.updateProjectionMatrix();\n\t\tvar proj = camera.projectionMatrix;\n\n\t\tvar fm = new THREE.Matrix4().multiply(proj).multiply(viewI).multiply(world);\n\t\tfrustum.setFromMatrix(fm);\n\t\tfrustums.push(frustum);\n\n\t\t//Camera position in object space\n\t\tvar view = camera.matrixWorld;\n\t\tvar worldI = new THREE.Matrix4().getInverse(world);\n\t\tvar camMatrixObject = new THREE.Matrix4().multiply(worldI).multiply(view);\n\t\tvar camObjPos = new THREE.Vector3().setFromMatrixPosition(camMatrixObject);\n\t\tcamObjPositions.push(camObjPos);\n\n\t\tif(pointcloud.visible && pointcloud.root !== null)\n\t\t{\n\t\t\tpriorityQueue.push(\n\t\t\t{\n\t\t\t\tpointcloud: i,\n\t\t\t\tnode: pointcloud.root,\n\t\t\t\tweight: Number.MAX_VALUE\n\t\t\t});\n\t\t}\n\n\t\t//Hide all previously visible nodes\n\t\tif(pointcloud.root.isTreeNode())\n\t\t{\n\t\t\tpointcloud.hideDescendants(pointcloud.root.sceneNode);\n\t\t}\n\n\t\tfor(var j = 0; j < pointcloud.boundingBoxNodes.length; j++)\n\t\t{\n\t\t\tpointcloud.boundingBoxNodes[j].visible = false;\n\t\t}\n\t}\n\n\treturn {\n\t\tfrustums: frustums,\n\t\tcamObjPositions: camObjPositions,\n\t\tpriorityQueue: priorityQueue\n\t};\n}\n\nclass Points\n{\n\tconstructor()\n\t{\n\t\tthis.boundingBox = new THREE.Box3();\n\t\tthis.numPoints = 0;\n\t\tthis.data = {};\n\t}\n\n\tadd(points)\n\t{\n\t\tvar currentSize = this.numPoints;\n\t\tvar additionalSize = points.numPoints;\n\t\tvar newSize = currentSize + additionalSize;\n\n\t\tvar thisAttributes = Object.keys(this.data);\n\t\tvar otherAttributes = Object.keys(points.data);\n\t\tvar attributes = new Set([...thisAttributes, ...otherAttributes]);\n\n\t\tfor(var attribute of attributes)\n\t\t{\n\t\t\tif(thisAttributes.includes(attribute) && otherAttributes.includes(attribute))\n\t\t\t{\n\t\t\t\t//attribute in both, merge\n\t\t\t\tvar Type = this.data[attribute].constructor;\n\t\t\t\tvar merged = new Type(this.data[attribute].length + points.data[attribute].length);\n\t\t\t\tmerged.set(this.data[attribute], 0);\n\t\t\t\tmerged.set(points.data[attribute], this.data[attribute].length);\n\t\t\t\tthis.data[attribute] = merged;\n\t\t\t}\n\t\t\telse if(thisAttributes.includes(attribute) && !otherAttributes.includes(attribute))\n\t\t\t{\n\t\t\t\t//attribute only in this; take over this and expand to new size\n\t\t\t\tvar elementsPerPoint = this.data[attribute].length / this.numPoints;\n\t\t\t\tvar Type = this.data[attribute].constructor;\n\t\t\t\tvar expanded = new Type(elementsPerPoint * newSize);\n\t\t\t\texpanded.set(this.data[attribute], 0);\n\t\t\t\tthis.data[attribute] = expanded;\n\t\t\t}\n\t\t\telse if(!thisAttributes.includes(attribute) && otherAttributes.includes(attribute))\n\t\t\t{\n\t\t\t\t//attribute only in points to be added; take over new points and expand to new size\n\t\t\t\tvar elementsPerPoint = points.data[attribute].length / points.numPoints;\n\t\t\t\tvar Type = points.data[attribute].constructor;\n\t\t\t\tvar expanded = new Type(elementsPerPoint * newSize);\n\t\t\t\texpanded.set(points.data[attribute], elementsPerPoint * currentSize);\n\t\t\t\tthis.data[attribute] = expanded;\n\t\t\t}\n\t\t}\n\n\t\tthis.numPoints = newSize;\n\n\t\tthis.boundingBox.union(points.boundingBox);\n\t}\n}\n\nfunction paramThreeToGL(gl, p)\n{\n\tvar extension;\n\n\tif(p === THREE.RepeatWrapping) return gl.REPEAT;\n\tif(p === THREE.ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;\n\tif(p === THREE.MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;\n\n\tif(p === THREE.NearestFilter) return gl.NEAREST;\n\tif(p === THREE.NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;\n\tif(p === THREE.NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;\n\n\tif(p === THREE.LinearFilter) return gl.LINEAR;\n\tif(p === THREE.LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;\n\tif(p === THREE.LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;\n\n\tif(p === THREE.UnsignedByteType) return gl.UNSIGNED_BYTE;\n\tif(p === THREE.UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n\tif(p === THREE.UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n\tif(p === THREE.UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;\n\n\tif(p === THREE.ByteType) return gl.BYTE;\n\tif(p === THREE.ShortType) return gl.SHORT;\n\tif(p === THREE.UnsignedShortType) return gl.UNSIGNED_SHORT;\n\tif(p === THREE.IntType) return gl.INT;\n\tif(p === THREE.UnsignedIntType) return gl.UNSIGNED_INT;\n\tif(p === THREE.FloatType) return gl.FLOAT;\n\n\tif(p === THREE.HalfFloatType)\n\t{\n\t\textension = extensions.get(\"OES_texture_half_float\");\n\t\tif(extension !== null) return extension.HALF_FLOAT_OES;\n\t}\n\n\tif(p === THREE.AlphaFormat) return gl.ALPHA;\n\tif(p === THREE.RGBFormat) return gl.RGB;\n\tif(p === THREE.RGBAFormat) return gl.RGBA;\n\tif(p === THREE.LuminanceFormat) return gl.LUMINANCE;\n\tif(p === THREE.LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n\tif(p === THREE.DepthFormat) return gl.DEPTH_COMPONENT;\n\tif(p === THREE.DepthStencilFormat) return gl.DEPTH_STENCIL;\n\n\tif(p === THREE.AddEquation) return gl.FUNC_ADD;\n\tif(p === THREE.SubtractEquation) return gl.FUNC_SUBTRACT;\n\tif(p === THREE.ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;\n\n\tif(p === THREE.ZeroFactor) return gl.ZERO;\n\tif(p === THREE.OneFactor) return gl.ONE;\n\tif(p === THREE.SrcColorFactor) return gl.SRC_COLOR;\n\tif(p === THREE.OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;\n\tif(p === THREE.SrcAlphaFactor) return gl.SRC_ALPHA;\n\tif(p === THREE.OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;\n\tif(p === THREE.DstAlphaFactor) return gl.DST_ALPHA;\n\tif(p === THREE.OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;\n\n\tif(p === THREE.DstColorFactor) return gl.DST_COLOR;\n\tif(p === THREE.OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;\n\tif(p === THREE.SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;\n\n\tif(p === THREE.RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === THREE.RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format)\n\t{\n\t\textension = extensions.get(\"WEBGL_compressed_texture_s3tc\");\n\n\t\tif(extension !== null)\n\t\t{\n\t\t\tif(p === THREE.RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif(p === THREE.RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif(p === THREE.RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif(p === THREE.RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t}\n\t}\n\n\tif(p === THREE.RGB_PVRTC_4BPPV1_Format || p === THREE.RGB_PVRTC_2BPPV1_Format || p === THREE.RGBA_PVRTC_4BPPV1_Format || p === THREE.RGBA_PVRTC_2BPPV1_Format)\n\t{\n\t\textension = extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n\n\t\tif(extension !== null)\n\t\t{\n\t\t\tif(p === THREE.RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif(p === THREE.RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif(p === THREE.RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif(p === THREE.RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t}\n\t}\n\n\tif(p === THREE.RGB_ETC1_Format)\n\t{\n\t\textension = extensions.get(\"WEBGL_compressed_texture_etc1\");\n\t\tif(extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t}\n\n\tif(p === THREE.MinEquation || p === THREE.MaxEquation)\n\t{\n\t\textension = extensions.get(\"EXT_blend_minmax\");\n\n\t\tif(extension !== null)\n\t\t{\n\t\t\tif(p === THREE.MinEquation) return extension.MIN_EXT;\n\t\t\tif(p === THREE.MaxEquation) return extension.MAX_EXT;\n\t\t}\n\t}\n\n\tif(p === UnsignedInt248Type)\n\t{\n\t\textension = extensions.get(\"WEBGL_depth_texture\");\n\t\tif(extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;\n\t}\n\n\treturn 0;\n}\n\nclass WebGLTexture\n{\n\tconstructor(gl, texture)\n\t{\n\t\tthis.gl = gl;\n\n\t\tthis.texture = texture;\n\t\tthis.id = gl.createTexture();\n\n\t\tthis.target = gl.TEXTURE_2D;\n\t\tthis.version = -1;\n\n\t\tthis.update(texture);\n\t}\n\n\tupdate()\n\t{\n\t\tif(!this.texture.image)\n\t\t{\n\t\t\tthis.version = this.texture.version;\n\t\t\treturn;\n\t\t}\n\n\t\tvar gl = this.gl;\n\t\tvar texture = this.texture;\n\n\t\tif(this.version === texture.version)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.target = gl.TEXTURE_2D;\n\n\t\tgl.bindTexture(this.target, this.id);\n\n\t\tvar level = 0;\n\t\tvar internalFormat = paramThreeToGL(gl, texture.format);\n\t\tvar width = texture.image.width;\n\t\tvar height = texture.image.height;\n\t\tvar border = 0;\n\t\tvar srcFormat = internalFormat;\n\t\tvar srcType = paramThreeToGL(gl, texture.type);\n\t\tvar data;\n\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\tif(texture instanceof THREE.DataTexture)\n\t\t{\n\t\t\tdata = texture.image.data;\n\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, paramThreeToGL(gl, texture.magFilter));\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, paramThreeToGL(gl, texture.minFilter));\n\n\t\t\tgl.texImage2D(this.target, level, internalFormat, width, height, border, srcFormat, srcType, data);\n\t\t}\n\t\telse if(texture instanceof THREE.CanvasTexture)\n\t\t{\n\t\t\tdata = texture.image;\n\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_WRAP_S, paramThreeToGL(gl, texture.wrapS));\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_WRAP_T, paramThreeToGL(gl, texture.wrapT));\n\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, paramThreeToGL(gl, texture.magFilter));\n\t\t\tgl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, paramThreeToGL(gl, texture.minFilter));\n\n\t\t\tgl.texImage2D(this.target, level, internalFormat, internalFormat, srcType, data);\n\t\t}\n\n\t\tgl.bindTexture(this.target, null);\n\n\t\tthis.version = texture.version;\n\t}\n}\n\nclass Shader\n{\n\tconstructor(gl, name, vsSource, fsSource)\n\t{\n\t\tthis.gl = gl;\n\t\tthis.name = name;\n\t\tthis.vsSource = vsSource;\n\t\tthis.fsSource = fsSource;\n\n\t\tthis.cache = new Map();\n\n\t\tthis.vs = null;\n\t\tthis.fs = null;\n\t\tthis.program = null;\n\n\t\tthis.uniformLocations = {};\n\t\tthis.attributeLocations = {};\n\n\t\tthis.update(vsSource, fsSource);\n\t}\n\n\tupdate(vsSource, fsSource)\n\t{\n\t\tthis.vsSource = vsSource;\n\t\tthis.fsSource = fsSource;\n\n\t\tthis.linkProgram();\n\t}\n\n\tcompileShader(shader, source)\n\t{\n\t\tvar gl = this.gl;\n\n\t\tgl.shaderSource(shader, source);\n\n\t\tgl.compileShader(shader);\n\n\t\tvar success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tif(!success)\n\t\t{\n\t\t\tvar info = gl.getShaderInfoLog(shader);\n\t\t\tthrow new Error(\"Potree: Could not compile shader \" + this.name + \", \" + info);\n\t\t}\n\t}\n\n\tlinkProgram()\n\t{\n\n\t\tvar gl = this.gl;\n\n\t\tthis.uniformLocations = {};\n\t\tthis.attributeLocations = {};\n\n\t\tgl.useProgram(null);\n\n\t\tvar cached = this.cache.get(`${this.vsSource}, ${this.fsSource}`);\n\t\tif(cached)\n\t\t{\n\t\t\tthis.program = cached.program;\n\t\t\tthis.vs = cached.vs;\n\t\t\tthis.fs = cached.fs;\n\t\t\tthis.attributeLocations = cached.attributeLocations;\n\t\t\tthis.uniformLocations = cached.uniformLocations;\n\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.vs = gl.createShader(gl.VERTEX_SHADER);\n\t\t\tthis.fs = gl.createShader(gl.FRAGMENT_SHADER);\n\t\t\tthis.program = gl.createProgram();\n\n\t\t\tfor(var name of Object.keys(AttributeLocations))\n\t\t\t{\n\t\t\t\tvar location = AttributeLocations[name];\n\t\t\t\tgl.bindAttribLocation(this.program, location, name);\n\t\t\t}\n\n\t\t\tthis.compileShader(this.vs, this.vsSource);\n\t\t\tthis.compileShader(this.fs, this.fsSource);\n\n\t\t\tvar program = this.program;\n\n\t\t\tgl.attachShader(program, this.vs);\n\t\t\tgl.attachShader(program, this.fs);\n\n\t\t\tgl.linkProgram(program);\n\n\t\t\tgl.detachShader(program, this.vs);\n\t\t\tgl.detachShader(program, this.fs);\n\n\t\t\tvar success = gl.getProgramParameter(program, gl.LINK_STATUS);\n\t\t\tif(!success)\n\t\t\t{\n\t\t\t\tvar info = gl.getProgramInfoLog(program);\n\t\t\t\tthrow new Error(\"Potree: Could not link program \" + this.name + \", \" + info);\n\t\t\t}\n\n\t\t\t//attribute locations\n\t\t\tvar numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n\t\t\tfor(var i = 0; i < numAttributes; i++)\n\t\t\t{\n\t\t\t\tvar attribute = gl.getActiveAttrib(program, i);\n\n\t\t\t\tvar location = gl.getAttribLocation(program, attribute.name);\n\n\t\t\t\tthis.attributeLocations[attribute.name] = location;\n\t\t\t}\n\n\t\t\t//uniform locations\n\t\t\tvar numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t\t\tfor(var i = 0; i < numUniforms; i++)\n\t\t\t{\n\t\t\t\tvar uniform = gl.getActiveUniform(program, i);\n\n\t\t\t\tvar location = gl.getUniformLocation(program, uniform.name);\n\n\t\t\t\tthis.uniformLocations[uniform.name] = location;\n\t\t\t}\n\n\t\t\tvar cached = {\n\t\t\t\tprogram: this.program,\n\t\t\t\tvs: this.vs,\n\t\t\t\tfs: this.fs,\n\t\t\t\tattributeLocations: this.attributeLocations,\n\t\t\t\tuniformLocations: this.uniformLocations\n\t\t\t};\n\n\t\t\tthis.cache.set(`${this.vsSource}, ${this.fsSource}`, cached);\n\t\t}\n\t}\n\n\tsetUniformMatrix4(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar tmp = new Float32Array(value.elements);\n\t\tgl.uniformMatrix4fv(location, false, tmp);\n\t}\n\n\tsetUniform1f(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform1f(location, value);\n\t}\n\n\tsetUniformBoolean(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform1i(location, value);\n\t}\n\n\tsetUniformTexture(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform1i(location, value);\n\t}\n\n\tsetUniform2f(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform2f(location, value[0], value[1]);\n\t}\n\n\tsetUniform3f(name, value)\n\t{\n\t\tconst gl = this.gl;\n\t\tconst location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform3f(location, value[0], value[1], value[2]);\n\t}\n\n\tsetUniform(name, value)\n\t{\n\n\t\tif(value.constructor === THREE.Matrix4)\n\t\t{\n\t\t\tthis.setUniformMatrix4(name, value);\n\t\t}\n\t\telse if(typeof value === \"number\")\n\t\t{\n\t\t\tthis.setUniform1f(name, value);\n\t\t}\n\t\telse if(typeof value === \"boolean\")\n\t\t{\n\t\t\tthis.setUniformBoolean(name, value);\n\t\t}\n\t\telse if(value instanceof WebGLTexture)\n\t\t{\n\t\t\tthis.setUniformTexture(name, value);\n\t\t}\n\t\telse if(value instanceof Array)\n\t\t{\n\t\t\tif(value.length === 2)\n\t\t\t{\n\t\t\t\tthis.setUniform2f(name, value);\n\t\t\t}\n\t\t\telse if(value.length === 3)\n\t\t\t{\n\t\t\t\tthis.setUniform3f(name, value);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsole.error(\"Potree: Unhandled uniform type: \", name, value);\n\t\t}\n\n\t}\n\n\tsetUniform1i(name, value)\n\t{\n\t\tvar gl = this.gl;\n\t\tvar location = this.uniformLocations[name];\n\n\t\tif(location == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tgl.uniform1i(location, value);\n\t}\n}\n\nclass WebGLBuffer\n{\n\tconstructor()\n\t{\n\t\tthis.numElements = 0;\n\t\tthis.vao = null;\n\t\tthis.vbos = new Map();\n\t}\n}\n\n/**\n * Potree object is a wrapper to use Potree alongside other THREE based frameworks.\n * \n * The object can be used a normal Object3D.\n * \n * It is based on THREE.Mesh and automatically updates the point cloud based on visibility.\n * \n * Also takes care of geometry ajustments to allow the point clouds to be frustum culled.\n */\nclass BasicGroup extends THREE.Mesh\n{\n\tconstructor()\n\t{\n\t\tsuper(new THREE.Geometry(), new THREE.MeshBasicMaterial({opacity:0.0, wireframe:false, transparent:true}));\n\n\t\tthis.rotation.set(-Math.PI / 2, 0, 0);\n\n\t\tthis.frustumCulled = true;\n\t\tthis.pointclouds = [];\n\n\t\tthis.nodeSize = 30;\n\t\tthis.pointBudget = 1e10; //TODO <NOT USED>\n\t\tthis.nodeLoadRate = 2; //TODO <NOT USED>\n\t}\n\n\t/**\n\t * Empty raycast method to avoid getting valid collision detection with the box geometry attached.\n\t */\n\traycast(raycaster, intersects){}\n\n\t/**\n\t * Changes the point budget to be used by potree.\n\t */\n\tsetPointBudget(budget)\n\t{\n\t\tthis.pointBudget = budget;\n\t}\n\n\t/**\n\t * Used to update the point cloud visibility relative to a camera.\n\t * \n\t * Called automatically before rendering.\n\t */\n\tonBeforeRender(renderer, scene, camera, geometry, material, group)\n\t{\n\t\tfor(var i = 0; i < this.pointclouds.length; i++)\n\t\t{\n\t\t\tthis.pointclouds[i].minimumNodePixelSize = this.nodeSize;\n\t\t}\n\n\t\tupdatePointClouds(this.pointclouds, camera, renderer);\n\t}\n\n\t/**\n\t * Recalculate the box geometry attached to this group.\n\t * \n\t * The geometry its not visible and its only used for frustum culling.\n\t */\n\trecalculateBoxGeometry()\n\t{\n\t\tvar box = this.getBoundingBox();\n\t\t\n\t\tvar size = box.getSize(new THREE.Vector3());\n\t\tvar center = box.getCenter(new THREE.Vector3());\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.makeTranslation(center.x, -center.z, center.y);\n\n\t\tvar geometry = new THREE.BoxBufferGeometry(size.x, size.z, size.y);\n\t\tgeometry.applyMatrix(matrix);\n\n\t\tthis.geometry = geometry;\n\t}\n\n\t/**\n\t * Add an object as children of this scene.\n\t * \n\t * Point cloud objects are detected and used to recalculate the geometry box used for frustum culling.\n\t */\n\tadd(object)\n\t{\n\t\tTHREE.Object3D.prototype.add.call(this, object);\n\n\t\tif(object instanceof PointCloudTree)\n\t\t{\n\t\t\tobject.showBoundingBox = false;\n\t\t\tobject.generateDEM = false;\n\t\t\tthis.pointclouds.push(object);\n\t\t\tthis.recalculateBoxGeometry();\n\t\t}\n\t}\n\t\n\t/**\n\t * Remove object from group.\n\t * \n\t * Point cloud objects are detected and used to recalculate the geometry box used for frustum culling\n\t */\n\tremove(object)\n\t{\n\t\tTHREE.Object3D.prototype.remove.call(this, object);\n\n\t\tif(object instanceof PointCloudTree)\n\t\t{\n\t\t\tvar index = this.pointclouds.indexOf(object);\n\t\t\tif(index !== -1)\n\t\t\t{\n\t\t\t\tthis.pointclouds.splice(index, 1);\n\t\t\t\tthis.recalculateBoxGeometry();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \n\t * Get the point cloud bouding box.\n\t */\n\tgetBoundingBox()\n\t{\n\t\tvar box = new THREE.Box3();\n\n\t\tthis.updateMatrixWorld(true);\n\n\t\tfor(var i = 0; i < this.pointclouds.length; i++)\n\t\t{\n\t\t\tvar pointcloud = this.pointclouds[i];\n\t\t\tpointcloud.updateMatrixWorld(true);\n\t\t\tvar pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox ? pointcloud.pcoGeometry.tightBoundingBox : pointcloud.boundingBox;\n\t\t\tvar boxWorld = HelperUtils.computeTransformedBoundingBox(pointcloudBox, pointcloud.matrixWorld);\n\t\t\tbox.union(boxWorld);\n\t\t}\n\n\t\treturn box;\n\t}\n\n\t/** \n\t * Estimate the point cloud height at a given position.\n\t */\n\testimateHeightAt(position)\n\t{\n\t\tvar height = null;\n\t\tvar fromSpacing = Infinity;\n\n\t\tfor(var pointcloud of this.pointclouds)\n\t\t{\n\t\t\tif(pointcloud.root.geometryNode === undefined)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar pHeight = null;\n\t\t\tvar pFromSpacing = Infinity;\n\n\t\t\tvar lpos = position.clone().sub(pointcloud.position);\n\t\t\tlpos.z = 0;\n\t\t\tvar ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));\n\n\t\t\tvar stack = [pointcloud.root];\n\t\t\twhile(stack.length > 0)\n\t\t\t{\n\t\t\t\tvar node = stack.pop();\n\t\t\t\tvar box = node.getBoundingBox();\n\t\t\t\tvar inside = ray.intersectBox(box);\n\n\t\t\t\tif(!inside)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar h = node.geometryNode.mean.z + pointcloud.position.z + node.geometryNode.boundingBox.min.z;\n\n\t\t\t\tif(node.geometryNode.spacing <= pFromSpacing)\n\t\t\t\t{\n\t\t\t\t\tpHeight = h;\n\t\t\t\t\tpFromSpacing = node.geometryNode.spacing;\n\t\t\t\t}\n\n\t\t\t\tfor(var index of Object.keys(node.children))\n\t\t\t\t{\n\t\t\t\t\tvar child = node.children[index];\n\t\t\t\t\tif(child.geometryNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tstack.push(node.children[index]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(height === null || pFromSpacing < fromSpacing)\n\t\t\t{\n\t\t\t\theight = pHeight;\n\t\t\t\tfromSpacing = pFromSpacing;\n\t\t\t}\n\t\t}\n\n\t\treturn height;\n\t}\n}\n\nclass Group extends BasicGroup\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis.buffers = new Map();\n\t\tthis.shaders = new Map();\n\t\tthis.textures = new Map();\n\t\tthis.types = new Map();\n\t}\n\n\t/**\n\t * Get WebGL extensions required for the more advanced features.\n\t */\n\tgetExtensions(gl)\n\t{\n\t\tthis.types.set(Float32Array, gl.FLOAT);\n\t\tthis.types.set(Uint8Array, gl.UNSIGNED_BYTE);\n\t\tthis.types.set(Uint16Array, gl.UNSIGNED_SHORT);\n\t\t\n\t\tvar extVAO = gl.getExtension(\"OES_vertex_array_object\");\n\t\tgl.createVertexArray = extVAO.createVertexArrayOES.bind(extVAO);\n\t\tgl.bindVertexArray = extVAO.bindVertexArrayOES.bind(extVAO);\n\t}\n\n\t/**\n\t * Update the potree group before rendering.\n\t */\n\tonBeforeRender(renderer, scene, camera, geometry, material, group)\n\t{\n\t\tsuper.onBeforeRender(renderer, scene, camera, geometry, material, group);\n\n\t\tvar gl = renderer.getContext();\n\t\tif(gl.bindVertexArray === undefined)\n\t\t{\n\t\t\tthis.getExtensions(gl);\n\t\t}\n\n\t\tvar result = this.fetchOctrees();\n\n\t\tfor(var octree of result.octrees)\n\t\t{\n\t\t\tvar nodes = octree.visibleNodes;\n\t\t\tthis.renderOctree(renderer, octree, nodes, camera);\n\t\t}\n\n\t\tgl.activeTexture(gl.TEXTURE1);\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\n\t\trenderer.state.reset();\n\t}\n\n\tcreateBuffer(gl, geometry)\n\t{\n\t\tvar webglBuffer = new WebGLBuffer();\n\t\twebglBuffer.vao = gl.createVertexArray();\n\t\twebglBuffer.numElements = geometry.attributes.position.count;\n\n\t\tgl.bindVertexArray(webglBuffer.vao);\n\n\t\tfor(var attributeName in geometry.attributes)\n\t\t{\n\t\t\tvar bufferAttribute = geometry.attributes[attributeName];\n\n\t\t\tvar vbo = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, bufferAttribute.array, gl.STATIC_DRAW);\n\n\t\t\tvar attributeLocation = AttributeLocations[attributeName];\n\t\t\tvar normalized = bufferAttribute.normalized;\n\t\t\tvar type = this.types.get(bufferAttribute.array.constructor);\n\n\t\t\tif(type !== undefined)\n\t\t\t{\n\t\t\t\tgl.vertexAttribPointer(attributeLocation, bufferAttribute.itemSize, type, normalized, 0, 0);\n\t\t\t\tgl.enableVertexAttribArray(attributeLocation);\n\t\t\t}\n\n\t\t\twebglBuffer.vbos.set(attributeName,\n\t\t\t{\n\t\t\t\thandle: vbo,\n\t\t\t\tname: attributeName,\n\t\t\t\tcount: bufferAttribute.count,\n\t\t\t\titemSize: bufferAttribute.itemSize,\n\t\t\t\ttype: geometry.attributes.position.array.constructor,\n\t\t\t\tversion: 0\n\t\t\t});\n\t\t}\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t\tgl.bindVertexArray(null);\n\n\t\treturn webglBuffer;\n\t}\n\n\tupdateBuffer(gl, geometry)\n\t{\n\t\tvar webglBuffer = this.buffers.get(geometry);\n\n\t\tgl.bindVertexArray(webglBuffer.vao);\n\n\t\tfor(var attributeName in geometry.attributes)\n\t\t{\n\t\t\tvar bufferAttribute = geometry.attributes[attributeName];\n\n\t\t\tvar attributeLocation = AttributeLocations[attributeName];\n\t\t\tvar normalized = bufferAttribute.normalized;\n\t\t\tvar type = this.types.get(bufferAttribute.array.constructor);\n\n\t\t\tvar vbo = null;\n\t\t\tif(!webglBuffer.vbos.has(attributeName))\n\t\t\t{\n\t\t\t\tvbo = gl.createBuffer();\n\n\t\t\t\twebglBuffer.vbos.set(attributeName,\n\t\t\t\t{\n\t\t\t\t\thandle: vbo,\n\t\t\t\t\tname: attributeName,\n\t\t\t\t\tcount: bufferAttribute.count,\n\t\t\t\t\titemSize: bufferAttribute.itemSize,\n\t\t\t\t\ttype: geometry.attributes.position.array.constructor,\n\t\t\t\t\tversion: bufferAttribute.version\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvbo = webglBuffer.vbos.get(attributeName).handle;\n\t\t\t\twebglBuffer.vbos.get(attributeName).version = bufferAttribute.version;\n\t\t\t}\n\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, bufferAttribute.array, gl.STATIC_DRAW);\n\t\t\tgl.vertexAttribPointer(attributeLocation, bufferAttribute.itemSize, type, normalized, 0, 0);\n\t\t\tgl.enableVertexAttribArray(attributeLocation);\n\t\t}\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t\tgl.bindVertexArray(null);\n\t}\n\n\tfetchOctrees()\n\t{\n\t\tvar octrees = [];\n\t\tvar stack = [this];\n\n\t\twhile(stack.length > 0)\n\t\t{\n\t\t\tvar node = stack.pop();\n\n\t\t\tif(node instanceof PointCloudTree)\n\t\t\t{\n\t\t\t\toctrees.push(node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar visibleChildren = node.children.filter(c => c.visible);\n\t\t\tstack.push(...visibleChildren);\n\t\t}\n\n\t\tvar result =\n\t\t{\n\t\t\toctrees: octrees\n\t\t};\n\n\t\treturn result;\n\t}\n\n\trenderNodes(renderer, octree, nodes, visibilityTextureData, camera, shader)\n\t{\n\t\tvar gl = renderer.getContext();\n\t\tvar material = octree.material;\n\t\tvar view = camera.matrixWorldInverse;\n\n\t\tvar worldView = new THREE.Matrix4();\n\t\tvar mat4holder = new Float32Array(16);\n\n\t\tfor(var node of nodes)\n\t\t{\n\t\t\tif(Global.debug.allowedNodes !== undefined)\n\t\t\t{\n\t\t\t\tif(!Global.debug.allowedNodes.includes(node.name))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar world = node.sceneNode.matrixWorld;\n\t\t\tworldView.multiplyMatrices(view, world);\n\n\t\t\tif(visibilityTextureData)\n\t\t\t{\n\t\t\t\tvar vnStart = visibilityTextureData.offsets.get(node);\n\t\t\t\tshader.setUniform1f(\"uVNStart\", vnStart);\n\t\t\t}\n\n\t\t\tvar level = node.getLevel();\n\t\t\tshader.setUniform(\"uDebug\", node.debug === true);\n\n\t\t\tvar isLeaf;\n\t\t\tif(node instanceof PointCloudOctreeNode)\n\t\t\t{\n\t\t\t\tisLeaf = Object.keys(node.children).length === 0;\n\t\t\t}\n\t\t\telse if(node instanceof PointCloudArena4DNode)\n\t\t\t{\n\t\t\t\tisLeaf = node.geometryNode.isLeaf;\n\t\t\t}\n\t\t\tshader.setUniform(\"uIsLeafNode\", isLeaf);\n\n\t\t\t//TODO <consider passing matrices in an array to avoid uniformMatrix4fv overhead>\n\t\t\tvar lModel = shader.uniformLocations[\"modelMatrix\"];\n\t\t\tif(lModel)\n\t\t\t{\n\t\t\t\tmat4holder.set(world.elements);\n\t\t\t\tgl.uniformMatrix4fv(lModel, false, mat4holder);\n\t\t\t}\n\n\t\t\tvar lModelView = shader.uniformLocations[\"modelViewMatrix\"];\n\t\t\tmat4holder.set(worldView.elements);\n\t\t\tgl.uniformMatrix4fv(lModelView, false, mat4holder);\n\n\t\t\t//Clip Polygons\n\t\t\tif(material.clipPolygons && material.clipPolygons.length > 0)\n\t\t\t{\n\t\t\t\tvar clipPolygonVCount = [];\n\t\t\t\tvar worldViewProjMatrices = [];\n\n\t\t\t\tfor(var clipPolygon of material.clipPolygons)\n\t\t\t\t{\n\t\t\t\t\tvar view = clipPolygon.viewMatrix;\n\t\t\t\t\tvar proj = clipPolygon.projMatrix;\n\n\t\t\t\t\tvar worldViewProj = proj.clone().multiply(view).multiply(world);\n\n\t\t\t\t\tclipPolygonVCount.push(clipPolygon.markers.length);\n\t\t\t\t\tworldViewProjMatrices.push(worldViewProj);\n\t\t\t\t}\n\n\t\t\t\tvar flattenedMatrices = [].concat(...worldViewProjMatrices.map(m => m.elements));\n\n\t\t\t\tvar flattenedVertices = new Array(8 * 3 * material.clipPolygons.length);\n\t\t\t\tfor(var i = 0; i < material.clipPolygons.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar clipPolygon = material.clipPolygons[i];\n\t\t\t\t\t\n\t\t\t\t\tfor(var j = 0; j < clipPolygon.markers.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tflattenedVertices[i * 24 + (j * 3 + 0)] = clipPolygon.markers[j].position.x;\n\t\t\t\t\t\tflattenedVertices[i * 24 + (j * 3 + 1)] = clipPolygon.markers[j].position.y;\n\t\t\t\t\t\tflattenedVertices[i * 24 + (j * 3 + 2)] = clipPolygon.markers[j].position.z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar lClipPolygonVCount = shader.uniformLocations[\"uClipPolygonVCount[0]\"];\n\t\t\t\tgl.uniform1iv(lClipPolygonVCount, clipPolygonVCount);\n\n\t\t\t\tvar lClipPolygonVP = shader.uniformLocations[\"uClipPolygonWVP[0]\"];\n\t\t\t\tgl.uniformMatrix4fv(lClipPolygonVP, false, flattenedMatrices);\n\n\t\t\t\tvar lClipPolygons = shader.uniformLocations[\"uClipPolygonVertices[0]\"];\n\t\t\t\tgl.uniform3fv(lClipPolygons, flattenedVertices);\n\t\t\t}\n\n\t\t\tshader.setUniform1f(\"uLevel\", level);\n\t\t\tshader.setUniform1f(\"uNodeSpacing\", node.geometryNode.estimatedSpacing);\n\t\t\tshader.setUniform1f(\"uPCIndex\", i);\n\n\t\t\t/*\n\t\t\tif(shadowMaps.length > 0)\n\t\t\t{\n\t\t\t\tvar lShadowMap = shader.uniformLocations[\"uShadowMap[0]\"];\n\n\t\t\t\tshader.setUniform3f(\"uShadowColor\", material.uniforms.uShadowColor.value);\n\n\t\t\t\tvar bindingStart = 5;\n\t\t\t\tvar bindingPoints = new Array(shadowMaps.length).fill(bindingStart).map((a, i) => (a + i));\n\t\t\t\tgl.uniform1iv(lShadowMap, bindingPoints);\n\n\t\t\t\tfor(var i = 0; i < shadowMaps.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar shadowMap = shadowMaps[i];\n\t\t\t\t\tvar bindingPoint = bindingPoints[i];\n\t\t\t\t\tvar glTexture = renderer.properties.get(shadowMap.target.texture).__webglTexture;\n\n\t\t\t\t\tgl.activeTexture(gl[`TEXTURE${bindingPoint}`]);\n\t\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, glTexture);\n\t\t\t\t}\n\n\t\t\t\tvar worldViewMatrices = shadowMaps.map(sm => sm.camera.matrixWorldInverse).map(view => new THREE.Matrix4().multiplyMatrices(view, world))\n\n\t\t\t\tvar flattenedMatrices = [].concat(...worldViewMatrices.map(c => c.elements));\n\t\t\t\tvar lWorldView = shader.uniformLocations[\"uShadowWorldView[0]\"];\n\t\t\t\tgl.uniformMatrix4fv(lWorldView, false, flattenedMatrices);\n\n\t\t\t\tflattenedMatrices = [].concat(...shadowMaps.map(sm => sm.camera.projectionMatrix.elements));\n\t\t\t\tvar lProj = shader.uniformLocations[\"uShadowProj[0]\"];\n\t\t\t\tgl.uniformMatrix4fv(lProj, false, flattenedMatrices);\n\t\t\t}\n\t\t\t*/\n\n\t\t\tvar geometry = node.geometryNode.geometry;\n\t\t\tvar webglBuffer = null;\n\t\t\tif(!this.buffers.has(geometry))\n\t\t\t{\n\t\t\t\twebglBuffer = this.createBuffer(gl, geometry);\n\t\t\t\tthis.buffers.set(geometry, webglBuffer);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twebglBuffer = this.buffers.get(geometry);\n\t\t\t\tfor(var attributeName in geometry.attributes)\n\t\t\t\t{\n\t\t\t\t\tvar attribute = geometry.attributes[attributeName];\n\t\t\t\t\tif(attribute.version > webglBuffer.vbos.get(attributeName).version)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.updateBuffer(gl, geometry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgl.bindVertexArray(webglBuffer.vao);\n\t\t\tgl.drawArrays(gl.POINTS, 0, webglBuffer.numElements);\n\t\t}\n\n\t\tgl.bindVertexArray(null);\n\t}\n\n\trenderOctree(renderer, octree, nodes, camera)\n\t{\n\t\tvar gl = renderer.getContext();\n\t\tvar material = octree.material;\n\t\tvar shadowMaps = [];\n\t\tvar view = camera.matrixWorldInverse;\n\t\tvar viewInv = camera.matrixWorld;\n\t\tvar proj = camera.projectionMatrix;\n\t\tvar projInv = new THREE.Matrix4().getInverse(proj);\n\t\tvar worldView = new THREE.Matrix4();\n\n\t\tvar visibilityTextureData = null;\n\t\tvar currentTextureBindingPoint = 0;\n\n\t\tif(material.pointSizeType === PointSizeType.ADAPTIVE || material.pointColorType === PointColorType.LOD)\n\t\t{\n\t\t\tvisibilityTextureData = octree.computeVisibilityTextureData(nodes, camera);\n\n\t\t\tvar vnt = material.visibleNodesTexture;\n\t\t\tvnt.image.data.set(visibilityTextureData.data);\n\t\t\tvnt.needsUpdate = true;\n\t\t}\n\n\t\tvar shader = null;\n\n\t\tif(!this.shaders.has(material))\n\t\t{\n\t\t\tshader = new Shader(gl, \"pointcloud\", material.vertexShader, material.fragmentShader);\n\t\t\tthis.shaders.set(material, shader);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshader = this.shaders.get(material);\n\t\t}\n\n\t\tvar numSnapshots = material.snapEnabled ? material.numSnapshots : 0;\n\t\tvar numClipBoxes = (material.clipBoxes && material.clipBoxes.length) ? material.clipBoxes.length : 0;\n\t\tvar numClipPolygons = (material.clipPolygons && material.clipPolygons.length) ? material.clipPolygons.length : 0;\n\t\tvar numClipSpheres = 0;\n\n\t\tvar defines = [\n\t\t\t\"#define num_shadowmaps\" + shadowMaps.length,\n\t\t\t\"#define num_snapshots\" + numSnapshots,\n\t\t\t\"#define num_clipboxes\" + numClipBoxes,\n\t\t\t\"#define num_clipspheres\" + numClipSpheres,\n\t\t\t\"#define num_clippolygons\" + numClipPolygons,\n\t\t];\n\n\t\tvar definesString = defines.join(\"\\n\");\n\t\tvar vs = definesString + \"\\n\" + material.vertexShader;\n\t\tvar fs = definesString + \"\\n\" + material.fragmentShader;\n\n\t\tshader.update(vs, fs);\n\n\t\tmaterial.needsUpdate = false;\n\n\t\tfor(var uniformName of Object.keys(material.uniforms))\n\t\t{\n\t\t\tvar uniform = material.uniforms[uniformName];\n\n\t\t\tif(uniform.type == \"t\")\n\t\t\t{\n\t\t\t\tvar texture = uniform.value;\n\n\t\t\t\tif(!texture)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(!this.textures.has(texture))\n\t\t\t\t{\n\t\t\t\t\tvar webglTexture = new WebGLTexture(gl, texture);\n\t\t\t\t\tthis.textures.set(texture, webglTexture);\n\t\t\t\t}\n\n\t\t\t\tvar webGLTexture = this.textures.get(texture);\n\t\t\t\twebGLTexture.update();\n\t\t\t}\n\t\t}\n\n\t\tgl.useProgram(shader.program);\n\n\t\tif(material.opacity < 1.0)\n\t\t{\n\t\t\tgl.enable(gl.BLEND);\n\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\t\t\tgl.depthMask(false);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tgl.depthMask(true);\n\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t}\n\n\t\t//Update shader uniforms\n\t\tshader.setUniformMatrix4(\"projectionMatrix\", proj);\n\t\tshader.setUniformMatrix4(\"viewMatrix\", view);\n\t\tshader.setUniformMatrix4(\"uViewInv\", viewInv);\n\t\tshader.setUniformMatrix4(\"uProjInv\", projInv);\n\n\t\tvar screenWidth = material.screenWidth;\n\t\tvar screenHeight = material.screenHeight;\n\n\t\tshader.setUniform1f(\"uScreenWidth\", screenWidth);\n\t\tshader.setUniform1f(\"uScreenHeight\", screenHeight);\n\t\tshader.setUniform1f(\"fov\", Math.PI * camera.fov / 180);\n\t\tshader.setUniform1f(\"near\", camera.near);\n\t\tshader.setUniform1f(\"far\", camera.far);\n\t\t\n\t\t//Set log\n\t\tif(renderer.capabilities.logarithmicDepthBuffer)\n\t\t{\n\t\t\tshader.setUniform(\"logDepthBufFC\", 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n\t\t}\n\n\t\t//Camera configuration\n\t\tif(camera instanceof THREE.OrthographicCamera)\n\t\t{\n\t\t\tshader.setUniform(\"uUseOrthographicCamera\", true);\n\t\t\tshader.setUniform(\"uOrthoWidth\", camera.right - camera.left); \n\t\t\tshader.setUniform(\"uOrthoHeight\", camera.top - camera.bottom);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshader.setUniform(\"uUseOrthographicCamera\", false);\n\t\t}\n\n\t\t//Clip task\n\t\tif(material.clipBoxes.length + material.clipPolygons.length === 0)\n\t\t{\n\t\t\tshader.setUniform1i(\"clipTask\", ClipTask.NONE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshader.setUniform1i(\"clipTask\", material.clipTask);\n\t\t}\n\n\t\tshader.setUniform1i(\"clipMethod\", material.clipMethod);\n\n\t\t//Clipboxes\n\t\tif(material.clipBoxes && material.clipBoxes.length > 0)\n\t\t{\n\t\t\tvar lClipBoxes = shader.uniformLocations[\"clipBoxes[0]\"];\n\t\t\tgl.uniformMatrix4fv(lClipBoxes, false, material.uniforms.clipBoxes.value);\n\t\t}\n\n\t\t//Clispheres\n\t\t/*if(material.clipSpheres && material.clipSpheres.length > 0)\n\t\t{\n\t\t\tvar clipSpheres = material.clipSpheres;\n\t\t\tvar matrices = [];\n\t\t\tfor(var clipSphere of clipSpheres)\n\t\t\t{\n\t\t\t\tvar clipToWorld = clipSphere.matrixWorld;\n\t\t\t\tvar viewToWorld = camera.matrixWorld\n\t\t\t\tvar worldToClip = new THREE.Matrix4().getInverse(clipToWorld);\n\n\t\t\t\tvar viewToClip = new THREE.Matrix4().multiplyMatrices(worldToClip, viewToWorld);\n\n\t\t\t\tmatrices.push(viewToClip);\n\t\t\t}\n\n\t\t\tvar flattenedMatrices = [].concat(...matrices.map(matrix => matrix.elements));\n\n\t\t\tvar lClipSpheres = shader.uniformLocations[\"uClipSpheres[0]\"];\n\t\t\tgl.uniformMatrix4fv(lClipSpheres, false, flattenedMatrices);\n\t\t}*/\n\n\t\tshader.setUniform1f(\"size\", material.size);\n\t\tshader.setUniform1f(\"maxSize\", material.uniforms.maxSize.value);\n\t\tshader.setUniform1f(\"minSize\", material.uniforms.minSize.value);\n\t\tshader.setUniform1f(\"uOctreeSpacing\", material.spacing);\n\t\tshader.setUniform(\"uOctreeSize\", material.uniforms.octreeSize.value);\n\t\tshader.setUniform3f(\"uColor\", material.color.toArray());\n\t\tshader.setUniform1f(\"uOpacity\", material.opacity);\n\t\tshader.setUniform2f(\"elevationRange\", material.elevationRange);\n\t\tshader.setUniform2f(\"intensityRange\", material.intensityRange);\n\t\tshader.setUniform1f(\"intensityGamma\", material.intensityGamma);\n\t\tshader.setUniform1f(\"intensityContrast\", material.intensityContrast);\n\t\tshader.setUniform1f(\"intensityBrightness\", material.intensityBrightness);\n\t\tshader.setUniform1f(\"rgbGamma\", material.rgbGamma);\n\t\tshader.setUniform1f(\"rgbContrast\", material.rgbContrast);\n\t\tshader.setUniform1f(\"rgbBrightness\", material.rgbBrightness);\n\t\tshader.setUniform1f(\"uTransition\", material.transition);\n\t\tshader.setUniform1f(\"wRGB\", material.weightRGB);\n\t\tshader.setUniform1f(\"wIntensity\", material.weightIntensity);\n\t\tshader.setUniform1f(\"wElevation\", material.weightElevation);\n\t\tshader.setUniform1f(\"wClassification\", material.weightClassification);\n\t\tshader.setUniform1f(\"wReturnNumber\", material.weightReturnNumber);\n\t\tshader.setUniform1f(\"wSourceID\", material.weightSourceID);\n\n\t\tvar vnWebGLTexture = this.textures.get(material.visibleNodesTexture);\n\t\tshader.setUniform1i(\"visibleNodesTexture\", currentTextureBindingPoint);\n\t\tgl.activeTexture(gl.TEXTURE0 + currentTextureBindingPoint);\n\t\tgl.bindTexture(vnWebGLTexture.target, vnWebGLTexture.id);\n\t\tcurrentTextureBindingPoint++;\n\n\t\tvar gradientTexture = this.textures.get(material.gradientTexture);\n\t\tshader.setUniform1i(\"gradient\", currentTextureBindingPoint);\n\t\tgl.activeTexture(gl.TEXTURE0 + currentTextureBindingPoint);\n\t\tgl.bindTexture(gradientTexture.target, gradientTexture.id);\n\t\tcurrentTextureBindingPoint++;\n\n\t\tvar classificationTexture = this.textures.get(material.classificationTexture);\n\t\tshader.setUniform1i(\"classificationLUT\", currentTextureBindingPoint);\n\t\tgl.activeTexture(gl.TEXTURE0 + currentTextureBindingPoint);\n\t\tgl.bindTexture(classificationTexture.target, classificationTexture.id);\n\t\tcurrentTextureBindingPoint++;\n\n\t\tif(material.snapEnabled === true)\n\t\t{\n\t\t\tvar lSnapshot = shader.uniformLocations[\"uSnapshot[0]\"];\n\t\t\tvar lSnapshotDepth = shader.uniformLocations[\"uSnapshotDepth[0]\"];\n\n\t\t\tvar bindingStart = currentTextureBindingPoint;\n\t\t\tvar lSnapshotBindingPoints = new Array(5).fill(bindingStart).map((a, i) => (a + i));\n\t\t\tvar lSnapshotDepthBindingPoints = new Array(5).fill(1 + Math.max(...lSnapshotBindingPoints)).map((a, i) => (a + i));\n\t\t\tcurrentTextureBindingPoint = 1 + Math.max(...lSnapshotDepthBindingPoints);\n\n\t\t\tgl.uniform1iv(lSnapshot, lSnapshotBindingPoints);\n\t\t\tgl.uniform1iv(lSnapshotDepth, lSnapshotDepthBindingPoints);\n\n\t\t\tfor(var i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tvar texture = material.uniforms[\"uSnapshot\"].value[i];\n\t\t\t\tvar textureDepth = material.uniforms[\"uSnapshotDepth\"].value[i];\n\n\t\t\t\tif(!texture)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar snapTexture = renderer.properties.get(texture).__webglTexture;\n\t\t\t\tvar snapTextureDepth = renderer.properties.get(textureDepth).__webglTexture;\n\n\t\t\t\tvar bindingPoint = lSnapshotBindingPoints[i];\n\t\t\t\tvar depthBindingPoint = lSnapshotDepthBindingPoints[i];\n\n\t\t\t\tgl.activeTexture(gl[`TEXTURE${bindingPoint}`]);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, snapTexture);\n\n\t\t\t\tgl.activeTexture(gl[`TEXTURE${depthBindingPoint}`]);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, snapTextureDepth);\n\t\t\t}\n\n\t\t\tvar flattenedMatrices = [].concat(...material.uniforms.uSnapView.value.map(c => c.elements));\n\t\t\tvar lSnapView = shader.uniformLocations[\"uSnapView[0]\"];\n\t\t\tgl.uniformMatrix4fv(lSnapView, false, flattenedMatrices);\n\n\t\t\tflattenedMatrices = [].concat(...material.uniforms.uSnapProj.value.map(c => c.elements));\n\t\t\tvar lSnapProj = shader.uniformLocations[\"uSnapProj[0]\"];\n\t\t\tgl.uniformMatrix4fv(lSnapProj, false, flattenedMatrices);\n\n\t\t\tflattenedMatrices = [].concat(...material.uniforms.uSnapProjInv.value.map(c => c.elements));\n\t\t\tvar lSnapProjInv = shader.uniformLocations[\"uSnapProjInv[0]\"];\n\t\t\tgl.uniformMatrix4fv(lSnapProjInv, false, flattenedMatrices);\n\n\t\t\tflattenedMatrices = [].concat(...material.uniforms.uSnapViewInv.value.map(c => c.elements));\n\t\t\tvar lSnapViewInv = shader.uniformLocations[\"uSnapViewInv[0]\"];\n\t\t\tgl.uniformMatrix4fv(lSnapViewInv, false, flattenedMatrices);\n\t\t}\n\n\t\tthis.renderNodes(renderer, octree, nodes, visibilityTextureData, camera, shader);\n\n\t\tgl.activeTexture(gl.TEXTURE2);\n\t\tgl.bindTexture(gl.TEXTURE_2D, null);\n\t\tgl.activeTexture(gl.TEXTURE0);\n\t}\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'AttributeLocations', { enumerable: true, configurable: true, get: function() { return AttributeLocations; } });Object.defineProperty(exports, 'BasicGroup', { enumerable: true, configurable: true, get: function() { return BasicGroup; } });Object.defineProperty(exports, 'BinaryHeap', { enumerable: true, configurable: true, get: function() { return BinaryHeap; } });Object.defineProperty(exports, 'BinaryLoader', { enumerable: true, configurable: true, get: function() { return BinaryLoader; } });Object.defineProperty(exports, 'Classification', { enumerable: true, configurable: true, get: function() { return Classification; } });Object.defineProperty(exports, 'ClipMethod', { enumerable: true, configurable: true, get: function() { return ClipMethod; } });Object.defineProperty(exports, 'ClipTask', { enumerable: true, configurable: true, get: function() { return ClipTask; } });Object.defineProperty(exports, 'DEM', { enumerable: true, configurable: true, get: function() { return DEM$1; } });Object.defineProperty(exports, 'DEMNode', { enumerable: true, configurable: true, get: function() { return DEMNode; } });Object.defineProperty(exports, 'EptBinaryLoader', { enumerable: true, configurable: true, get: function() { return EptBinaryLoader; } });Object.defineProperty(exports, 'EptLaszipLoader', { enumerable: true, configurable: true, get: function() { return EptLaszipLoader; } });Object.defineProperty(exports, 'EptLoader', { enumerable: true, configurable: true, get: function() { return EptLoader; } });Object.defineProperty(exports, 'Global', { enumerable: true, configurable: true, get: function() { return Global; } });Object.defineProperty(exports, 'Gradients', { enumerable: true, configurable: true, get: function() { return Gradients; } });Object.defineProperty(exports, 'GreyhoundBinaryLoader', { enumerable: true, configurable: true, get: function() { return GreyhoundBinaryLoader; } });Object.defineProperty(exports, 'GreyhoundLoader', { enumerable: true, configurable: true, get: function() { return GreyhoundLoader; } });Object.defineProperty(exports, 'GreyhoundUtils', { enumerable: true, configurable: true, get: function() { return GreyhoundUtils; } });Object.defineProperty(exports, 'Group', { enumerable: true, configurable: true, get: function() { return Group; } });Object.defineProperty(exports, 'HelperUtils', { enumerable: true, configurable: true, get: function() { return HelperUtils; } });Object.defineProperty(exports, 'LASLAZLoader', { enumerable: true, configurable: true, get: function() { return LASLAZLoader; } });Object.defineProperty(exports, 'LASLoader', { enumerable: true, configurable: true, get: function() { return LASLoader; } });Object.defineProperty(exports, 'LRU', { enumerable: true, configurable: true, get: function() { return LRU; } });Object.defineProperty(exports, 'POCLoader', { enumerable: true, configurable: true, get: function() { return POCLoader; } });Object.defineProperty(exports, 'PointAttribute', { enumerable: true, configurable: true, get: function() { return PointAttribute; } });Object.defineProperty(exports, 'PointAttributeNames', { enumerable: true, configurable: true, get: function() { return PointAttributeNames; } });Object.defineProperty(exports, 'PointAttributeTypes', { enumerable: true, configurable: true, get: function() { return PointAttributeTypes; } });Object.defineProperty(exports, 'PointAttributes', { enumerable: true, configurable: true, get: function() { return PointAttributes; } });Object.defineProperty(exports, 'PointCloudArena4D', { enumerable: true, configurable: true, get: function() { return PointCloudArena4D; } });Object.defineProperty(exports, 'PointCloudArena4DGeometry', { enumerable: true, configurable: true, get: function() { return PointCloudArena4DGeometry; } });Object.defineProperty(exports, 'PointCloudEptGeometry', { enumerable: true, configurable: true, get: function() { return PointCloudEptGeometry; } });Object.defineProperty(exports, 'PointCloudGreyhoundGeometry', { enumerable: true, configurable: true, get: function() { return PointCloudGreyhoundGeometry; } });Object.defineProperty(exports, 'PointCloudMaterial', { enumerable: true, configurable: true, get: function() { return PointCloudMaterial; } });Object.defineProperty(exports, 'PointCloudOctree', { enumerable: true, configurable: true, get: function() { return PointCloudOctree; } });Object.defineProperty(exports, 'PointCloudOctreeGeometry', { enumerable: true, configurable: true, get: function() { return PointCloudOctreeGeometry; } });Object.defineProperty(exports, 'PointCloudTree', { enumerable: true, configurable: true, get: function() { return PointCloudTree; } });Object.defineProperty(exports, 'PointColorType', { enumerable: true, configurable: true, get: function() { return PointColorType; } });Object.defineProperty(exports, 'PointShape', { enumerable: true, configurable: true, get: function() { return PointShape; } });Object.defineProperty(exports, 'PointSizeType', { enumerable: true, configurable: true, get: function() { return PointSizeType; } });Object.defineProperty(exports, 'Points', { enumerable: true, configurable: true, get: function() { return Points; } });Object.defineProperty(exports, 'Shader', { enumerable: true, configurable: true, get: function() { return Shader; } });Object.defineProperty(exports, 'Shaders', { enumerable: true, configurable: true, get: function() { return Shaders; } });Object.defineProperty(exports, 'TreeType', { enumerable: true, configurable: true, get: function() { return TreeType; } });Object.defineProperty(exports, 'VersionUtils', { enumerable: true, configurable: true, get: function() { return VersionUtils; } });Object.defineProperty(exports, 'WebGLBuffer', { enumerable: true, configurable: true, get: function() { return WebGLBuffer; } });Object.defineProperty(exports, 'WebGLTexture', { enumerable: true, configurable: true, get: function() { return WebGLTexture; } });Object.defineProperty(exports, 'WorkerManager', { enumerable: true, configurable: true, get: function() { return WorkerManager; } });Object.defineProperty(exports, 'loadPointCloud', { enumerable: true, configurable: true, get: function() { return loadPointCloud; } });Object.defineProperty(exports, 'updatePointClouds', { enumerable: true, configurable: true, get: function() { return updatePointClouds; } });Object.defineProperty(exports, 'updateVisibility', { enumerable: true, configurable: true, get: function() { return updateVisibility; } });Object.defineProperty(exports, 'updateVisibilityStructures', { enumerable: true, configurable: true, get: function() { return updateVisibilityStructures; } });\n"]}